"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@hello-pangea";
exports.ids = ["vendor-chunks/@hello-pangea"];
exports.modules = {

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/dist/dnd.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragDropContext: () => (/* binding */ DragDropContext),\n/* harmony export */   Draggable: () => (/* binding */ PublicDraggable),\n/* harmony export */   Droppable: () => (/* binding */ ConnectedDroppable),\n/* harmony export */   useKeyboardSensor: () => (/* binding */ useKeyboardSensor),\n/* harmony export */   useMouseSensor: () => (/* binding */ useMouseSensor),\n/* harmony export */   useTouchSensor: () => (/* binding */ useTouchSensor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/@hello-pangea/dnd/node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/@hello-pangea/dnd/node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var css_box_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! css-box-model */ \"(ssr)/./node_modules/css-box-model/dist/css-box-model.esm.js\");\n/* harmony import */ var raf_schd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! raf-schd */ \"(ssr)/./node_modules/raf-schd/dist/raf-schd.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n\n\n\n\n\n\nconst isProduction$1 = \"development\" === \"production\";\nconst spacesAndTabs = /[ \\t]{2,}/g;\nconst lineStartWithSpaces = /^[ \\t]*/gm;\nconst clean$2 = (value)=>value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\nconst getDevMessage = (message)=>clean$2(`\n  %c@hello-pangea/dnd\n\n  %c${clean$2(message)}\n\n  %cðŸ‘·â€ This is a development only message. It will be removed in production builds.\n`);\nconst getFormattedMessage = (message)=>[\n        getDevMessage(message),\n        \"color: #00C584; font-size: 1.2em; font-weight: bold;\",\n        \"line-height: 1.5\",\n        \"color: #723874;\"\n    ];\nconst isDisabledFlag = \"__@hello-pangea/dnd-disable-dev-warnings\";\nfunction log(type, message) {\n    if (isProduction$1) {\n        return;\n    }\n    if (false) {}\n    console[type](...getFormattedMessage(message));\n}\nconst warning = log.bind(null, \"warn\");\nconst error = log.bind(null, \"error\");\nfunction noop$2() {}\nfunction getOptions(shared, fromBinding) {\n    return {\n        ...shared,\n        ...fromBinding\n    };\n}\nfunction bindEvents(el, bindings, sharedOptions) {\n    const unbindings = bindings.map((binding)=>{\n        const options = getOptions(sharedOptions, binding.options);\n        el.addEventListener(binding.eventName, binding.fn, options);\n        return function unbind() {\n            el.removeEventListener(binding.eventName, binding.fn, options);\n        };\n    });\n    return function unbindAll() {\n        unbindings.forEach((unbind)=>{\n            unbind();\n        });\n    };\n}\nconst isProduction = \"development\" === \"production\";\nconst prefix$1 = \"Invariant failed\";\nclass RbdInvariant extends Error {\n}\nRbdInvariant.prototype.toString = function toString() {\n    return this.message;\n};\nfunction invariant(condition, message) {\n    if (isProduction) {\n        throw new RbdInvariant(prefix$1);\n    } else {\n        throw new RbdInvariant(`${prefix$1}: ${message || \"\"}`);\n    }\n}\nclass ErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {\n    constructor(...args){\n        super(...args);\n        this.callbacks = null;\n        this.unbind = noop$2;\n        this.onWindowError = (event)=>{\n            const callbacks = this.getCallbacks();\n            if (callbacks.isDragging()) {\n                callbacks.tryAbort();\n                 true ? warning(`\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      `) : 0;\n            }\n            const err = event.error;\n            if (err instanceof RbdInvariant) {\n                event.preventDefault();\n                if (true) {\n                    error(err.message);\n                }\n            }\n        };\n        this.getCallbacks = ()=>{\n            if (!this.callbacks) {\n                throw new Error(\"Unable to find AppCallbacks in <ErrorBoundary/>\");\n            }\n            return this.callbacks;\n        };\n        this.setCallbacks = (callbacks)=>{\n            this.callbacks = callbacks;\n        };\n    }\n    componentDidMount() {\n        this.unbind = bindEvents(window, [\n            {\n                eventName: \"error\",\n                fn: this.onWindowError\n            }\n        ]);\n    }\n    componentDidCatch(err) {\n        if (err instanceof RbdInvariant) {\n            if (true) {\n                error(err.message);\n            }\n            this.setState({});\n            return;\n        }\n        throw err;\n    }\n    componentWillUnmount() {\n        this.unbind();\n    }\n    render() {\n        return this.props.children(this.setCallbacks);\n    }\n}\nconst dragHandleUsageInstructions = `\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n`;\nconst position = (index)=>index + 1;\nconst onDragStart = (start)=>`\n  You have lifted an item in position ${position(start.source.index)}\n`;\nconst withLocation = (source, destination)=>{\n    const isInHomeList = source.droppableId === destination.droppableId;\n    const startPosition = position(source.index);\n    const endPosition = position(destination.index);\n    if (isInHomeList) {\n        return `\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `;\n    }\n    return `\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `;\n};\nconst withCombine = (id, source, combine)=>{\n    const inHomeList = source.droppableId === combine.droppableId;\n    if (inHomeList) {\n        return `\n      The item ${id}\n      has been combined with ${combine.draggableId}`;\n    }\n    return `\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `;\n};\nconst onDragUpdate = (update)=>{\n    const location = update.destination;\n    if (location) {\n        return withLocation(update.source, location);\n    }\n    const combine = update.combine;\n    if (combine) {\n        return withCombine(update.draggableId, update.source, combine);\n    }\n    return \"You are over an area that cannot be dropped on\";\n};\nconst returnedToStart = (source)=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`;\nconst onDragEnd = (result)=>{\n    if (result.reason === \"CANCEL\") {\n        return `\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;\n    }\n    const location = result.destination;\n    const combine = result.combine;\n    if (location) {\n        return `\n      You have dropped the item.\n      ${withLocation(result.source, location)}\n    `;\n    }\n    if (combine) {\n        return `\n      You have dropped the item.\n      ${withCombine(result.draggableId, result.source, combine)}\n    `;\n    }\n    return `\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `;\n};\nconst preset = {\n    dragHandleUsageInstructions,\n    onDragStart,\n    onDragUpdate,\n    onDragEnd\n};\nfunction isEqual$2(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (Number.isNaN(first) && Number.isNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for(let i = 0; i < newInputs.length; i++){\n        if (!isEqual$2(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction useMemo(getResult, inputs) {\n    const initial = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>({\n            inputs,\n            result: getResult()\n        }))[0];\n    const isFirstRun = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const committed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initial);\n    const useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));\n    const cache = useCache ? committed.current : {\n        inputs,\n        result: getResult()\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        isFirstRun.current = false;\n        committed.current = cache;\n    }, [\n        cache\n    ]);\n    return cache.result;\n}\nfunction useCallback(callback, inputs) {\n    return useMemo(()=>callback, inputs);\n}\nconst origin = {\n    x: 0,\n    y: 0\n};\nconst add = (point1, point2)=>({\n        x: point1.x + point2.x,\n        y: point1.y + point2.y\n    });\nconst subtract = (point1, point2)=>({\n        x: point1.x - point2.x,\n        y: point1.y - point2.y\n    });\nconst isEqual$1 = (point1, point2)=>point1.x === point2.x && point1.y === point2.y;\nconst negate = (point)=>({\n        x: point.x !== 0 ? -point.x : 0,\n        y: point.y !== 0 ? -point.y : 0\n    });\nconst patch = (line, value, otherValue = 0)=>{\n    if (line === \"x\") {\n        return {\n            x: value,\n            y: otherValue\n        };\n    }\n    return {\n        x: otherValue,\n        y: value\n    };\n};\nconst distance = (point1, point2)=>Math.sqrt((point2.x - point1.x) ** 2 + (point2.y - point1.y) ** 2);\nconst closest$1 = (target, points)=>Math.min(...points.map((point)=>distance(target, point)));\nconst apply = (fn)=>(point)=>({\n            x: fn(point.x),\n            y: fn(point.y)\n        });\nvar executeClip = (frame, subject)=>{\n    const result = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: Math.max(subject.top, frame.top),\n        right: Math.min(subject.right, frame.right),\n        bottom: Math.min(subject.bottom, frame.bottom),\n        left: Math.max(subject.left, frame.left)\n    });\n    if (result.width <= 0 || result.height <= 0) {\n        return null;\n    }\n    return result;\n};\nconst offsetByPosition = (spacing, point)=>({\n        top: spacing.top + point.y,\n        left: spacing.left + point.x,\n        bottom: spacing.bottom + point.y,\n        right: spacing.right + point.x\n    });\nconst getCorners = (spacing)=>[\n        {\n            x: spacing.left,\n            y: spacing.top\n        },\n        {\n            x: spacing.right,\n            y: spacing.top\n        },\n        {\n            x: spacing.left,\n            y: spacing.bottom\n        },\n        {\n            x: spacing.right,\n            y: spacing.bottom\n        }\n    ];\nconst noSpacing = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n};\nconst scroll$1 = (target, frame)=>{\n    if (!frame) {\n        return target;\n    }\n    return offsetByPosition(target, frame.scroll.diff.displacement);\n};\nconst increase = (target, axis, withPlaceholder)=>{\n    if (withPlaceholder && withPlaceholder.increasedBy) {\n        return {\n            ...target,\n            [axis.end]: target[axis.end] + withPlaceholder.increasedBy[axis.line]\n        };\n    }\n    return target;\n};\nconst clip = (target, frame)=>{\n    if (frame && frame.shouldClipSubject) {\n        return executeClip(frame.pageMarginBox, target);\n    }\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(target);\n};\nvar getSubject = ({ page, withPlaceholder, axis, frame })=>{\n    const scrolled = scroll$1(page.marginBox, frame);\n    const increased = increase(scrolled, axis, withPlaceholder);\n    const clipped = clip(increased, frame);\n    return {\n        page,\n        withPlaceholder,\n        active: clipped\n    };\n};\nvar scrollDroppable = (droppable, newScroll)=>{\n    !droppable.frame ?  true ? invariant() : 0 : void 0;\n    const scrollable = droppable.frame;\n    const scrollDiff = subtract(newScroll, scrollable.scroll.initial);\n    const scrollDisplacement = negate(scrollDiff);\n    const frame = {\n        ...scrollable,\n        scroll: {\n            initial: scrollable.scroll.initial,\n            current: newScroll,\n            diff: {\n                value: scrollDiff,\n                displacement: scrollDisplacement\n            },\n            max: scrollable.scroll.max\n        }\n    };\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: droppable.subject.withPlaceholder,\n        axis: droppable.axis,\n        frame\n    });\n    const result = {\n        ...droppable,\n        frame,\n        subject\n    };\n    return result;\n};\nfunction memoizeOne(resultFn, isEqual = areInputsEqual) {\n    let cache = null;\n    function memoized(...newArgs) {\n        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n            return cache.lastResult;\n        }\n        const lastResult = resultFn.apply(this, newArgs);\n        cache = {\n            lastResult,\n            lastArgs: newArgs,\n            lastThis: this\n        };\n        return lastResult;\n    }\n    memoized.clear = function clear() {\n        cache = null;\n    };\n    return memoized;\n}\nconst toDroppableMap = memoizeOne((droppables)=>droppables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDraggableMap = memoizeOne((draggables)=>draggables.reduce((previous, current)=>{\n        previous[current.descriptor.id] = current;\n        return previous;\n    }, {}));\nconst toDroppableList = memoizeOne((droppables)=>Object.values(droppables));\nconst toDraggableList = memoizeOne((draggables)=>Object.values(draggables));\nvar getDraggablesInsideDroppable = memoizeOne((droppableId, draggables)=>{\n    const result = toDraggableList(draggables).filter((draggable)=>droppableId === draggable.descriptor.droppableId).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n    return result;\n});\nfunction tryGetDestination(impact) {\n    if (impact.at && impact.at.type === \"REORDER\") {\n        return impact.at.destination;\n    }\n    return null;\n}\nfunction tryGetCombine(impact) {\n    if (impact.at && impact.at.type === \"COMBINE\") {\n        return impact.at.combine;\n    }\n    return null;\n}\nvar removeDraggableFromList = memoizeOne((remove, list)=>list.filter((item)=>item.descriptor.id !== remove.descriptor.id));\nvar moveToNextCombine = ({ isMovingForward, draggable, destination, insideDestination, previousImpact })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const location = tryGetDestination(previousImpact);\n    if (!location) {\n        return null;\n    }\n    function getImpact(target) {\n        const at = {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: target,\n                droppableId: destination.descriptor.id\n            }\n        };\n        return {\n            ...previousImpact,\n            at\n        };\n    }\n    const all = previousImpact.displaced.all;\n    const closestId = all.length ? all[0] : null;\n    if (isMovingForward) {\n        return closestId ? getImpact(closestId) : null;\n    }\n    const withoutDraggable = removeDraggableFromList(draggable, insideDestination);\n    if (!closestId) {\n        if (!withoutDraggable.length) {\n            return null;\n        }\n        const last = withoutDraggable[withoutDraggable.length - 1];\n        return getImpact(last.descriptor.id);\n    }\n    const indexOfClosest = withoutDraggable.findIndex((d)=>d.descriptor.id === closestId);\n    !(indexOfClosest !== -1) ?  true ? invariant(false, \"Could not find displaced item in set\") : 0 : void 0;\n    const proposedIndex = indexOfClosest - 1;\n    if (proposedIndex < 0) {\n        return null;\n    }\n    const before = withoutDraggable[proposedIndex];\n    return getImpact(before.descriptor.id);\n};\nvar isHomeOf = (draggable, destination)=>draggable.descriptor.droppableId === destination.descriptor.id;\nconst noDisplacedBy = {\n    point: origin,\n    value: 0\n};\nconst emptyGroups = {\n    invisible: {},\n    visible: {},\n    all: []\n};\nconst noImpact = {\n    displaced: emptyGroups,\n    displacedBy: noDisplacedBy,\n    at: null\n};\nvar isWithin = (lowerBound, upperBound)=>(value)=>lowerBound <= value && value <= upperBound;\nvar isPartiallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        if (isContained) {\n            return true;\n        }\n        const isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);\n        const isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);\n        const isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;\n        if (isPartiallyContained) {\n            return true;\n        }\n        const isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;\n        const isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;\n        const isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;\n        if (isTargetBiggerThanFrame) {\n            return true;\n        }\n        const isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;\n        return isTargetBiggerOnOneAxis;\n    };\n};\nvar isTotallyVisibleThroughFrame = (frame)=>{\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return (subject)=>{\n        const isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        return isContained;\n    };\n};\nconst vertical = {\n    direction: \"vertical\",\n    line: \"y\",\n    crossAxisLine: \"x\",\n    start: \"top\",\n    end: \"bottom\",\n    size: \"height\",\n    crossAxisStart: \"left\",\n    crossAxisEnd: \"right\",\n    crossAxisSize: \"width\"\n};\nconst horizontal = {\n    direction: \"horizontal\",\n    line: \"x\",\n    crossAxisLine: \"y\",\n    start: \"left\",\n    end: \"right\",\n    size: \"width\",\n    crossAxisStart: \"top\",\n    crossAxisEnd: \"bottom\",\n    crossAxisSize: \"height\"\n};\nvar isTotallyVisibleThroughFrameOnAxis = (axis)=>(frame)=>{\n        const isWithinVertical = isWithin(frame.top, frame.bottom);\n        const isWithinHorizontal = isWithin(frame.left, frame.right);\n        return (subject)=>{\n            if (axis === vertical) {\n                return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);\n            }\n            return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);\n        };\n    };\nconst getDroppableDisplaced = (target, destination)=>{\n    const displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;\n    return offsetByPosition(target, displacement);\n};\nconst isVisibleInDroppable = (target, destination, isVisibleThroughFrameFn)=>{\n    if (!destination.subject.active) {\n        return false;\n    }\n    return isVisibleThroughFrameFn(destination.subject.active)(target);\n};\nconst isVisibleInViewport = (target, viewport, isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target);\nconst isVisible$1 = ({ target: toBeDisplaced, destination, viewport, withDroppableDisplacement, isVisibleThroughFrameFn })=>{\n    const displacedTarget = withDroppableDisplacement ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;\n    return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);\n};\nconst isPartiallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame\n    });\nconst isTotallyVisible = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrame\n    });\nconst isTotallyVisibleOnAxis = (args)=>isVisible$1({\n        ...args,\n        isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)\n    });\nconst getShouldAnimate = (id, last, forceShouldAnimate)=>{\n    if (typeof forceShouldAnimate === \"boolean\") {\n        return forceShouldAnimate;\n    }\n    if (!last) {\n        return true;\n    }\n    const { invisible, visible } = last;\n    if (invisible[id]) {\n        return false;\n    }\n    const previous = visible[id];\n    return previous ? previous.shouldAnimate : true;\n};\nfunction getTarget(draggable, displacedBy) {\n    const marginBox = draggable.page.marginBox;\n    const expandBy = {\n        top: displacedBy.point.y,\n        right: 0,\n        bottom: 0,\n        left: displacedBy.point.x\n    };\n    return (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)((0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(marginBox, expandBy));\n}\nfunction getDisplacementGroups({ afterDragging, destination, displacedBy, viewport, forceShouldAnimate, last }) {\n    return afterDragging.reduce(function process(groups, draggable) {\n        const target = getTarget(draggable, displacedBy);\n        const id = draggable.descriptor.id;\n        groups.all.push(id);\n        const isVisible = isPartiallyVisible({\n            target,\n            destination,\n            viewport,\n            withDroppableDisplacement: true\n        });\n        if (!isVisible) {\n            groups.invisible[draggable.descriptor.id] = true;\n            return groups;\n        }\n        const shouldAnimate = getShouldAnimate(id, last, forceShouldAnimate);\n        const displacement = {\n            draggableId: id,\n            shouldAnimate\n        };\n        groups.visible[id] = displacement;\n        return groups;\n    }, {\n        all: [],\n        visible: {},\n        invisible: {}\n    });\n}\nfunction getIndexOfLastItem(draggables, options) {\n    if (!draggables.length) {\n        return 0;\n    }\n    const indexOfLastItem = draggables[draggables.length - 1].descriptor.index;\n    return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;\n}\nfunction goAtEnd({ insideDestination, inHomeList, displacedBy, destination }) {\n    const newIndex = getIndexOfLastItem(insideDestination, {\n        inHomeList\n    });\n    return {\n        displaced: emptyGroups,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index: newIndex\n            }\n        }\n    };\n}\nfunction calculateReorderImpact({ draggable, insideDestination, destination, viewport, displacedBy, last, index, forceShouldAnimate }) {\n    const inHomeList = isHomeOf(draggable, destination);\n    if (index == null) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const match = insideDestination.find((item)=>item.descriptor.index === index);\n    if (!match) {\n        return goAtEnd({\n            insideDestination,\n            inHomeList,\n            displacedBy,\n            destination\n        });\n    }\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const sliceFrom = insideDestination.indexOf(match);\n    const impacted = withoutDragging.slice(sliceFrom);\n    const displaced = getDisplacementGroups({\n        afterDragging: impacted,\n        destination,\n        displacedBy,\n        last,\n        viewport: viewport.frame,\n        forceShouldAnimate\n    });\n    return {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: {\n                droppableId: destination.descriptor.id,\n                index\n            }\n        }\n    };\n}\nfunction didStartAfterCritical(draggableId, afterCritical) {\n    return Boolean(afterCritical.effected[draggableId]);\n}\nvar fromCombine = ({ isMovingForward, destination, draggables, combine, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const combineId = combine.draggableId;\n    const combineWith = draggables[combineId];\n    const combineWithIndex = combineWith.descriptor.index;\n    const didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);\n    if (didCombineWithStartAfterCritical) {\n        if (isMovingForward) {\n            return combineWithIndex;\n        }\n        return combineWithIndex - 1;\n    }\n    if (isMovingForward) {\n        return combineWithIndex + 1;\n    }\n    return combineWithIndex;\n};\nvar fromReorder = ({ isMovingForward, isInHomeList, insideDestination, location })=>{\n    if (!insideDestination.length) {\n        return null;\n    }\n    const currentIndex = location.index;\n    const proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;\n    const firstIndex = insideDestination[0].descriptor.index;\n    const lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;\n    const upperBound = isInHomeList ? lastIndex : lastIndex + 1;\n    if (proposedIndex < firstIndex) {\n        return null;\n    }\n    if (proposedIndex > upperBound) {\n        return null;\n    }\n    return proposedIndex;\n};\nvar moveToNextIndex = ({ isMovingForward, isInHomeList, draggable, draggables, destination, insideDestination, previousImpact, viewport, afterCritical })=>{\n    const wasAt = previousImpact.at;\n    !wasAt ?  true ? invariant(false, \"Cannot move in direction without previous impact location\") : 0 : void 0;\n    if (wasAt.type === \"REORDER\") {\n        const newIndex = fromReorder({\n            isMovingForward,\n            isInHomeList,\n            location: wasAt.destination,\n            insideDestination\n        });\n        if (newIndex == null) {\n            return null;\n        }\n        return calculateReorderImpact({\n            draggable,\n            insideDestination,\n            destination,\n            viewport,\n            last: previousImpact.displaced,\n            displacedBy: previousImpact.displacedBy,\n            index: newIndex\n        });\n    }\n    const newIndex = fromCombine({\n        isMovingForward,\n        destination,\n        displaced: previousImpact.displaced,\n        draggables,\n        combine: wasAt.combine,\n        afterCritical\n    });\n    if (newIndex == null) {\n        return null;\n    }\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last: previousImpact.displaced,\n        displacedBy: previousImpact.displacedBy,\n        index: newIndex\n    });\n};\nvar getCombinedItemDisplacement = ({ displaced, afterCritical, combineWith, displacedBy })=>{\n    const isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);\n    if (didStartAfterCritical(combineWith, afterCritical)) {\n        return isDisplaced ? origin : negate(displacedBy.point);\n    }\n    return isDisplaced ? displacedBy.point : origin;\n};\nvar whenCombining = ({ afterCritical, impact, draggables })=>{\n    const combine = tryGetCombine(impact);\n    !combine ?  true ? invariant() : 0 : void 0;\n    const combineWith = combine.draggableId;\n    const center = draggables[combineWith].page.borderBox.center;\n    const displaceBy = getCombinedItemDisplacement({\n        displaced: impact.displaced,\n        afterCritical,\n        combineWith,\n        displacedBy: impact.displacedBy\n    });\n    return add(center, displaceBy);\n};\nconst distanceFromStartToBorderBoxCenter = (axis, box)=>box.margin[axis.start] + box.borderBox[axis.size] / 2;\nconst distanceFromEndToBorderBoxCenter = (axis, box)=>box.margin[axis.end] + box.borderBox[axis.size] / 2;\nconst getCrossAxisBorderBoxCenter = (axis, target, isMoving)=>target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;\nconst goAfter = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goBefore = ({ axis, moveRelativeTo, isMoving })=>patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));\nconst goIntoStart = ({ axis, moveInto, isMoving })=>patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));\nvar whenReordering = ({ impact, draggable, draggables, droppable, afterCritical })=>{\n    const insideDestination = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const draggablePage = draggable.page;\n    const axis = droppable.axis;\n    if (!insideDestination.length) {\n        return goIntoStart({\n            axis,\n            moveInto: droppable.page,\n            isMoving: draggablePage\n        });\n    }\n    const { displaced, displacedBy } = impact;\n    const closestAfter = displaced.all[0];\n    if (closestAfter) {\n        const closest = draggables[closestAfter];\n        if (didStartAfterCritical(closestAfter, afterCritical)) {\n            return goBefore({\n                axis,\n                moveRelativeTo: closest.page,\n                isMoving: draggablePage\n            });\n        }\n        const withDisplacement = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(closest.page, displacedBy.point);\n        return goBefore({\n            axis,\n            moveRelativeTo: withDisplacement,\n            isMoving: draggablePage\n        });\n    }\n    const last = insideDestination[insideDestination.length - 1];\n    if (last.descriptor.id === draggable.descriptor.id) {\n        return draggablePage.borderBox.center;\n    }\n    if (didStartAfterCritical(last.descriptor.id, afterCritical)) {\n        const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(last.page, negate(afterCritical.displacedBy.point));\n        return goAfter({\n            axis,\n            moveRelativeTo: page,\n            isMoving: draggablePage\n        });\n    }\n    return goAfter({\n        axis,\n        moveRelativeTo: last.page,\n        isMoving: draggablePage\n    });\n};\nvar withDroppableDisplacement = (droppable, point)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return point;\n    }\n    return add(point, frame.scroll.diff.displacement);\n};\nconst getResultWithoutDroppableDisplacement = ({ impact, draggable, droppable, draggables, afterCritical })=>{\n    const original = draggable.page.borderBox.center;\n    const at = impact.at;\n    if (!droppable) {\n        return original;\n    }\n    if (!at) {\n        return original;\n    }\n    if (at.type === \"REORDER\") {\n        return whenReordering({\n            impact,\n            draggable,\n            draggables,\n            droppable,\n            afterCritical\n        });\n    }\n    return whenCombining({\n        impact,\n        draggables,\n        afterCritical\n    });\n};\nvar getPageBorderBoxCenterFromImpact = (args)=>{\n    const withoutDisplacement = getResultWithoutDroppableDisplacement(args);\n    const droppable = args.droppable;\n    const withDisplacement = droppable ? withDroppableDisplacement(droppable, withoutDisplacement) : withoutDisplacement;\n    return withDisplacement;\n};\nvar scrollViewport = (viewport, newScroll)=>{\n    const diff = subtract(newScroll, viewport.scroll.initial);\n    const displacement = negate(diff);\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top: newScroll.y,\n        bottom: newScroll.y + viewport.frame.height,\n        left: newScroll.x,\n        right: newScroll.x + viewport.frame.width\n    });\n    const updated = {\n        frame,\n        scroll: {\n            initial: viewport.scroll.initial,\n            max: viewport.scroll.max,\n            current: newScroll,\n            diff: {\n                value: diff,\n                displacement\n            }\n        }\n    };\n    return updated;\n};\nfunction getDraggables$1(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nfunction tryGetVisible(id, groups) {\n    for(let i = 0; i < groups.length; i++){\n        const displacement = groups[i].visible[id];\n        if (displacement) {\n            return displacement;\n        }\n    }\n    return null;\n}\nvar speculativelyIncrease = ({ impact, viewport, destination, draggables, maxScrollChange })=>{\n    const scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));\n    const scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;\n    const last = impact.displaced;\n    const withViewportScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: scrolledViewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const withDroppableScroll = getDisplacementGroups({\n        afterDragging: getDraggables$1(last.all, draggables),\n        destination: scrolledDroppable,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        last,\n        forceShouldAnimate: false\n    });\n    const invisible = {};\n    const visible = {};\n    const groups = [\n        last,\n        withViewportScroll,\n        withDroppableScroll\n    ];\n    last.all.forEach((id)=>{\n        const displacement = tryGetVisible(id, groups);\n        if (displacement) {\n            visible[id] = displacement;\n            return;\n        }\n        invisible[id] = true;\n    });\n    const newImpact = {\n        ...impact,\n        displaced: {\n            all: last.all,\n            invisible,\n            visible\n        }\n    };\n    return newImpact;\n};\nvar withViewportDisplacement = (viewport, point)=>add(viewport.scroll.diff.displacement, point);\nvar getClientFromPageBorderBoxCenter = ({ pageBorderBoxCenter, draggable, viewport })=>{\n    const withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);\n    const offset = subtract(withoutPageScrollChange, draggable.page.borderBox.center);\n    return add(draggable.client.borderBox.center, offset);\n};\nvar isTotallyVisibleInNewLocation = ({ draggable, destination, newPageBorderBoxCenter, viewport, withDroppableDisplacement, onlyOnMainAxis = false })=>{\n    const changeNeeded = subtract(newPageBorderBoxCenter, draggable.page.borderBox.center);\n    const shifted = offsetByPosition(draggable.page.borderBox, changeNeeded);\n    const args = {\n        target: shifted,\n        destination,\n        withDroppableDisplacement,\n        viewport\n    };\n    return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);\n};\nvar moveToNextPlace = ({ isMovingForward, draggable, destination, draggables, previousImpact, viewport, previousPageBorderBoxCenter, previousClientSelection, afterCritical })=>{\n    if (!destination.isEnabled) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const isInHomeList = isHomeOf(draggable, destination);\n    const impact = moveToNextCombine({\n        isMovingForward,\n        draggable,\n        destination,\n        insideDestination,\n        previousImpact\n    }) || moveToNextIndex({\n        isMovingForward,\n        isInHomeList,\n        draggable,\n        draggables,\n        destination,\n        insideDestination,\n        previousImpact,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n        draggable,\n        destination,\n        newPageBorderBoxCenter: pageBorderBoxCenter,\n        viewport: viewport.frame,\n        withDroppableDisplacement: false,\n        onlyOnMainAxis: true\n    });\n    if (isVisibleInNewLocation) {\n        const clientSelection = getClientFromPageBorderBoxCenter({\n            pageBorderBoxCenter,\n            draggable,\n            viewport\n        });\n        return {\n            clientSelection,\n            impact,\n            scrollJumpRequest: null\n        };\n    }\n    const distance = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);\n    const cautious = speculativelyIncrease({\n        impact,\n        viewport,\n        destination,\n        draggables,\n        maxScrollChange: distance\n    });\n    return {\n        clientSelection: previousClientSelection,\n        impact: cautious,\n        scrollJumpRequest: distance\n    };\n};\nconst getKnownActive = (droppable)=>{\n    const rect = droppable.subject.active;\n    !rect ?  true ? invariant(false, \"Cannot get clipped area from droppable\") : 0 : void 0;\n    return rect;\n};\nvar getBestCrossAxisDroppable = ({ isMovingForward, pageBorderBoxCenter, source, droppables, viewport })=>{\n    const active = source.subject.active;\n    if (!active) {\n        return null;\n    }\n    const axis = source.axis;\n    const isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);\n    const candidates = toDroppableList(droppables).filter((droppable)=>droppable !== source).filter((droppable)=>droppable.isEnabled).filter((droppable)=>Boolean(droppable.subject.active)).filter((droppable)=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable))).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        if (isMovingForward) {\n            return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];\n        }\n        return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];\n    }).filter((droppable)=>{\n        const activeOfTarget = getKnownActive(droppable);\n        const isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);\n        return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);\n    }).sort((a, b)=>{\n        const first = getKnownActive(a)[axis.crossAxisStart];\n        const second = getKnownActive(b)[axis.crossAxisStart];\n        if (isMovingForward) {\n            return first - second;\n        }\n        return second - first;\n    }).filter((droppable, index, array)=>getKnownActive(droppable)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart]);\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0];\n    }\n    const contains = candidates.filter((droppable)=>{\n        const isWithinDroppable = isWithin(getKnownActive(droppable)[axis.start], getKnownActive(droppable)[axis.end]);\n        return isWithinDroppable(pageBorderBoxCenter[axis.line]);\n    });\n    if (contains.length === 1) {\n        return contains[0];\n    }\n    if (contains.length > 1) {\n        return contains.sort((a, b)=>getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start])[0];\n    }\n    return candidates.sort((a, b)=>{\n        const first = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(a)));\n        const second = closest$1(pageBorderBoxCenter, getCorners(getKnownActive(b)));\n        if (first !== second) {\n            return first - second;\n        }\n        return getKnownActive(a)[axis.start] - getKnownActive(b)[axis.start];\n    })[0];\n};\nconst getCurrentPageBorderBoxCenter = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox.center;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;\n};\nconst getCurrentPageBorderBox = (draggable, afterCritical)=>{\n    const original = draggable.page.borderBox;\n    return didStartAfterCritical(draggable.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;\n};\nvar getClosestDraggable = ({ pageBorderBoxCenter, viewport, destination, insideDestination, afterCritical })=>{\n    const sorted = insideDestination.filter((draggable)=>isTotallyVisible({\n            target: getCurrentPageBorderBox(draggable, afterCritical),\n            destination,\n            viewport: viewport.frame,\n            withDroppableDisplacement: true\n        })).sort((a, b)=>{\n        const distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a, afterCritical)));\n        const distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b, afterCritical)));\n        if (distanceToA < distanceToB) {\n            return -1;\n        }\n        if (distanceToB < distanceToA) {\n            return 1;\n        }\n        return a.descriptor.index - b.descriptor.index;\n    });\n    return sorted[0] || null;\n};\nvar getDisplacedBy = memoizeOne(function getDisplacedBy(axis, displaceBy) {\n    const displacement = displaceBy[axis.line];\n    return {\n        value: displacement,\n        point: patch(axis.line, displacement)\n    };\n});\nconst getRequiredGrowthForPlaceholder = (droppable, placeholderSize, draggables)=>{\n    const axis = droppable.axis;\n    if (droppable.descriptor.mode === \"virtual\") {\n        return patch(axis.line, placeholderSize[axis.line]);\n    }\n    const availableSpace = droppable.subject.page.contentBox[axis.size];\n    const insideDroppable = getDraggablesInsideDroppable(droppable.descriptor.id, draggables);\n    const spaceUsed = insideDroppable.reduce((sum, dimension)=>sum + dimension.client.marginBox[axis.size], 0);\n    const requiredSpace = spaceUsed + placeholderSize[axis.line];\n    const needsToGrowBy = requiredSpace - availableSpace;\n    if (needsToGrowBy <= 0) {\n        return null;\n    }\n    return patch(axis.line, needsToGrowBy);\n};\nconst withMaxScroll = (frame, max)=>({\n        ...frame,\n        scroll: {\n            ...frame.scroll,\n            max\n        }\n    });\nconst addPlaceholder = (droppable, draggable, draggables)=>{\n    const frame = droppable.frame;\n    !!isHomeOf(draggable, droppable) ?  true ? invariant(false, \"Should not add placeholder space to home list\") : 0 : void 0;\n    !!droppable.subject.withPlaceholder ?  true ? invariant(false, \"Cannot add placeholder size to a subject when it already has one\") : 0 : void 0;\n    const placeholderSize = getDisplacedBy(droppable.axis, draggable.displaceBy).point;\n    const requiredGrowth = getRequiredGrowthForPlaceholder(droppable, placeholderSize, draggables);\n    const added = {\n        placeholderSize,\n        increasedBy: requiredGrowth,\n        oldFrameMaxScroll: droppable.frame ? droppable.frame.scroll.max : null\n    };\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            withPlaceholder: added,\n            axis: droppable.axis,\n            frame: droppable.frame\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;\n    const newFrame = withMaxScroll(frame, maxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        withPlaceholder: added,\n        axis: droppable.axis,\n        frame: newFrame\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nconst removePlaceholder = (droppable)=>{\n    const added = droppable.subject.withPlaceholder;\n    !added ?  true ? invariant(false, \"Cannot remove placeholder form subject when there was none\") : 0 : void 0;\n    const frame = droppable.frame;\n    if (!frame) {\n        const subject = getSubject({\n            page: droppable.subject.page,\n            axis: droppable.axis,\n            frame: null,\n            withPlaceholder: null\n        });\n        return {\n            ...droppable,\n            subject\n        };\n    }\n    const oldMaxScroll = added.oldFrameMaxScroll;\n    !oldMaxScroll ?  true ? invariant(false, \"Expected droppable with frame to have old max frame scroll when removing placeholder\") : 0 : void 0;\n    const newFrame = withMaxScroll(frame, oldMaxScroll);\n    const subject = getSubject({\n        page: droppable.subject.page,\n        axis: droppable.axis,\n        frame: newFrame,\n        withPlaceholder: null\n    });\n    return {\n        ...droppable,\n        subject,\n        frame: newFrame\n    };\n};\nvar moveToNewDroppable = ({ previousPageBorderBoxCenter, moveRelativeTo, insideDestination, draggable, draggables, destination, viewport, afterCritical })=>{\n    if (!moveRelativeTo) {\n        if (insideDestination.length) {\n            return null;\n        }\n        const proposed = {\n            displaced: emptyGroups,\n            displacedBy: noDisplacedBy,\n            at: {\n                type: \"REORDER\",\n                destination: {\n                    droppableId: destination.descriptor.id,\n                    index: 0\n                }\n            }\n        };\n        const proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n            impact: proposed,\n            draggable,\n            droppable: destination,\n            draggables,\n            afterCritical\n        });\n        const withPlaceholder = isHomeOf(draggable, destination) ? destination : addPlaceholder(destination, draggable, draggables);\n        const isVisibleInNewLocation = isTotallyVisibleInNewLocation({\n            draggable,\n            destination: withPlaceholder,\n            newPageBorderBoxCenter: proposedPageBorderBoxCenter,\n            viewport: viewport.frame,\n            withDroppableDisplacement: false,\n            onlyOnMainAxis: true\n        });\n        return isVisibleInNewLocation ? proposed : null;\n    }\n    const isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);\n    const proposedIndex = (()=>{\n        const relativeTo = moveRelativeTo.descriptor.index;\n        if (moveRelativeTo.descriptor.id === draggable.descriptor.id) {\n            return relativeTo;\n        }\n        if (isGoingBeforeTarget) {\n            return relativeTo;\n        }\n        return relativeTo + 1;\n    })();\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        displacedBy,\n        last: emptyGroups,\n        index: proposedIndex\n    });\n};\nvar moveCrossAxis = ({ isMovingForward, previousPageBorderBoxCenter, draggable, isOver, draggables, droppables, viewport, afterCritical })=>{\n    const destination = getBestCrossAxisDroppable({\n        isMovingForward,\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        source: isOver,\n        droppables,\n        viewport\n    });\n    if (!destination) {\n        return null;\n    }\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const moveRelativeTo = getClosestDraggable({\n        pageBorderBoxCenter: previousPageBorderBoxCenter,\n        viewport,\n        destination,\n        insideDestination,\n        afterCritical\n    });\n    const impact = moveToNewDroppable({\n        previousPageBorderBoxCenter,\n        destination,\n        draggable,\n        draggables,\n        moveRelativeTo,\n        insideDestination,\n        viewport,\n        afterCritical\n    });\n    if (!impact) {\n        return null;\n    }\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        afterCritical\n    });\n    const clientSelection = getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n    return {\n        clientSelection,\n        impact,\n        scrollJumpRequest: null\n    };\n};\nvar whatIsDraggedOver = (impact)=>{\n    const at = impact.at;\n    if (!at) {\n        return null;\n    }\n    if (at.type === \"REORDER\") {\n        return at.destination.droppableId;\n    }\n    return at.combine.droppableId;\n};\nconst getDroppableOver$1 = (impact, droppables)=>{\n    const id = whatIsDraggedOver(impact);\n    return id ? droppables[id] : null;\n};\nvar moveInDirection = ({ state, type })=>{\n    const isActuallyOver = getDroppableOver$1(state.impact, state.dimensions.droppables);\n    const isMainAxisMovementAllowed = Boolean(isActuallyOver);\n    const home = state.dimensions.droppables[state.critical.droppable.id];\n    const isOver = isActuallyOver || home;\n    const direction = isOver.axis.direction;\n    const isMovingOnMainAxis = direction === \"vertical\" && (type === \"MOVE_UP\" || type === \"MOVE_DOWN\") || direction === \"horizontal\" && (type === \"MOVE_LEFT\" || type === \"MOVE_RIGHT\");\n    if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {\n        return null;\n    }\n    const isMovingForward = type === \"MOVE_DOWN\" || type === \"MOVE_RIGHT\";\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const previousPageBorderBoxCenter = state.current.page.borderBoxCenter;\n    const { draggables, droppables } = state.dimensions;\n    return isMovingOnMainAxis ? moveToNextPlace({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        destination: isOver,\n        draggables,\n        viewport: state.viewport,\n        previousClientSelection: state.current.client.selection,\n        previousImpact: state.impact,\n        afterCritical: state.afterCritical\n    }) : moveCrossAxis({\n        isMovingForward,\n        previousPageBorderBoxCenter,\n        draggable,\n        isOver,\n        draggables,\n        droppables,\n        viewport: state.viewport,\n        afterCritical: state.afterCritical\n    });\n};\nfunction isMovementAllowed(state) {\n    return state.phase === \"DRAGGING\" || state.phase === \"COLLECTING\";\n}\nfunction isPositionInFrame(frame) {\n    const isWithinVertical = isWithin(frame.top, frame.bottom);\n    const isWithinHorizontal = isWithin(frame.left, frame.right);\n    return function run(point) {\n        return isWithinVertical(point.y) && isWithinHorizontal(point.x);\n    };\n}\nfunction getHasOverlap(first, second) {\n    return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;\n}\nfunction getFurthestAway({ pageBorderBox, draggable, candidates }) {\n    const startCenter = draggable.page.borderBox.center;\n    const sorted = candidates.map((candidate)=>{\n        const axis = candidate.axis;\n        const target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);\n        return {\n            id: candidate.descriptor.id,\n            distance: distance(startCenter, target)\n        };\n    }).sort((a, b)=>b.distance - a.distance);\n    return sorted[0] ? sorted[0].id : null;\n}\nfunction getDroppableOver({ pageBorderBox, draggable, droppables }) {\n    const candidates = toDroppableList(droppables).filter((item)=>{\n        if (!item.isEnabled) {\n            return false;\n        }\n        const active = item.subject.active;\n        if (!active) {\n            return false;\n        }\n        if (!getHasOverlap(pageBorderBox, active)) {\n            return false;\n        }\n        if (isPositionInFrame(active)(pageBorderBox.center)) {\n            return true;\n        }\n        const axis = item.axis;\n        const childCenter = active.center[axis.crossAxisLine];\n        const crossAxisStart = pageBorderBox[axis.crossAxisStart];\n        const crossAxisEnd = pageBorderBox[axis.crossAxisEnd];\n        const isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);\n        const isStartContained = isContained(crossAxisStart);\n        const isEndContained = isContained(crossAxisEnd);\n        if (!isStartContained && !isEndContained) {\n            return true;\n        }\n        if (isStartContained) {\n            return crossAxisStart < childCenter;\n        }\n        return crossAxisEnd > childCenter;\n    });\n    if (!candidates.length) {\n        return null;\n    }\n    if (candidates.length === 1) {\n        return candidates[0].descriptor.id;\n    }\n    return getFurthestAway({\n        pageBorderBox,\n        draggable,\n        candidates\n    });\n}\nconst offsetRectByPosition = (rect, point)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(offsetByPosition(rect, point));\nvar withDroppableScroll = (droppable, area)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return area;\n    }\n    return offsetRectByPosition(area, frame.scroll.diff.value);\n};\nfunction getIsDisplaced({ displaced, id }) {\n    return Boolean(displaced.visible[id] || displaced.invisible[id]);\n}\nfunction atIndex({ draggable, closest, inHomeList }) {\n    if (!closest) {\n        return null;\n    }\n    if (!inHomeList) {\n        return closest.descriptor.index;\n    }\n    if (closest.descriptor.index > draggable.descriptor.index) {\n        return closest.descriptor.index - 1;\n    }\n    return closest.descriptor.index;\n}\nvar getReorderImpact = ({ pageBorderBoxWithDroppableScroll: targetRect, draggable, destination, insideDestination, last, viewport, afterCritical })=>{\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const closest = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childCenter = child.page.borderBox.center[axis.line];\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: last,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd <= childCenter;\n            }\n            return targetStart < childCenter - displacement;\n        }\n        if (isDisplaced) {\n            return targetEnd <= childCenter + displacement;\n        }\n        return targetStart < childCenter;\n    }) || null;\n    const newIndex = atIndex({\n        draggable,\n        closest,\n        inHomeList: isHomeOf(draggable, destination)\n    });\n    return calculateReorderImpact({\n        draggable,\n        insideDestination,\n        destination,\n        viewport,\n        last,\n        displacedBy,\n        index: newIndex\n    });\n};\nconst combineThresholdDivisor = 4;\nvar getCombineImpact = ({ draggable, pageBorderBoxWithDroppableScroll: targetRect, previousImpact, destination, insideDestination, afterCritical })=>{\n    if (!destination.isCombineEnabled) {\n        return null;\n    }\n    const axis = destination.axis;\n    const displacedBy = getDisplacedBy(destination.axis, draggable.displaceBy);\n    const displacement = displacedBy.value;\n    const targetStart = targetRect[axis.start];\n    const targetEnd = targetRect[axis.end];\n    const withoutDragging = removeDraggableFromList(draggable, insideDestination);\n    const combineWith = withoutDragging.find((child)=>{\n        const id = child.descriptor.id;\n        const childRect = child.page.borderBox;\n        const childSize = childRect[axis.size];\n        const threshold = childSize / combineThresholdDivisor;\n        const didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);\n        const isDisplaced = getIsDisplaced({\n            displaced: previousImpact.displaced,\n            id\n        });\n        if (didStartAfterCritical$1) {\n            if (isDisplaced) {\n                return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;\n            }\n            return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;\n        }\n        if (isDisplaced) {\n            return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;\n        }\n        return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;\n    });\n    if (!combineWith) {\n        return null;\n    }\n    const impact = {\n        displacedBy,\n        displaced: previousImpact.displaced,\n        at: {\n            type: \"COMBINE\",\n            combine: {\n                draggableId: combineWith.descriptor.id,\n                droppableId: destination.descriptor.id\n            }\n        }\n    };\n    return impact;\n};\nvar getDragImpact = ({ pageOffset, draggable, draggables, droppables, previousImpact, viewport, afterCritical })=>{\n    const pageBorderBox = offsetRectByPosition(draggable.page.borderBox, pageOffset);\n    const destinationId = getDroppableOver({\n        pageBorderBox,\n        draggable,\n        droppables\n    });\n    if (!destinationId) {\n        return noImpact;\n    }\n    const destination = droppables[destinationId];\n    const insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);\n    const pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);\n    return getCombineImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        previousImpact,\n        destination,\n        insideDestination,\n        afterCritical\n    }) || getReorderImpact({\n        pageBorderBoxWithDroppableScroll,\n        draggable,\n        destination,\n        insideDestination,\n        last: previousImpact.displaced,\n        viewport,\n        afterCritical\n    });\n};\nvar patchDroppableMap = (droppables, updated)=>({\n        ...droppables,\n        [updated.descriptor.id]: updated\n    });\nconst clearUnusedPlaceholder = ({ previousImpact, impact, droppables })=>{\n    const last = whatIsDraggedOver(previousImpact);\n    const now = whatIsDraggedOver(impact);\n    if (!last) {\n        return droppables;\n    }\n    if (last === now) {\n        return droppables;\n    }\n    const lastDroppable = droppables[last];\n    if (!lastDroppable.subject.withPlaceholder) {\n        return droppables;\n    }\n    const updated = removePlaceholder(lastDroppable);\n    return patchDroppableMap(droppables, updated);\n};\nvar recomputePlaceholders = ({ draggable, draggables, droppables, previousImpact, impact })=>{\n    const cleaned = clearUnusedPlaceholder({\n        previousImpact,\n        impact,\n        droppables\n    });\n    const isOver = whatIsDraggedOver(impact);\n    if (!isOver) {\n        return cleaned;\n    }\n    const droppable = droppables[isOver];\n    if (isHomeOf(draggable, droppable)) {\n        return cleaned;\n    }\n    if (droppable.subject.withPlaceholder) {\n        return cleaned;\n    }\n    const patched = addPlaceholder(droppable, draggable, draggables);\n    return patchDroppableMap(cleaned, patched);\n};\nvar update = ({ state, clientSelection: forcedClientSelection, dimensions: forcedDimensions, viewport: forcedViewport, impact: forcedImpact, scrollJumpRequest })=>{\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const clientSelection = forcedClientSelection || state.current.client.selection;\n    const offset = subtract(clientSelection, state.initial.client.selection);\n    const client = {\n        offset,\n        selection: clientSelection,\n        borderBoxCenter: add(state.initial.client.borderBoxCenter, offset)\n    };\n    const page = {\n        selection: add(client.selection, viewport.scroll.current),\n        borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),\n        offset: add(client.offset, viewport.scroll.diff.value)\n    };\n    const current = {\n        client,\n        page\n    };\n    if (state.phase === \"COLLECTING\") {\n        return {\n            ...state,\n            dimensions,\n            viewport,\n            current\n        };\n    }\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const newImpact = forcedImpact || getDragImpact({\n        pageOffset: page.offset,\n        draggable,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact: state.impact,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    const withUpdatedPlaceholders = recomputePlaceholders({\n        draggable,\n        impact: newImpact,\n        previousImpact: state.impact,\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables\n    });\n    const result = {\n        ...state,\n        current,\n        dimensions: {\n            draggables: dimensions.draggables,\n            droppables: withUpdatedPlaceholders\n        },\n        impact: newImpact,\n        viewport,\n        scrollJumpRequest: scrollJumpRequest || null,\n        forceShouldAnimate: scrollJumpRequest ? false : null\n    };\n    return result;\n};\nfunction getDraggables(ids, draggables) {\n    return ids.map((id)=>draggables[id]);\n}\nvar recompute = ({ impact, viewport, draggables, destination, forceShouldAnimate })=>{\n    const last = impact.displaced;\n    const afterDragging = getDraggables(last.all, draggables);\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination,\n        displacedBy: impact.displacedBy,\n        viewport: viewport.frame,\n        forceShouldAnimate,\n        last\n    });\n    return {\n        ...impact,\n        displaced\n    };\n};\nvar getClientBorderBoxCenter = ({ impact, draggable, droppable, draggables, viewport, afterCritical })=>{\n    const pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({\n        impact,\n        draggable,\n        draggables,\n        droppable,\n        afterCritical\n    });\n    return getClientFromPageBorderBoxCenter({\n        pageBorderBoxCenter,\n        draggable,\n        viewport\n    });\n};\nvar refreshSnap = ({ state, dimensions: forcedDimensions, viewport: forcedViewport })=>{\n    !(state.movementMode === \"SNAP\") ?  true ? invariant() : 0 : void 0;\n    const needsVisibilityCheck = state.impact;\n    const viewport = forcedViewport || state.viewport;\n    const dimensions = forcedDimensions || state.dimensions;\n    const { draggables, droppables } = dimensions;\n    const draggable = draggables[state.critical.draggable.id];\n    const isOver = whatIsDraggedOver(needsVisibilityCheck);\n    !isOver ?  true ? invariant(false, \"Must be over a destination in SNAP movement mode\") : 0 : void 0;\n    const destination = droppables[isOver];\n    const impact = recompute({\n        impact: needsVisibilityCheck,\n        viewport,\n        destination,\n        draggables\n    });\n    const clientSelection = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        droppable: destination,\n        draggables,\n        viewport,\n        afterCritical: state.afterCritical\n    });\n    return update({\n        impact,\n        clientSelection,\n        state,\n        dimensions,\n        viewport\n    });\n};\nvar getHomeLocation = (descriptor)=>({\n        index: descriptor.index,\n        droppableId: descriptor.droppableId\n    });\nvar getLiftEffect = ({ draggable, home, draggables, viewport })=>{\n    const displacedBy = getDisplacedBy(home.axis, draggable.displaceBy);\n    const insideHome = getDraggablesInsideDroppable(home.descriptor.id, draggables);\n    const rawIndex = insideHome.indexOf(draggable);\n    !(rawIndex !== -1) ?  true ? invariant(false, \"Expected draggable to be inside home list\") : 0 : void 0;\n    const afterDragging = insideHome.slice(rawIndex + 1);\n    const effected = afterDragging.reduce((previous, item)=>{\n        previous[item.descriptor.id] = true;\n        return previous;\n    }, {});\n    const afterCritical = {\n        inVirtualList: home.descriptor.mode === \"virtual\",\n        displacedBy,\n        effected\n    };\n    const displaced = getDisplacementGroups({\n        afterDragging,\n        destination: home,\n        displacedBy,\n        last: null,\n        viewport: viewport.frame,\n        forceShouldAnimate: false\n    });\n    const impact = {\n        displaced,\n        displacedBy,\n        at: {\n            type: \"REORDER\",\n            destination: getHomeLocation(draggable.descriptor)\n        }\n    };\n    return {\n        impact,\n        afterCritical\n    };\n};\nvar patchDimensionMap = (dimensions, updated)=>({\n        draggables: dimensions.draggables,\n        droppables: patchDroppableMap(dimensions.droppables, updated)\n    });\nconst start = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nconst finish = (key)=>{\n    if (true) {\n        {\n            return;\n        }\n    }\n};\nvar offsetDraggable = ({ draggable, offset: offset$1, initialWindowScroll })=>{\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.offset)(draggable.client, offset$1);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, initialWindowScroll);\n    const moved = {\n        ...draggable,\n        placeholder: {\n            ...draggable.placeholder,\n            client\n        },\n        client,\n        page\n    };\n    return moved;\n};\nvar getFrame = (droppable)=>{\n    const frame = droppable.frame;\n    !frame ?  true ? invariant(false, \"Expected Droppable to have a frame\") : 0 : void 0;\n    return frame;\n};\nvar adjustAdditionsForScrollChanges = ({ additions, updatedDroppables, viewport })=>{\n    const windowScrollChange = viewport.scroll.diff.value;\n    return additions.map((draggable)=>{\n        const droppableId = draggable.descriptor.droppableId;\n        const modified = updatedDroppables[droppableId];\n        const frame = getFrame(modified);\n        const droppableScrollChange = frame.scroll.diff.value;\n        const totalChange = add(windowScrollChange, droppableScrollChange);\n        const moved = offsetDraggable({\n            draggable,\n            offset: totalChange,\n            initialWindowScroll: viewport.scroll.initial\n        });\n        return moved;\n    });\n};\nvar publishWhileDraggingInVirtual = ({ state, published })=>{\n    start();\n    const withScrollChange = published.modified.map((update)=>{\n        const existing = state.dimensions.droppables[update.droppableId];\n        const scrolled = scrollDroppable(existing, update.scroll);\n        return scrolled;\n    });\n    const droppables = {\n        ...state.dimensions.droppables,\n        ...toDroppableMap(withScrollChange)\n    };\n    const updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({\n        additions: published.additions,\n        updatedDroppables: droppables,\n        viewport: state.viewport\n    }));\n    const draggables = {\n        ...state.dimensions.draggables,\n        ...updatedAdditions\n    };\n    published.removals.forEach((id)=>{\n        delete draggables[id];\n    });\n    const dimensions = {\n        droppables,\n        draggables\n    };\n    const wasOverId = whatIsDraggedOver(state.impact);\n    const wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;\n    const draggable = dimensions.draggables[state.critical.draggable.id];\n    const home = dimensions.droppables[state.critical.droppable.id];\n    const { impact: onLiftImpact, afterCritical } = getLiftEffect({\n        draggable,\n        home,\n        draggables,\n        viewport: state.viewport\n    });\n    const previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;\n    const impact = getDragImpact({\n        pageOffset: state.current.page.offset,\n        draggable: dimensions.draggables[state.critical.draggable.id],\n        draggables: dimensions.draggables,\n        droppables: dimensions.droppables,\n        previousImpact,\n        viewport: state.viewport,\n        afterCritical\n    });\n    finish();\n    const draggingState = {\n        ...state,\n        phase: \"DRAGGING\",\n        impact,\n        onLiftImpact,\n        dimensions,\n        afterCritical,\n        forceShouldAnimate: false\n    };\n    if (state.phase === \"COLLECTING\") {\n        return draggingState;\n    }\n    const dropPending = {\n        ...draggingState,\n        phase: \"DROP_PENDING\",\n        reason: state.reason,\n        isWaiting: false\n    };\n    return dropPending;\n};\nconst isSnapping = (state)=>state.movementMode === \"SNAP\";\nconst postDroppableChange = (state, updated, isEnabledChanging)=>{\n    const dimensions = patchDimensionMap(state.dimensions, updated);\n    if (!isSnapping(state) || isEnabledChanging) {\n        return update({\n            state,\n            dimensions\n        });\n    }\n    return refreshSnap({\n        state,\n        dimensions\n    });\n};\nfunction removeScrollJumpRequest(state) {\n    if (state.isDragging && state.movementMode === \"SNAP\") {\n        return {\n            ...state,\n            scrollJumpRequest: null\n        };\n    }\n    return state;\n}\nconst idle$2 = {\n    phase: \"IDLE\",\n    completed: null,\n    shouldFlush: false\n};\nvar reducer = (state = idle$2, action)=>{\n    if (action.type === \"FLUSH\") {\n        return {\n            ...idle$2,\n            shouldFlush: true\n        };\n    }\n    if (action.type === \"INITIAL_PUBLISH\") {\n        !(state.phase === \"IDLE\") ?  true ? invariant(false, \"INITIAL_PUBLISH must come after a IDLE phase\") : 0 : void 0;\n        const { critical, clientSelection, viewport, dimensions, movementMode } = action.payload;\n        const draggable = dimensions.draggables[critical.draggable.id];\n        const home = dimensions.droppables[critical.droppable.id];\n        const client = {\n            selection: clientSelection,\n            borderBoxCenter: draggable.client.borderBox.center,\n            offset: origin\n        };\n        const initial = {\n            client,\n            page: {\n                selection: add(client.selection, viewport.scroll.initial),\n                borderBoxCenter: add(client.selection, viewport.scroll.initial),\n                offset: add(client.selection, viewport.scroll.diff.value)\n            }\n        };\n        const isWindowScrollAllowed = toDroppableList(dimensions.droppables).every((item)=>!item.isFixedOnPage);\n        const { impact, afterCritical } = getLiftEffect({\n            draggable,\n            home,\n            draggables: dimensions.draggables,\n            viewport\n        });\n        const result = {\n            phase: \"DRAGGING\",\n            isDragging: true,\n            critical,\n            movementMode,\n            dimensions,\n            initial,\n            current: initial,\n            isWindowScrollAllowed,\n            impact,\n            afterCritical,\n            onLiftImpact: impact,\n            viewport,\n            scrollJumpRequest: null,\n            forceShouldAnimate: null\n        };\n        return result;\n    }\n    if (action.type === \"COLLECTION_STARTING\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `Collection cannot start from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            ...state,\n            phase: \"COLLECTING\"\n        };\n        return result;\n    }\n    if (action.type === \"PUBLISH_WHILE_DRAGGING\") {\n        !(state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Unexpected ${action.type} received in phase ${state.phase}`) : 0 : void 0;\n        return publishWhileDraggingInVirtual({\n            state,\n            published: action.payload\n        });\n    }\n    if (action.type === \"MOVE\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { client: clientSelection } = action.payload;\n        if (isEqual$1(clientSelection, state.current.client.selection)) {\n            return state;\n        }\n        return update({\n            state,\n            clientSelection,\n            impact: isSnapping(state) ? state.impact : null\n        });\n    }\n    if (action.type === \"UPDATE_DROPPABLE_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return removeScrollJumpRequest(state);\n        }\n        if (state.phase === \"COLLECTING\") {\n            return removeScrollJumpRequest(state);\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `${action.type} not permitted in phase ${state.phase}`) : 0 : void 0;\n        const { id, newScroll } = action.payload;\n        const target = state.dimensions.droppables[id];\n        if (!target) {\n            return state;\n        }\n        const scrolled = scrollDroppable(target, newScroll);\n        return postDroppableChange(state, scrolled, false);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its enabled state`) : 0 : void 0;\n        !(target.isEnabled !== isEnabled) ?  true ? invariant(false, `Trying to set droppable isEnabled to ${String(isEnabled)}\n      but it is already ${String(target.isEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\") {\n        if (state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Attempting to move in an unsupported phase ${state.phase}`) : 0 : void 0;\n        const { id, isCombineEnabled } = action.payload;\n        const target = state.dimensions.droppables[id];\n        !target ?  true ? invariant(false, `Cannot find Droppable[id: ${id}] to toggle its isCombineEnabled state`) : 0 : void 0;\n        !(target.isCombineEnabled !== isCombineEnabled) ?  true ? invariant(false, `Trying to set droppable isCombineEnabled to ${String(isCombineEnabled)}\n      but it is already ${String(target.isCombineEnabled)}`) : 0 : void 0;\n        const updated = {\n            ...target,\n            isCombineEnabled\n        };\n        return postDroppableChange(state, updated, true);\n    }\n    if (action.type === \"MOVE_BY_WINDOW_SCROLL\") {\n        if (state.phase === \"DROP_PENDING\" || state.phase === \"DROP_ANIMATING\") {\n            return state;\n        }\n        !isMovementAllowed(state) ?  true ? invariant(false, `Cannot move by window in phase ${state.phase}`) : 0 : void 0;\n        !state.isWindowScrollAllowed ?  true ? invariant(false, \"Window scrolling is currently not supported for fixed lists\") : 0 : void 0;\n        const newScroll = action.payload.newScroll;\n        if (isEqual$1(state.viewport.scroll.current, newScroll)) {\n            return removeScrollJumpRequest(state);\n        }\n        const viewport = scrollViewport(state.viewport, newScroll);\n        if (isSnapping(state)) {\n            return refreshSnap({\n                state,\n                viewport\n            });\n        }\n        return update({\n            state,\n            viewport\n        });\n    }\n    if (action.type === \"UPDATE_VIEWPORT_MAX_SCROLL\") {\n        if (!isMovementAllowed(state)) {\n            return state;\n        }\n        const maxScroll = action.payload.maxScroll;\n        if (isEqual$1(maxScroll, state.viewport.scroll.max)) {\n            return state;\n        }\n        const withMaxScroll = {\n            ...state.viewport,\n            scroll: {\n                ...state.viewport.scroll,\n                max: maxScroll\n            }\n        };\n        return {\n            ...state,\n            viewport: withMaxScroll\n        };\n    }\n    if (action.type === \"MOVE_UP\" || action.type === \"MOVE_DOWN\" || action.type === \"MOVE_LEFT\" || action.type === \"MOVE_RIGHT\") {\n        if (state.phase === \"COLLECTING\" || state.phase === \"DROP_PENDING\") {\n            return state;\n        }\n        !(state.phase === \"DRAGGING\") ?  true ? invariant(false, `${action.type} received while not in DRAGGING phase`) : 0 : void 0;\n        const result = moveInDirection({\n            state,\n            type: action.type\n        });\n        if (!result) {\n            return state;\n        }\n        return update({\n            state,\n            impact: result.impact,\n            clientSelection: result.clientSelection,\n            scrollJumpRequest: result.scrollJumpRequest\n        });\n    }\n    if (action.type === \"DROP_PENDING\") {\n        const reason = action.payload.reason;\n        !(state.phase === \"COLLECTING\") ?  true ? invariant(false, \"Can only move into the DROP_PENDING phase from the COLLECTING phase\") : 0 : void 0;\n        const newState = {\n            ...state,\n            phase: \"DROP_PENDING\",\n            isWaiting: true,\n            reason\n        };\n        return newState;\n    }\n    if (action.type === \"DROP_ANIMATE\") {\n        const { completed, dropDuration, newHomeClientOffset } = action.payload;\n        !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot animate drop from phase ${state.phase}`) : 0 : void 0;\n        const result = {\n            phase: \"DROP_ANIMATING\",\n            completed,\n            dropDuration,\n            newHomeClientOffset,\n            dimensions: state.dimensions\n        };\n        return result;\n    }\n    if (action.type === \"DROP_COMPLETE\") {\n        const { completed } = action.payload;\n        return {\n            phase: \"IDLE\",\n            completed,\n            shouldFlush: false\n        };\n    }\n    return state;\n};\nfunction guard(action, predicate) {\n    return action instanceof Object && \"type\" in action && action.type === predicate;\n}\nconst beforeInitialCapture = (args)=>({\n        type: \"BEFORE_INITIAL_CAPTURE\",\n        payload: args\n    });\nconst lift$1 = (args)=>({\n        type: \"LIFT\",\n        payload: args\n    });\nconst initialPublish = (args)=>({\n        type: \"INITIAL_PUBLISH\",\n        payload: args\n    });\nconst publishWhileDragging = (args)=>({\n        type: \"PUBLISH_WHILE_DRAGGING\",\n        payload: args\n    });\nconst collectionStarting = ()=>({\n        type: \"COLLECTION_STARTING\",\n        payload: null\n    });\nconst updateDroppableScroll = (args)=>({\n        type: \"UPDATE_DROPPABLE_SCROLL\",\n        payload: args\n    });\nconst updateDroppableIsEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_ENABLED\",\n        payload: args\n    });\nconst updateDroppableIsCombineEnabled = (args)=>({\n        type: \"UPDATE_DROPPABLE_IS_COMBINE_ENABLED\",\n        payload: args\n    });\nconst move = (args)=>({\n        type: \"MOVE\",\n        payload: args\n    });\nconst moveByWindowScroll = (args)=>({\n        type: \"MOVE_BY_WINDOW_SCROLL\",\n        payload: args\n    });\nconst updateViewportMaxScroll = (args)=>({\n        type: \"UPDATE_VIEWPORT_MAX_SCROLL\",\n        payload: args\n    });\nconst moveUp = ()=>({\n        type: \"MOVE_UP\",\n        payload: null\n    });\nconst moveDown = ()=>({\n        type: \"MOVE_DOWN\",\n        payload: null\n    });\nconst moveRight = ()=>({\n        type: \"MOVE_RIGHT\",\n        payload: null\n    });\nconst moveLeft = ()=>({\n        type: \"MOVE_LEFT\",\n        payload: null\n    });\nconst flush = ()=>({\n        type: \"FLUSH\",\n        payload: null\n    });\nconst animateDrop = (args)=>({\n        type: \"DROP_ANIMATE\",\n        payload: args\n    });\nconst completeDrop = (args)=>({\n        type: \"DROP_COMPLETE\",\n        payload: args\n    });\nconst drop = (args)=>({\n        type: \"DROP\",\n        payload: args\n    });\nconst dropPending = (args)=>({\n        type: \"DROP_PENDING\",\n        payload: args\n    });\nconst dropAnimationFinished = ()=>({\n        type: \"DROP_ANIMATION_FINISHED\",\n        payload: null\n    });\nfunction checkIndexes(insideDestination) {\n    if (insideDestination.length <= 1) {\n        return;\n    }\n    const indexes = insideDestination.map((d)=>d.descriptor.index);\n    const errors = {};\n    for(let i = 1; i < indexes.length; i++){\n        const current = indexes[i];\n        const previous = indexes[i - 1];\n        if (current !== previous + 1) {\n            errors[current] = true;\n        }\n    }\n    if (!Object.keys(errors).length) {\n        return;\n    }\n    const formatted = indexes.map((index)=>{\n        const hasError = Boolean(errors[index]);\n        return hasError ? `[ðŸ”¥${index}]` : `${index}`;\n    }).join(\", \");\n     true ? warning(`\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    ${formatted}\n  `) : 0;\n}\nfunction validateDimensions(critical, dimensions) {\n    if (true) {\n        const insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);\n        checkIndexes(insideDestination);\n    }\n}\nvar lift = (marshal)=>({ getState, dispatch })=>(next)=>(action)=>{\n                if (!guard(action, \"LIFT\")) {\n                    next(action);\n                    return;\n                }\n                const { id, clientSelection, movementMode } = action.payload;\n                const initial = getState();\n                if (initial.phase === \"DROP_ANIMATING\") {\n                    dispatch(completeDrop({\n                        completed: initial.completed\n                    }));\n                }\n                !(getState().phase === \"IDLE\") ?  true ? invariant(false, \"Unexpected phase to start a drag\") : 0 : void 0;\n                dispatch(flush());\n                dispatch(beforeInitialCapture({\n                    draggableId: id,\n                    movementMode\n                }));\n                const scrollOptions = {\n                    shouldPublishImmediately: movementMode === \"SNAP\"\n                };\n                const request = {\n                    draggableId: id,\n                    scrollOptions\n                };\n                const { critical, dimensions, viewport } = marshal.startPublishing(request);\n                validateDimensions(critical, dimensions);\n                dispatch(initialPublish({\n                    critical,\n                    dimensions,\n                    clientSelection,\n                    movementMode,\n                    viewport\n                }));\n            };\nvar style = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    marshal.dragging();\n                }\n                if (guard(action, \"DROP_ANIMATE\")) {\n                    marshal.dropping(action.payload.completed.result.reason);\n                }\n                if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\")) {\n                    marshal.resting();\n                }\n                next(action);\n            };\nconst curves = {\n    outOfTheWay: \"cubic-bezier(0.2, 0, 0, 1)\",\n    drop: \"cubic-bezier(.2,1,.1,1)\"\n};\nconst combine = {\n    opacity: {\n        drop: 0,\n        combining: 0.7\n    },\n    scale: {\n        drop: 0.75\n    }\n};\nconst timings = {\n    outOfTheWay: 0.2,\n    minDropTime: 0.33,\n    maxDropTime: 0.55\n};\nconst outOfTheWayTiming = `${timings.outOfTheWay}s ${curves.outOfTheWay}`;\nconst transitions = {\n    fluid: `opacity ${outOfTheWayTiming}`,\n    snap: `transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,\n    drop: (duration)=>{\n        const timing = `${duration}s ${curves.drop}`;\n        return `transform ${timing}, opacity ${timing}`;\n    },\n    outOfTheWay: `transform ${outOfTheWayTiming}`,\n    placeholder: `height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`\n};\nconst moveTo = (offset)=>isEqual$1(offset, origin) ? undefined : `translate(${offset.x}px, ${offset.y}px)`;\nconst transforms = {\n    moveTo,\n    drop: (offset, isCombining)=>{\n        const translate = moveTo(offset);\n        if (!translate) {\n            return undefined;\n        }\n        if (!isCombining) {\n            return translate;\n        }\n        return `${translate} scale(${combine.scale.drop})`;\n    }\n};\nconst { minDropTime, maxDropTime } = timings;\nconst dropTimeRange = maxDropTime - minDropTime;\nconst maxDropTimeAtDistance = 1500;\nconst cancelDropModifier = 0.6;\nvar getDropDuration = ({ current, destination, reason })=>{\n    const distance$1 = distance(current, destination);\n    if (distance$1 <= 0) {\n        return minDropTime;\n    }\n    if (distance$1 >= maxDropTimeAtDistance) {\n        return maxDropTime;\n    }\n    const percentage = distance$1 / maxDropTimeAtDistance;\n    const duration = minDropTime + dropTimeRange * percentage;\n    const withDuration = reason === \"CANCEL\" ? duration * cancelDropModifier : duration;\n    return Number(withDuration.toFixed(2));\n};\nvar getNewHomeClientOffset = ({ impact, draggable, dimensions, viewport, afterCritical })=>{\n    const { draggables, droppables } = dimensions;\n    const droppableId = whatIsDraggedOver(impact);\n    const destination = droppableId ? droppables[droppableId] : null;\n    const home = droppables[draggable.descriptor.droppableId];\n    const newClientCenter = getClientBorderBoxCenter({\n        impact,\n        draggable,\n        draggables,\n        afterCritical,\n        droppable: destination || home,\n        viewport\n    });\n    const offset = subtract(newClientCenter, draggable.client.borderBox.center);\n    return offset;\n};\nvar getDropImpact = ({ draggables, reason, lastImpact, home, viewport, onLiftImpact })=>{\n    if (!lastImpact.at || reason !== \"DROP\") {\n        const recomputedHomeImpact = recompute({\n            draggables,\n            impact: onLiftImpact,\n            destination: home,\n            viewport,\n            forceShouldAnimate: true\n        });\n        return {\n            impact: recomputedHomeImpact,\n            didDropInsideDroppable: false\n        };\n    }\n    if (lastImpact.at.type === \"REORDER\") {\n        return {\n            impact: lastImpact,\n            didDropInsideDroppable: true\n        };\n    }\n    const withoutMovement = {\n        ...lastImpact,\n        displaced: emptyGroups\n    };\n    return {\n        impact: withoutMovement,\n        didDropInsideDroppable: true\n    };\n};\nconst dropMiddleware = ({ getState, dispatch })=>(next)=>(action)=>{\n            if (!guard(action, \"DROP\")) {\n                next(action);\n                return;\n            }\n            const state = getState();\n            const reason = action.payload.reason;\n            if (state.phase === \"COLLECTING\") {\n                dispatch(dropPending({\n                    reason\n                }));\n                return;\n            }\n            if (state.phase === \"IDLE\") {\n                return;\n            }\n            const isWaitingForDrop = state.phase === \"DROP_PENDING\" && state.isWaiting;\n            !!isWaitingForDrop ?  true ? invariant(false, \"A DROP action occurred while DROP_PENDING and still waiting\") : 0 : void 0;\n            !(state.phase === \"DRAGGING\" || state.phase === \"DROP_PENDING\") ?  true ? invariant(false, `Cannot drop in phase: ${state.phase}`) : 0 : void 0;\n            const critical = state.critical;\n            const dimensions = state.dimensions;\n            const draggable = dimensions.draggables[state.critical.draggable.id];\n            const { impact, didDropInsideDroppable } = getDropImpact({\n                reason,\n                lastImpact: state.impact,\n                afterCritical: state.afterCritical,\n                onLiftImpact: state.onLiftImpact,\n                home: state.dimensions.droppables[state.critical.droppable.id],\n                viewport: state.viewport,\n                draggables: state.dimensions.draggables\n            });\n            const destination = didDropInsideDroppable ? tryGetDestination(impact) : null;\n            const combine = didDropInsideDroppable ? tryGetCombine(impact) : null;\n            const source = {\n                index: critical.draggable.index,\n                droppableId: critical.droppable.id\n            };\n            const result = {\n                draggableId: draggable.descriptor.id,\n                type: draggable.descriptor.type,\n                source,\n                reason,\n                mode: state.movementMode,\n                destination,\n                combine\n            };\n            const newHomeClientOffset = getNewHomeClientOffset({\n                impact,\n                draggable,\n                dimensions,\n                viewport: state.viewport,\n                afterCritical: state.afterCritical\n            });\n            const completed = {\n                critical: state.critical,\n                afterCritical: state.afterCritical,\n                result,\n                impact\n            };\n            const isAnimationRequired = !isEqual$1(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);\n            if (!isAnimationRequired) {\n                dispatch(completeDrop({\n                    completed\n                }));\n                return;\n            }\n            const dropDuration = getDropDuration({\n                current: state.current.client.offset,\n                destination: newHomeClientOffset,\n                reason\n            });\n            const args = {\n                newHomeClientOffset,\n                dropDuration,\n                completed\n            };\n            dispatch(animateDrop(args));\n        };\nvar getWindowScroll = ()=>({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n    });\nfunction getWindowScrollBinding(update) {\n    return {\n        eventName: \"scroll\",\n        options: {\n            passive: true,\n            capture: false\n        },\n        fn: (event)=>{\n            if (event.target !== window && event.target !== window.document) {\n                return;\n            }\n            update();\n        }\n    };\n}\nfunction getScrollListener({ onWindowScroll }) {\n    function updateScroll() {\n        onWindowScroll(getWindowScroll());\n    }\n    const scheduled = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll);\n    const binding = getWindowScrollBinding(scheduled);\n    let unbind = noop$2;\n    function isActive() {\n        return unbind !== noop$2;\n    }\n    function start() {\n        !!isActive() ?  true ? invariant(false, \"Cannot start scroll listener when already active\") : 0 : void 0;\n        unbind = bindEvents(window, [\n            binding\n        ]);\n    }\n    function stop() {\n        !isActive() ?  true ? invariant(false, \"Cannot stop scroll listener when not active\") : 0 : void 0;\n        scheduled.cancel();\n        unbind();\n        unbind = noop$2;\n    }\n    return {\n        start,\n        stop,\n        isActive\n    };\n}\nconst shouldStop$1 = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nconst scrollListener = (store)=>{\n    const listener = getScrollListener({\n        onWindowScroll: (newScroll)=>{\n            store.dispatch(moveByWindowScroll({\n                newScroll\n            }));\n        }\n    });\n    return (next)=>(action)=>{\n            if (!listener.isActive() && guard(action, \"INITIAL_PUBLISH\")) {\n                listener.start();\n            }\n            if (listener.isActive() && shouldStop$1(action)) {\n                listener.stop();\n            }\n            next(action);\n        };\n};\nvar getExpiringAnnounce = (announce)=>{\n    let wasCalled = false;\n    let isExpired = false;\n    const timeoutId = setTimeout(()=>{\n        isExpired = true;\n    });\n    const result = (message)=>{\n        if (wasCalled) {\n             true ? warning(\"Announcement already made. Not making a second announcement\") : 0;\n            return;\n        }\n        if (isExpired) {\n             true ? warning(`\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      `) : 0;\n            return;\n        }\n        wasCalled = true;\n        announce(message);\n        clearTimeout(timeoutId);\n    };\n    result.wasCalled = ()=>wasCalled;\n    return result;\n};\nvar getAsyncMarshal = ()=>{\n    const entries = [];\n    const execute = (timerId)=>{\n        const index = entries.findIndex((item)=>item.timerId === timerId);\n        !(index !== -1) ?  true ? invariant(false, \"Could not find timer\") : 0 : void 0;\n        const [entry] = entries.splice(index, 1);\n        entry.callback();\n    };\n    const add = (fn)=>{\n        const timerId = setTimeout(()=>execute(timerId));\n        const entry = {\n            timerId,\n            callback: fn\n        };\n        entries.push(entry);\n    };\n    const flush = ()=>{\n        if (!entries.length) {\n            return;\n        }\n        const shallow = [\n            ...entries\n        ];\n        entries.length = 0;\n        shallow.forEach((entry)=>{\n            clearTimeout(entry.timerId);\n            entry.callback();\n        });\n    };\n    return {\n        add,\n        flush\n    };\n};\nconst areLocationsEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.droppableId === second.droppableId && first.index === second.index;\n};\nconst isCombineEqual = (first, second)=>{\n    if (first == null && second == null) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    return first.draggableId === second.draggableId && first.droppableId === second.droppableId;\n};\nconst isCriticalEqual = (first, second)=>{\n    if (first === second) {\n        return true;\n    }\n    const isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;\n    const isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;\n    return isDraggableEqual && isDroppableEqual;\n};\nconst withTimings = (key, fn)=>{\n    start();\n    fn();\n    finish();\n};\nconst getDragStart = (critical, mode)=>({\n        draggableId: critical.draggable.id,\n        type: critical.droppable.type,\n        source: {\n            droppableId: critical.droppable.id,\n            index: critical.draggable.index\n        },\n        mode\n    });\nfunction execute(responder, data, announce, getDefaultMessage) {\n    if (!responder) {\n        announce(getDefaultMessage(data));\n        return;\n    }\n    const willExpire = getExpiringAnnounce(announce);\n    const provided = {\n        announce: willExpire\n    };\n    responder(data, provided);\n    if (!willExpire.wasCalled()) {\n        announce(getDefaultMessage(data));\n    }\n}\nvar getPublisher = (getResponders, announce)=>{\n    const asyncMarshal = getAsyncMarshal();\n    let dragging = null;\n    const beforeCapture = (draggableId, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeCapture as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeCapture\", ()=>{\n            const fn = getResponders().onBeforeCapture;\n            if (fn) {\n                const before = {\n                    draggableId,\n                    mode\n                };\n                fn(before);\n            }\n        });\n    };\n    const beforeStart = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        withTimings(\"onBeforeDragStart\", ()=>{\n            const fn = getResponders().onBeforeDragStart;\n            if (fn) {\n                fn(getDragStart(critical, mode));\n            }\n        });\n    };\n    const start = (critical, mode)=>{\n        !!dragging ?  true ? invariant(false, \"Cannot fire onBeforeDragStart as a drag start has already been published\") : 0 : void 0;\n        const data = getDragStart(critical, mode);\n        dragging = {\n            mode,\n            lastCritical: critical,\n            lastLocation: data.source,\n            lastCombine: null\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragStart\", ()=>execute(getResponders().onDragStart, data, announce, preset.onDragStart));\n        });\n    };\n    const update = (critical, impact)=>{\n        const location = tryGetDestination(impact);\n        const combine = tryGetCombine(impact);\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragMove when onDragStart has not been called\") : 0 : void 0;\n        const hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);\n        if (hasCriticalChanged) {\n            dragging.lastCritical = critical;\n        }\n        const hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);\n        if (hasLocationChanged) {\n            dragging.lastLocation = location;\n        }\n        const hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine);\n        if (hasGroupingChanged) {\n            dragging.lastCombine = combine;\n        }\n        if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {\n            return;\n        }\n        const data = {\n            ...getDragStart(critical, dragging.mode),\n            combine,\n            destination: location\n        };\n        asyncMarshal.add(()=>{\n            withTimings(\"onDragUpdate\", ()=>execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate));\n        });\n    };\n    const flush = ()=>{\n        !dragging ?  true ? invariant(false, \"Can only flush responders while dragging\") : 0 : void 0;\n        asyncMarshal.flush();\n    };\n    const drop = (result)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fire onDragEnd when there is no matching onDragStart\") : 0 : void 0;\n        dragging = null;\n        withTimings(\"onDragEnd\", ()=>execute(getResponders().onDragEnd, result, announce, preset.onDragEnd));\n    };\n    const abort = ()=>{\n        if (!dragging) {\n            return;\n        }\n        const result = {\n            ...getDragStart(dragging.lastCritical, dragging.mode),\n            combine: null,\n            destination: null,\n            reason: \"CANCEL\"\n        };\n        drop(result);\n    };\n    return {\n        beforeCapture,\n        beforeStart,\n        start,\n        update,\n        flush,\n        drop,\n        abort\n    };\n};\nvar responders = (getResponders, announce)=>{\n    const publisher = getPublisher(getResponders, announce);\n    return (store)=>(next)=>(action)=>{\n                if (guard(action, \"BEFORE_INITIAL_CAPTURE\")) {\n                    publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    const critical = action.payload.critical;\n                    publisher.beforeStart(critical, action.payload.movementMode);\n                    next(action);\n                    publisher.start(critical, action.payload.movementMode);\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    const result = action.payload.completed.result;\n                    publisher.flush();\n                    next(action);\n                    publisher.drop(result);\n                    return;\n                }\n                next(action);\n                if (guard(action, \"FLUSH\")) {\n                    publisher.abort();\n                    return;\n                }\n                const state = store.getState();\n                if (state.phase === \"DRAGGING\") {\n                    publisher.update(state.critical, state.impact);\n                }\n            };\n};\nconst dropAnimationFinishMiddleware = (store)=>(next)=>(action)=>{\n            if (!guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                next(action);\n                return;\n            }\n            const state = store.getState();\n            !(state.phase === \"DROP_ANIMATING\") ?  true ? invariant(false, \"Cannot finish a drop animating when no drop is occurring\") : 0 : void 0;\n            store.dispatch(completeDrop({\n                completed: state.completed\n            }));\n        };\nconst dropAnimationFlushOnScrollMiddleware = (store)=>{\n    let unbind = null;\n    let frameId = null;\n    function clear() {\n        if (frameId) {\n            cancelAnimationFrame(frameId);\n            frameId = null;\n        }\n        if (unbind) {\n            unbind();\n            unbind = null;\n        }\n    }\n    return (next)=>(action)=>{\n            if (guard(action, \"FLUSH\") || guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATION_FINISHED\")) {\n                clear();\n            }\n            next(action);\n            if (!guard(action, \"DROP_ANIMATE\")) {\n                return;\n            }\n            const binding = {\n                eventName: \"scroll\",\n                options: {\n                    capture: true,\n                    passive: false,\n                    once: true\n                },\n                fn: function flushDropAnimation() {\n                    const state = store.getState();\n                    if (state.phase === \"DROP_ANIMATING\") {\n                        store.dispatch(dropAnimationFinished());\n                    }\n                }\n            };\n            frameId = requestAnimationFrame(()=>{\n                frameId = null;\n                unbind = bindEvents(window, [\n                    binding\n                ]);\n            });\n        };\n};\nvar dimensionMarshalStopper = (marshal)=>()=>(next)=>(action)=>{\n                if (guard(action, \"DROP_COMPLETE\") || guard(action, \"FLUSH\") || guard(action, \"DROP_ANIMATE\")) {\n                    marshal.stopPublishing();\n                }\n                next(action);\n            };\nvar focus = (marshal)=>{\n    let isWatching = false;\n    return ()=>(next)=>(action)=>{\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    isWatching = true;\n                    marshal.tryRecordFocus(action.payload.critical.draggable.id);\n                    next(action);\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                next(action);\n                if (!isWatching) {\n                    return;\n                }\n                if (guard(action, \"FLUSH\")) {\n                    isWatching = false;\n                    marshal.tryRestoreFocusRecorded();\n                    return;\n                }\n                if (guard(action, \"DROP_COMPLETE\")) {\n                    isWatching = false;\n                    const result = action.payload.completed.result;\n                    if (result.combine) {\n                        marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);\n                    }\n                    marshal.tryRestoreFocusRecorded();\n                }\n            };\n};\nconst shouldStop = (action)=>guard(action, \"DROP_COMPLETE\") || guard(action, \"DROP_ANIMATE\") || guard(action, \"FLUSH\");\nvar autoScroll = (autoScroller)=>(store)=>(next)=>(action)=>{\n                if (shouldStop(action)) {\n                    autoScroller.stop();\n                    next(action);\n                    return;\n                }\n                if (guard(action, \"INITIAL_PUBLISH\")) {\n                    next(action);\n                    const state = store.getState();\n                    !(state.phase === \"DRAGGING\") ?  true ? invariant(false, \"Expected phase to be DRAGGING after INITIAL_PUBLISH\") : 0 : void 0;\n                    autoScroller.start(state);\n                    return;\n                }\n                next(action);\n                autoScroller.scroll(store.getState());\n            };\nconst pendingDrop = (store)=>(next)=>(action)=>{\n            next(action);\n            if (!guard(action, \"PUBLISH_WHILE_DRAGGING\")) {\n                return;\n            }\n            const postActionState = store.getState();\n            if (postActionState.phase !== \"DROP_PENDING\") {\n                return;\n            }\n            if (postActionState.isWaiting) {\n                return;\n            }\n            store.dispatch(drop({\n                reason: postActionState.reason\n            }));\n        };\nconst composeEnhancers =  false ? 0 : redux__WEBPACK_IMPORTED_MODULE_5__.compose;\nvar createStore = ({ dimensionMarshal, focusMarshal, styleMarshal, getResponders, announce, autoScroller })=>(0,redux__WEBPACK_IMPORTED_MODULE_5__.createStore)(reducer, composeEnhancers((0,redux__WEBPACK_IMPORTED_MODULE_5__.applyMiddleware)(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift(dimensionMarshal), dropMiddleware, dropAnimationFinishMiddleware, dropAnimationFlushOnScrollMiddleware, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));\nconst clean$1 = ()=>({\n        additions: {},\n        removals: {},\n        modified: {}\n    });\nfunction createPublisher({ registry, callbacks }) {\n    let staging = clean$1();\n    let frameId = null;\n    const collect = ()=>{\n        if (frameId) {\n            return;\n        }\n        callbacks.collectionStarting();\n        frameId = requestAnimationFrame(()=>{\n            frameId = null;\n            start();\n            const { additions, removals, modified } = staging;\n            const added = Object.keys(additions).map((id)=>registry.draggable.getById(id).getDimension(origin)).sort((a, b)=>a.descriptor.index - b.descriptor.index);\n            const updated = Object.keys(modified).map((id)=>{\n                const entry = registry.droppable.getById(id);\n                const scroll = entry.callbacks.getScrollWhileDragging();\n                return {\n                    droppableId: id,\n                    scroll\n                };\n            });\n            const result = {\n                additions: added,\n                removals: Object.keys(removals),\n                modified: updated\n            };\n            staging = clean$1();\n            finish();\n            callbacks.publish(result);\n        });\n    };\n    const add = (entry)=>{\n        const id = entry.descriptor.id;\n        staging.additions[id] = entry;\n        staging.modified[entry.descriptor.droppableId] = true;\n        if (staging.removals[id]) {\n            delete staging.removals[id];\n        }\n        collect();\n    };\n    const remove = (entry)=>{\n        const descriptor = entry.descriptor;\n        staging.removals[descriptor.id] = true;\n        staging.modified[descriptor.droppableId] = true;\n        if (staging.additions[descriptor.id]) {\n            delete staging.additions[descriptor.id];\n        }\n        collect();\n    };\n    const stop = ()=>{\n        if (!frameId) {\n            return;\n        }\n        cancelAnimationFrame(frameId);\n        frameId = null;\n        staging = clean$1();\n    };\n    return {\n        add,\n        remove,\n        stop\n    };\n}\nvar getMaxScroll = ({ scrollHeight, scrollWidth, height, width })=>{\n    const maxScroll = subtract({\n        x: scrollWidth,\n        y: scrollHeight\n    }, {\n        x: width,\n        y: height\n    });\n    const adjustedMaxScroll = {\n        x: Math.max(0, maxScroll.x),\n        y: Math.max(0, maxScroll.y)\n    };\n    return adjustedMaxScroll;\n};\nvar getDocumentElement = ()=>{\n    const doc = document.documentElement;\n    !doc ?  true ? invariant(false, \"Cannot find document.documentElement\") : 0 : void 0;\n    return doc;\n};\nvar getMaxWindowScroll = ()=>{\n    const doc = getDocumentElement();\n    const maxScroll = getMaxScroll({\n        scrollHeight: doc.scrollHeight,\n        scrollWidth: doc.scrollWidth,\n        width: doc.clientWidth,\n        height: doc.clientHeight\n    });\n    return maxScroll;\n};\nvar getViewport = ()=>{\n    const scroll = getWindowScroll();\n    const maxScroll = getMaxWindowScroll();\n    const top = scroll.y;\n    const left = scroll.x;\n    const doc = getDocumentElement();\n    const width = doc.clientWidth;\n    const height = doc.clientHeight;\n    const right = left + width;\n    const bottom = top + height;\n    const frame = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)({\n        top,\n        left,\n        right,\n        bottom\n    });\n    const viewport = {\n        frame,\n        scroll: {\n            initial: scroll,\n            current: scroll,\n            max: maxScroll,\n            diff: {\n                value: origin,\n                displacement: origin\n            }\n        }\n    };\n    return viewport;\n};\nvar getInitialPublish = ({ critical, scrollOptions, registry })=>{\n    start();\n    const viewport = getViewport();\n    const windowScroll = viewport.scroll.current;\n    const home = critical.droppable;\n    const droppables = registry.droppable.getAllByType(home.type).map((entry)=>entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions));\n    const draggables = registry.draggable.getAllByType(critical.draggable.type).map((entry)=>entry.getDimension(windowScroll));\n    const dimensions = {\n        draggables: toDraggableMap(draggables),\n        droppables: toDroppableMap(droppables)\n    };\n    finish();\n    const result = {\n        dimensions,\n        critical,\n        viewport\n    };\n    return result;\n};\nfunction shouldPublishUpdate(registry, dragging, entry) {\n    if (entry.descriptor.id === dragging.id) {\n        return false;\n    }\n    if (entry.descriptor.type !== dragging.type) {\n        return false;\n    }\n    const home = registry.droppable.getById(entry.descriptor.droppableId);\n    if (home.descriptor.mode !== \"virtual\") {\n         true ? warning(`\n      You are attempting to add or remove a Draggable [id: ${entry.descriptor.id}]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/hello-pangea/dnd/blob/main/docs/patterns/virtual-lists.md\n    `) : 0;\n        return false;\n    }\n    return true;\n}\nvar createDimensionMarshal = (registry, callbacks)=>{\n    let collection = null;\n    const publisher = createPublisher({\n        callbacks: {\n            publish: callbacks.publishWhileDragging,\n            collectionStarting: callbacks.collectionStarting\n        },\n        registry\n    });\n    const updateDroppableIsEnabled = (id, isEnabled)=>{\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update is enabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        if (!collection) {\n            return;\n        }\n        callbacks.updateDroppableIsEnabled({\n            id,\n            isEnabled\n        });\n    };\n    const updateDroppableIsCombineEnabled = (id, isCombineEnabled)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update isCombineEnabled flag of Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableIsCombineEnabled({\n            id,\n            isCombineEnabled\n        });\n    };\n    const updateDroppableScroll = (id, newScroll)=>{\n        if (!collection) {\n            return;\n        }\n        !registry.droppable.exists(id) ?  true ? invariant(false, `Cannot update the scroll on Droppable ${id} as it is not registered`) : 0 : void 0;\n        callbacks.updateDroppableScroll({\n            id,\n            newScroll\n        });\n    };\n    const scrollDroppable = (id, change)=>{\n        if (!collection) {\n            return;\n        }\n        registry.droppable.getById(id).callbacks.scroll(change);\n    };\n    const stopPublishing = ()=>{\n        if (!collection) {\n            return;\n        }\n        publisher.stop();\n        const home = collection.critical.droppable;\n        registry.droppable.getAllByType(home.type).forEach((entry)=>entry.callbacks.dragStopped());\n        collection.unsubscribe();\n        collection = null;\n    };\n    const subscriber = (event)=>{\n        !collection ?  true ? invariant(false, \"Should only be subscribed when a collection is occurring\") : 0 : void 0;\n        const dragging = collection.critical.draggable;\n        if (event.type === \"ADDITION\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.add(event.value);\n            }\n        }\n        if (event.type === \"REMOVAL\") {\n            if (shouldPublishUpdate(registry, dragging, event.value)) {\n                publisher.remove(event.value);\n            }\n        }\n    };\n    const startPublishing = (request)=>{\n        !!collection ?  true ? invariant(false, \"Cannot start capturing critical dimensions as there is already a collection\") : 0 : void 0;\n        const entry = registry.draggable.getById(request.draggableId);\n        const home = registry.droppable.getById(entry.descriptor.droppableId);\n        const critical = {\n            draggable: entry.descriptor,\n            droppable: home.descriptor\n        };\n        const unsubscribe = registry.subscribe(subscriber);\n        collection = {\n            critical,\n            unsubscribe\n        };\n        return getInitialPublish({\n            critical,\n            registry,\n            scrollOptions: request.scrollOptions\n        });\n    };\n    const marshal = {\n        updateDroppableIsEnabled,\n        updateDroppableIsCombineEnabled,\n        scrollDroppable,\n        updateDroppableScroll,\n        startPublishing,\n        stopPublishing\n    };\n    return marshal;\n};\nvar canStartDrag = (state, id)=>{\n    if (state.phase === \"IDLE\") {\n        return true;\n    }\n    if (state.phase !== \"DROP_ANIMATING\") {\n        return false;\n    }\n    if (state.completed.result.draggableId === id) {\n        return false;\n    }\n    return state.completed.result.reason === \"DROP\";\n};\nvar scrollWindow = (change)=>{\n    window.scrollBy(change.x, change.y);\n};\nconst getScrollableDroppables = memoizeOne((droppables)=>toDroppableList(droppables).filter((droppable)=>{\n        if (!droppable.isEnabled) {\n            return false;\n        }\n        if (!droppable.frame) {\n            return false;\n        }\n        return true;\n    }));\nconst getScrollableDroppableOver = (target, droppables)=>{\n    const maybe = getScrollableDroppables(droppables).find((droppable)=>{\n        !droppable.frame ?  true ? invariant(false, \"Invalid result\") : 0 : void 0;\n        return isPositionInFrame(droppable.frame.pageMarginBox)(target);\n    }) || null;\n    return maybe;\n};\nvar getBestScrollableDroppable = ({ center, destination, droppables })=>{\n    if (destination) {\n        const dimension = droppables[destination];\n        if (!dimension.frame) {\n            return null;\n        }\n        return dimension;\n    }\n    const dimension = getScrollableDroppableOver(center, droppables);\n    return dimension;\n};\nconst defaultAutoScrollerOptions = {\n    startFromPercentage: 0.25,\n    maxScrollAtPercentage: 0.05,\n    maxPixelScroll: 28,\n    ease: (percentage)=>percentage ** 2,\n    durationDampening: {\n        stopDampeningAt: 1200,\n        accelerateAt: 360\n    },\n    disabled: false\n};\nvar getDistanceThresholds = (container, axis, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const startScrollingFrom = container[axis.size] * autoScrollerOptions.startFromPercentage;\n    const maxScrollValueAt = container[axis.size] * autoScrollerOptions.maxScrollAtPercentage;\n    const thresholds = {\n        startScrollingFrom,\n        maxScrollValueAt\n    };\n    return thresholds;\n};\nvar getPercentage = ({ startOfRange, endOfRange, current })=>{\n    const range = endOfRange - startOfRange;\n    if (range === 0) {\n         true ? warning(`\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    `) : 0;\n        return 0;\n    }\n    const currentInRange = current - startOfRange;\n    const percentage = currentInRange / range;\n    return percentage;\n};\nvar minScroll = 1;\nvar getValueFromDistance = (distanceToEdge, thresholds, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    if (distanceToEdge > thresholds.startScrollingFrom) {\n        return 0;\n    }\n    if (distanceToEdge <= thresholds.maxScrollValueAt) {\n        return autoScrollerOptions.maxPixelScroll;\n    }\n    if (distanceToEdge === thresholds.startScrollingFrom) {\n        return minScroll;\n    }\n    const percentageFromMaxScrollValueAt = getPercentage({\n        startOfRange: thresholds.maxScrollValueAt,\n        endOfRange: thresholds.startScrollingFrom,\n        current: distanceToEdge\n    });\n    const percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;\n    const scroll = autoScrollerOptions.maxPixelScroll * autoScrollerOptions.ease(percentageFromStartScrollingFrom);\n    return Math.ceil(scroll);\n};\nvar dampenValueByTime = (proposedScroll, dragStartTime, getAutoScrollerOptions)=>{\n    const autoScrollerOptions = getAutoScrollerOptions();\n    const accelerateAt = autoScrollerOptions.durationDampening.accelerateAt;\n    const stopAt = autoScrollerOptions.durationDampening.stopDampeningAt;\n    const startOfRange = dragStartTime;\n    const endOfRange = stopAt;\n    const now = Date.now();\n    const runTime = now - startOfRange;\n    if (runTime >= stopAt) {\n        return proposedScroll;\n    }\n    if (runTime < accelerateAt) {\n        return minScroll;\n    }\n    const betweenAccelerateAtAndStopAtPercentage = getPercentage({\n        startOfRange: accelerateAt,\n        endOfRange,\n        current: runTime\n    });\n    const scroll = proposedScroll * autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);\n    return Math.ceil(scroll);\n};\nvar getValue = ({ distanceToEdge, thresholds, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getValueFromDistance(distanceToEdge, thresholds, getAutoScrollerOptions);\n    if (scroll === 0) {\n        return 0;\n    }\n    if (!shouldUseTimeDampening) {\n        return scroll;\n    }\n    return Math.max(dampenValueByTime(scroll, dragStartTime, getAutoScrollerOptions), minScroll);\n};\nvar getScrollOnAxis = ({ container, distanceToEdges, dragStartTime, axis, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const thresholds = getDistanceThresholds(container, axis, getAutoScrollerOptions);\n    const isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];\n    if (isCloserToEnd) {\n        return getValue({\n            distanceToEdge: distanceToEdges[axis.end],\n            thresholds,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    }\n    return -1 * getValue({\n        distanceToEdge: distanceToEdges[axis.start],\n        thresholds,\n        dragStartTime,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n};\nvar adjustForSizeLimits = ({ container, subject, proposedScroll })=>{\n    const isTooBigVertically = subject.height > container.height;\n    const isTooBigHorizontally = subject.width > container.width;\n    if (!isTooBigHorizontally && !isTooBigVertically) {\n        return proposedScroll;\n    }\n    if (isTooBigHorizontally && isTooBigVertically) {\n        return null;\n    }\n    return {\n        x: isTooBigHorizontally ? 0 : proposedScroll.x,\n        y: isTooBigVertically ? 0 : proposedScroll.y\n    };\n};\nconst clean = apply((value)=>value === 0 ? 0 : value);\nvar getScroll$1 = ({ dragStartTime, container, subject, center, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const distanceToEdges = {\n        top: center.y - container.top,\n        right: container.right - center.x,\n        bottom: container.bottom - center.y,\n        left: center.x - container.left\n    };\n    const y = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: vertical,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const x = getScrollOnAxis({\n        container,\n        distanceToEdges,\n        dragStartTime,\n        axis: horizontal,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    const required = clean({\n        x,\n        y\n    });\n    if (isEqual$1(required, origin)) {\n        return null;\n    }\n    const limited = adjustForSizeLimits({\n        container,\n        subject,\n        proposedScroll: required\n    });\n    if (!limited) {\n        return null;\n    }\n    return isEqual$1(limited, origin) ? null : limited;\n};\nconst smallestSigned = apply((value)=>{\n    if (value === 0) {\n        return 0;\n    }\n    return value > 0 ? 1 : -1;\n});\nconst getOverlap = (()=>{\n    const getRemainder = (target, max)=>{\n        if (target < 0) {\n            return target;\n        }\n        if (target > max) {\n            return target - max;\n        }\n        return 0;\n    };\n    return ({ current, max, change })=>{\n        const targetScroll = add(current, change);\n        const overlap = {\n            x: getRemainder(targetScroll.x, max.x),\n            y: getRemainder(targetScroll.y, max.y)\n        };\n        if (isEqual$1(overlap, origin)) {\n            return null;\n        }\n        return overlap;\n    };\n})();\nconst canPartiallyScroll = ({ max: rawMax, current, change })=>{\n    const max = {\n        x: Math.max(current.x, rawMax.x),\n        y: Math.max(current.y, rawMax.y)\n    };\n    const smallestChange = smallestSigned(change);\n    const overlap = getOverlap({\n        max,\n        current,\n        change: smallestChange\n    });\n    if (!overlap) {\n        return true;\n    }\n    if (smallestChange.x !== 0 && overlap.x === 0) {\n        return true;\n    }\n    if (smallestChange.y !== 0 && overlap.y === 0) {\n        return true;\n    }\n    return false;\n};\nconst canScrollWindow = (viewport, change)=>canPartiallyScroll({\n        current: viewport.scroll.current,\n        max: viewport.scroll.max,\n        change\n    });\nconst getWindowOverlap = (viewport, change)=>{\n    if (!canScrollWindow(viewport, change)) {\n        return null;\n    }\n    const max = viewport.scroll.max;\n    const current = viewport.scroll.current;\n    return getOverlap({\n        current,\n        max,\n        change\n    });\n};\nconst canScrollDroppable = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return false;\n    }\n    return canPartiallyScroll({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nconst getDroppableOverlap = (droppable, change)=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    if (!canScrollDroppable(droppable, change)) {\n        return null;\n    }\n    return getOverlap({\n        current: frame.scroll.current,\n        max: frame.scroll.max,\n        change\n    });\n};\nvar getWindowScrollChange = ({ viewport, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: viewport.frame,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollWindow(viewport, scroll) ? scroll : null;\n};\nvar getDroppableScrollChange = ({ droppable, subject, center, dragStartTime, shouldUseTimeDampening, getAutoScrollerOptions })=>{\n    const frame = droppable.frame;\n    if (!frame) {\n        return null;\n    }\n    const scroll = getScroll$1({\n        dragStartTime,\n        container: frame.pageMarginBox,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    return scroll && canScrollDroppable(droppable, scroll) ? scroll : null;\n};\nvar scroll = ({ state, dragStartTime, shouldUseTimeDampening, scrollWindow, scrollDroppable, getAutoScrollerOptions })=>{\n    const center = state.current.page.borderBoxCenter;\n    const draggable = state.dimensions.draggables[state.critical.draggable.id];\n    const subject = draggable.page.marginBox;\n    if (state.isWindowScrollAllowed) {\n        const viewport = state.viewport;\n        const change = getWindowScrollChange({\n            dragStartTime,\n            viewport,\n            subject,\n            center,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n        if (change) {\n            scrollWindow(change);\n            return;\n        }\n    }\n    const droppable = getBestScrollableDroppable({\n        center,\n        destination: whatIsDraggedOver(state.impact),\n        droppables: state.dimensions.droppables\n    });\n    if (!droppable) {\n        return;\n    }\n    const change = getDroppableScrollChange({\n        dragStartTime,\n        droppable,\n        subject,\n        center,\n        shouldUseTimeDampening,\n        getAutoScrollerOptions\n    });\n    if (change) {\n        scrollDroppable(droppable.descriptor.id, change);\n    }\n};\nvar createFluidScroller = ({ scrollWindow, scrollDroppable, getAutoScrollerOptions = ()=>defaultAutoScrollerOptions })=>{\n    const scheduleWindowScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollWindow);\n    const scheduleDroppableScroll = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(scrollDroppable);\n    let dragging = null;\n    const tryScroll = (state)=>{\n        !dragging ?  true ? invariant(false, \"Cannot fluid scroll if not dragging\") : 0 : void 0;\n        const { shouldUseTimeDampening, dragStartTime } = dragging;\n        scroll({\n            state,\n            scrollWindow: scheduleWindowScroll,\n            scrollDroppable: scheduleDroppableScroll,\n            dragStartTime,\n            shouldUseTimeDampening,\n            getAutoScrollerOptions\n        });\n    };\n    const start$1 = (state)=>{\n        start();\n        !!dragging ?  true ? invariant(false, \"Cannot start auto scrolling when already started\") : 0 : void 0;\n        const dragStartTime = Date.now();\n        let wasScrollNeeded = false;\n        const fakeScrollCallback = ()=>{\n            wasScrollNeeded = true;\n        };\n        scroll({\n            state,\n            dragStartTime: 0,\n            shouldUseTimeDampening: false,\n            scrollWindow: fakeScrollCallback,\n            scrollDroppable: fakeScrollCallback,\n            getAutoScrollerOptions\n        });\n        dragging = {\n            dragStartTime,\n            shouldUseTimeDampening: wasScrollNeeded\n        };\n        finish();\n        if (wasScrollNeeded) {\n            tryScroll(state);\n        }\n    };\n    const stop = ()=>{\n        if (!dragging) {\n            return;\n        }\n        scheduleWindowScroll.cancel();\n        scheduleDroppableScroll.cancel();\n        dragging = null;\n    };\n    return {\n        start: start$1,\n        stop,\n        scroll: tryScroll\n    };\n};\nvar createJumpScroller = ({ move, scrollDroppable, scrollWindow })=>{\n    const moveByOffset = (state, offset)=>{\n        const client = add(state.current.client.selection, offset);\n        move({\n            client\n        });\n    };\n    const scrollDroppableAsMuchAsItCan = (droppable, change)=>{\n        if (!canScrollDroppable(droppable, change)) {\n            return change;\n        }\n        const overlap = getDroppableOverlap(droppable, change);\n        if (!overlap) {\n            scrollDroppable(droppable.descriptor.id, change);\n            return null;\n        }\n        const whatTheDroppableCanScroll = subtract(change, overlap);\n        scrollDroppable(droppable.descriptor.id, whatTheDroppableCanScroll);\n        const remainder = subtract(change, whatTheDroppableCanScroll);\n        return remainder;\n    };\n    const scrollWindowAsMuchAsItCan = (isWindowScrollAllowed, viewport, change)=>{\n        if (!isWindowScrollAllowed) {\n            return change;\n        }\n        if (!canScrollWindow(viewport, change)) {\n            return change;\n        }\n        const overlap = getWindowOverlap(viewport, change);\n        if (!overlap) {\n            scrollWindow(change);\n            return null;\n        }\n        const whatTheWindowCanScroll = subtract(change, overlap);\n        scrollWindow(whatTheWindowCanScroll);\n        const remainder = subtract(change, whatTheWindowCanScroll);\n        return remainder;\n    };\n    const jumpScroller = (state)=>{\n        const request = state.scrollJumpRequest;\n        if (!request) {\n            return;\n        }\n        const destination = whatIsDraggedOver(state.impact);\n        !destination ?  true ? invariant(false, \"Cannot perform a jump scroll when there is no destination\") : 0 : void 0;\n        const droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);\n        if (!droppableRemainder) {\n            return;\n        }\n        const viewport = state.viewport;\n        const windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);\n        if (!windowRemainder) {\n            return;\n        }\n        moveByOffset(state, windowRemainder);\n    };\n    return jumpScroller;\n};\nvar createAutoScroller = ({ scrollDroppable, scrollWindow, move, getAutoScrollerOptions })=>{\n    const fluidScroller = createFluidScroller({\n        scrollWindow,\n        scrollDroppable,\n        getAutoScrollerOptions\n    });\n    const jumpScroll = createJumpScroller({\n        move,\n        scrollWindow,\n        scrollDroppable\n    });\n    const scroll = (state)=>{\n        const autoScrollerOptions = getAutoScrollerOptions();\n        if (autoScrollerOptions.disabled || state.phase !== \"DRAGGING\") {\n            return;\n        }\n        if (state.movementMode === \"FLUID\") {\n            fluidScroller.scroll(state);\n            return;\n        }\n        if (!state.scrollJumpRequest) {\n            return;\n        }\n        jumpScroll(state);\n    };\n    const scroller = {\n        scroll,\n        start: fluidScroller.start,\n        stop: fluidScroller.stop\n    };\n    return scroller;\n};\nconst prefix = \"data-rfd\";\nconst dragHandle = (()=>{\n    const base = `${prefix}-drag-handle`;\n    return {\n        base,\n        draggableId: `${base}-draggable-id`,\n        contextId: `${base}-context-id`\n    };\n})();\nconst draggable = (()=>{\n    const base = `${prefix}-draggable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst droppable = (()=>{\n    const base = `${prefix}-droppable`;\n    return {\n        base,\n        contextId: `${base}-context-id`,\n        id: `${base}-id`\n    };\n})();\nconst scrollContainer = {\n    contextId: `${prefix}-scroll-container-context-id`\n};\nconst makeGetSelector = (context)=>(attribute)=>`[${attribute}=\"${context}\"]`;\nconst getStyles = (rules, property)=>rules.map((rule)=>{\n        const value = rule.styles[property];\n        if (!value) {\n            return \"\";\n        }\n        return `${rule.selector} { ${value} }`;\n    }).join(\" \");\nconst noPointerEvents = \"pointer-events: none;\";\nvar getStyles$1 = (contextId)=>{\n    const getSelector = makeGetSelector(contextId);\n    const dragHandle$1 = (()=>{\n        const grabCursor = `\n      cursor: -webkit-grab;\n      cursor: grab;\n    `;\n        return {\n            selector: getSelector(dragHandle.contextId),\n            styles: {\n                always: `\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        `,\n                resting: grabCursor,\n                dragging: noPointerEvents,\n                dropAnimating: grabCursor\n            }\n        };\n    })();\n    const draggable$1 = (()=>{\n        const transition = `\n      transition: ${transitions.outOfTheWay};\n    `;\n        return {\n            selector: getSelector(draggable.contextId),\n            styles: {\n                dragging: transition,\n                dropAnimating: transition,\n                userCancel: transition\n            }\n        };\n    })();\n    const droppable$1 = {\n        selector: getSelector(droppable.contextId),\n        styles: {\n            always: `overflow-anchor: none;`\n        }\n    };\n    const body = {\n        selector: \"body\",\n        styles: {\n            dragging: `\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      `\n        }\n    };\n    const rules = [\n        draggable$1,\n        dragHandle$1,\n        droppable$1,\n        body\n    ];\n    return {\n        always: getStyles(rules, \"always\"),\n        resting: getStyles(rules, \"resting\"),\n        dragging: getStyles(rules, \"dragging\"),\n        dropAnimating: getStyles(rules, \"dropAnimating\"),\n        userCancel: getStyles(rules, \"userCancel\")\n    };\n};\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nconst getHead = ()=>{\n    const head = document.querySelector(\"head\");\n    !head ?  true ? invariant(false, \"Cannot find the head to append a style to\") : 0 : void 0;\n    return head;\n};\nconst createStyleEl = (nonce)=>{\n    const el = document.createElement(\"style\");\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    el.type = \"text/css\";\n    return el;\n};\nfunction useStyleMarshal(contextId, nonce) {\n    const styles = useMemo(()=>getStyles$1(contextId), [\n        contextId\n    ]);\n    const alwaysRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const dynamicRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setDynamicStyle = useCallback(memoizeOne((proposed)=>{\n        const el = dynamicRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }), []);\n    const setAlwaysStyle = useCallback((proposed)=>{\n        const el = alwaysRef.current;\n        !el ?  true ? invariant(false, \"Cannot set dynamic style element if it is not set\") : 0 : void 0;\n        el.textContent = proposed;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        !(!alwaysRef.current && !dynamicRef.current) ?  true ? invariant(false, \"style elements already mounted\") : 0 : void 0;\n        const always = createStyleEl(nonce);\n        const dynamic = createStyleEl(nonce);\n        alwaysRef.current = always;\n        dynamicRef.current = dynamic;\n        always.setAttribute(`${prefix}-always`, contextId);\n        dynamic.setAttribute(`${prefix}-dynamic`, contextId);\n        getHead().appendChild(always);\n        getHead().appendChild(dynamic);\n        setAlwaysStyle(styles.always);\n        setDynamicStyle(styles.resting);\n        return ()=>{\n            const remove = (ref)=>{\n                const current = ref.current;\n                !current ?  true ? invariant(false, \"Cannot unmount ref as it is not set\") : 0 : void 0;\n                getHead().removeChild(current);\n                ref.current = null;\n            };\n            remove(alwaysRef);\n            remove(dynamicRef);\n        };\n    }, [\n        nonce,\n        setAlwaysStyle,\n        setDynamicStyle,\n        styles.always,\n        styles.resting,\n        contextId\n    ]);\n    const dragging = useCallback(()=>setDynamicStyle(styles.dragging), [\n        setDynamicStyle,\n        styles.dragging\n    ]);\n    const dropping = useCallback((reason)=>{\n        if (reason === \"DROP\") {\n            setDynamicStyle(styles.dropAnimating);\n            return;\n        }\n        setDynamicStyle(styles.userCancel);\n    }, [\n        setDynamicStyle,\n        styles.dropAnimating,\n        styles.userCancel\n    ]);\n    const resting = useCallback(()=>{\n        if (!dynamicRef.current) {\n            return;\n        }\n        setDynamicStyle(styles.resting);\n    }, [\n        setDynamicStyle,\n        styles.resting\n    ]);\n    const marshal = useMemo(()=>({\n            dragging,\n            dropping,\n            resting\n        }), [\n        dragging,\n        dropping,\n        resting\n    ]);\n    return marshal;\n}\nfunction querySelectorAll(parentNode, selector) {\n    return Array.from(parentNode.querySelectorAll(selector));\n}\nvar getWindowFromEl = (el)=>{\n    if (el && el.ownerDocument && el.ownerDocument.defaultView) {\n        return el.ownerDocument.defaultView;\n    }\n    return window;\n};\nfunction isHtmlElement(el) {\n    return el instanceof getWindowFromEl(el).HTMLElement;\n}\nfunction findDragHandle(contextId, draggableId) {\n    const selector = `[${dragHandle.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    if (!possible.length) {\n         true ? warning(`Unable to find any drag handles in the context \"${contextId}\"`) : 0;\n        return null;\n    }\n    const handle = possible.find((el)=>{\n        return el.getAttribute(dragHandle.draggableId) === draggableId;\n    });\n    if (!handle) {\n         true ? warning(`Unable to find drag handle with id \"${draggableId}\" as no handle with a matching id was found`) : 0;\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle needs to be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction useFocusMarshal(contextId) {\n    const entriesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const recordRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const restoreFocusFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const register = useCallback(function register(id, focus) {\n        const entry = {\n            id,\n            focus\n        };\n        entriesRef.current[id] = entry;\n        return function unregister() {\n            const entries = entriesRef.current;\n            const current = entries[id];\n            if (current !== entry) {\n                delete entries[id];\n            }\n        };\n    }, []);\n    const tryGiveFocus = useCallback(function tryGiveFocus(tryGiveFocusTo) {\n        const handle = findDragHandle(contextId, tryGiveFocusTo);\n        if (handle && handle !== document.activeElement) {\n            handle.focus();\n        }\n    }, [\n        contextId\n    ]);\n    const tryShiftRecord = useCallback(function tryShiftRecord(previous, redirectTo) {\n        if (recordRef.current === previous) {\n            recordRef.current = redirectTo;\n        }\n    }, []);\n    const tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded() {\n        if (restoreFocusFrameRef.current) {\n            return;\n        }\n        if (!isMountedRef.current) {\n            return;\n        }\n        restoreFocusFrameRef.current = requestAnimationFrame(()=>{\n            restoreFocusFrameRef.current = null;\n            const record = recordRef.current;\n            if (record) {\n                tryGiveFocus(record);\n            }\n        });\n    }, [\n        tryGiveFocus\n    ]);\n    const tryRecordFocus = useCallback(function tryRecordFocus(id) {\n        recordRef.current = null;\n        const focused = document.activeElement;\n        if (!focused) {\n            return;\n        }\n        if (focused.getAttribute(dragHandle.draggableId) !== id) {\n            return;\n        }\n        recordRef.current = id;\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        isMountedRef.current = true;\n        return function clearFrameOnUnmount() {\n            isMountedRef.current = false;\n            const frameId = restoreFocusFrameRef.current;\n            if (frameId) {\n                cancelAnimationFrame(frameId);\n            }\n        };\n    }, []);\n    const marshal = useMemo(()=>({\n            register,\n            tryRecordFocus,\n            tryRestoreFocusRecorded,\n            tryShiftRecord\n        }), [\n        register,\n        tryRecordFocus,\n        tryRestoreFocusRecorded,\n        tryShiftRecord\n    ]);\n    return marshal;\n}\nfunction createRegistry() {\n    const entries = {\n        draggables: {},\n        droppables: {}\n    };\n    const subscribers = [];\n    function subscribe(cb) {\n        subscribers.push(cb);\n        return function unsubscribe() {\n            const index = subscribers.indexOf(cb);\n            if (index === -1) {\n                return;\n            }\n            subscribers.splice(index, 1);\n        };\n    }\n    function notify(event) {\n        if (subscribers.length) {\n            subscribers.forEach((cb)=>cb(event));\n        }\n    }\n    function findDraggableById(id) {\n        return entries.draggables[id] || null;\n    }\n    function getDraggableById(id) {\n        const entry = findDraggableById(id);\n        !entry ?  true ? invariant(false, `Cannot find draggable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const draggableAPI = {\n        register: (entry)=>{\n            entries.draggables[entry.descriptor.id] = entry;\n            notify({\n                type: \"ADDITION\",\n                value: entry\n            });\n        },\n        update: (entry, last)=>{\n            const current = entries.draggables[last.descriptor.id];\n            if (!current) {\n                return;\n            }\n            if (current.uniqueId !== entry.uniqueId) {\n                return;\n            }\n            delete entries.draggables[last.descriptor.id];\n            entries.draggables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const draggableId = entry.descriptor.id;\n            const current = findDraggableById(draggableId);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.draggables[draggableId];\n            if (entries.droppables[entry.descriptor.droppableId]) {\n                notify({\n                    type: \"REMOVAL\",\n                    value: entry\n                });\n            }\n        },\n        getById: getDraggableById,\n        findById: findDraggableById,\n        exists: (id)=>Boolean(findDraggableById(id)),\n        getAllByType: (type)=>Object.values(entries.draggables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function findDroppableById(id) {\n        return entries.droppables[id] || null;\n    }\n    function getDroppableById(id) {\n        const entry = findDroppableById(id);\n        !entry ?  true ? invariant(false, `Cannot find droppable entry with id [${id}]`) : 0 : void 0;\n        return entry;\n    }\n    const droppableAPI = {\n        register: (entry)=>{\n            entries.droppables[entry.descriptor.id] = entry;\n        },\n        unregister: (entry)=>{\n            const current = findDroppableById(entry.descriptor.id);\n            if (!current) {\n                return;\n            }\n            if (entry.uniqueId !== current.uniqueId) {\n                return;\n            }\n            delete entries.droppables[entry.descriptor.id];\n        },\n        getById: getDroppableById,\n        findById: findDroppableById,\n        exists: (id)=>Boolean(findDroppableById(id)),\n        getAllByType: (type)=>Object.values(entries.droppables).filter((entry)=>entry.descriptor.type === type)\n    };\n    function clean() {\n        entries.draggables = {};\n        entries.droppables = {};\n        subscribers.length = 0;\n    }\n    return {\n        draggable: draggableAPI,\n        droppable: droppableAPI,\n        subscribe,\n        clean\n    };\n}\nfunction useRegistry() {\n    const registry = useMemo(createRegistry, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return function unmount() {\n            registry.clean();\n        };\n    }, [\n        registry\n    ]);\n    return registry;\n}\nvar StoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getBodyElement = ()=>{\n    const body = document.body;\n    !body ?  true ? invariant(false, \"Cannot find document.body\") : 0 : void 0;\n    return body;\n};\nconst visuallyHidden = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    margin: \"-1px\",\n    border: \"0\",\n    padding: \"0\",\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    \"clip-path\": \"inset(100%)\"\n};\nconst getId = (contextId)=>`rfd-announcement-${contextId}`;\nfunction useAnnouncer(contextId) {\n    const id = useMemo(()=>getId(contextId), [\n        contextId\n    ]);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function setup() {\n        const el = document.createElement(\"div\");\n        ref.current = el;\n        el.id = id;\n        el.setAttribute(\"aria-live\", \"assertive\");\n        el.setAttribute(\"aria-atomic\", \"true\");\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el.style, visuallyHidden);\n        getBodyElement().appendChild(el);\n        return function cleanup() {\n            setTimeout(function remove() {\n                const body = getBodyElement();\n                if (body.contains(el)) {\n                    body.removeChild(el);\n                }\n                if (el === ref.current) {\n                    ref.current = null;\n                }\n            });\n        };\n    }, [\n        id\n    ]);\n    const announce = useCallback((message)=>{\n        const el = ref.current;\n        if (el) {\n            el.textContent = message;\n            return;\n        }\n         true ? warning(`\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      \"${message}\"\n    `) : 0;\n    }, []);\n    return announce;\n}\nconst defaults = {\n    separator: \"::\"\n};\nfunction useUniqueId(prefix, options = defaults) {\n    const id = react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n    return useMemo(()=>`${prefix}${options.separator}${id}`, [\n        options.separator,\n        prefix,\n        id\n    ]);\n}\nfunction getElementId({ contextId, uniqueId }) {\n    return `rfd-hidden-text-${contextId}-${uniqueId}`;\n}\nfunction useHiddenTextElement({ contextId, text }) {\n    const uniqueId = useUniqueId(\"hidden-text\", {\n        separator: \"-\"\n    });\n    const id = useMemo(()=>getElementId({\n            contextId,\n            uniqueId\n        }), [\n        uniqueId,\n        contextId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function mount() {\n        const el = document.createElement(\"div\");\n        el.id = id;\n        el.textContent = text;\n        el.style.display = \"none\";\n        getBodyElement().appendChild(el);\n        return function unmount() {\n            const body = getBodyElement();\n            if (body.contains(el)) {\n                body.removeChild(el);\n            }\n        };\n    }, [\n        id,\n        text\n    ]);\n    return id;\n}\nvar AppContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar peerDependencies = {\n    react: \"^18.0.0 || ^19.0.0\"\n};\nconst semver = /(\\d+)\\.(\\d+)\\.(\\d+)/;\nconst getVersion = (value)=>{\n    const result = semver.exec(value);\n    !(result != null) ?  true ? invariant(false, `Unable to parse React version ${value}`) : 0 : void 0;\n    const major = Number(result[1]);\n    const minor = Number(result[2]);\n    const patch = Number(result[3]);\n    return {\n        major,\n        minor,\n        patch,\n        raw: value\n    };\n};\nconst isSatisfied = (expected, actual)=>{\n    if (actual.major > expected.major) {\n        return true;\n    }\n    if (actual.major < expected.major) {\n        return false;\n    }\n    if (actual.minor > expected.minor) {\n        return true;\n    }\n    if (actual.minor < expected.minor) {\n        return false;\n    }\n    return actual.patch >= expected.patch;\n};\nvar checkReactVersion = (peerDepValue, actualValue)=>{\n    const peerDep = getVersion(peerDepValue);\n    const actual = getVersion(actualValue);\n    if (isSatisfied(peerDep, actual)) {\n        return;\n    }\n     true ? warning(`\n    React version: [${actual.raw}]\n    does not satisfy expected peer dependency version: [${peerDep.raw}]\n\n    This can result in run time bugs, and even fatal crashes\n  `) : 0;\n};\nconst suffix = `\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/doctype.md\n`;\nvar checkDoctype = (doc)=>{\n    const doctype = doc.doctype;\n    if (!doctype) {\n         true ? warning(`\n      No <!doctype html> found.\n\n      ${suffix}\n    `) : 0;\n        return;\n    }\n    if (doctype.name.toLowerCase() !== \"html\") {\n         true ? warning(`\n      Unexpected <!doctype> found: (${doctype.name})\n\n      ${suffix}\n    `) : 0;\n    }\n    if (doctype.publicId !== \"\") {\n         true ? warning(`\n      Unexpected <!doctype> publicId found: (${doctype.publicId})\n      A html5 doctype does not have a publicId\n\n      ${suffix}\n    `) : 0;\n    }\n};\nfunction useDev(useHook) {\n    if (true) {\n        useHook();\n    }\n}\nfunction useDevSetupWarning(fn, inputs) {\n    useDev(()=>{\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n            try {\n                fn();\n            } catch (e) {\n                error(`\n          A setup problem was encountered.\n\n          > ${e.message}\n        `);\n            }\n        }, inputs);\n    });\n}\nfunction useStartupValidation() {\n    useDevSetupWarning(()=>{\n        checkReactVersion(peerDependencies.react, (react__WEBPACK_IMPORTED_MODULE_0___default().version));\n        checkDoctype(document);\n    }, []);\n}\nfunction usePrevious(current) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = current;\n    });\n    return ref;\n}\nfunction create() {\n    let lock = null;\n    function isClaimed() {\n        return Boolean(lock);\n    }\n    function isActive(value) {\n        return value === lock;\n    }\n    function claim(abandon) {\n        !!lock ?  true ? invariant(false, \"Cannot claim lock as it is already claimed\") : 0 : void 0;\n        const newLock = {\n            abandon\n        };\n        lock = newLock;\n        return newLock;\n    }\n    function release() {\n        !lock ?  true ? invariant(false, \"Cannot release lock when there is no lock\") : 0 : void 0;\n        lock = null;\n    }\n    function tryAbandon() {\n        if (lock) {\n            lock.abandon();\n            release();\n        }\n    }\n    return {\n        isClaimed,\n        isActive,\n        claim,\n        release,\n        tryAbandon\n    };\n}\nfunction isDragging(state) {\n    if (state.phase === \"IDLE\" || state.phase === \"DROP_ANIMATING\") {\n        return false;\n    }\n    return state.isDragging;\n}\nconst tab = 9;\nconst enter = 13;\nconst escape = 27;\nconst space = 32;\nconst pageUp = 33;\nconst pageDown = 34;\nconst end = 35;\nconst home = 36;\nconst arrowLeft = 37;\nconst arrowUp = 38;\nconst arrowRight = 39;\nconst arrowDown = 40;\nconst preventedKeys = {\n    [enter]: true,\n    [tab]: true\n};\nvar preventStandardKeyEvents = (event)=>{\n    if (preventedKeys[event.keyCode]) {\n        event.preventDefault();\n    }\n};\nconst supportedEventName = (()=>{\n    const base = \"visibilitychange\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        `ms${base}`,\n        `webkit${base}`,\n        `moz${base}`,\n        `o${base}`\n    ];\n    const supported = candidates.find((eventName)=>`on${eventName}` in document);\n    return supported || base;\n})();\nconst primaryButton = 0;\nconst sloppyClickThreshold = 5;\nfunction isSloppyClickThresholdExceeded(original, current) {\n    return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;\n}\nconst idle$1 = {\n    type: \"IDLE\"\n};\nfunction getCaptureBindings({ cancel, completed, getPhase, setPhase }) {\n    return [\n        {\n            eventName: \"mousemove\",\n            fn: (event)=>{\n                const { button, clientX, clientY } = event;\n                if (button !== primaryButton) {\n                    return;\n                }\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                const phase = getPhase();\n                if (phase.type === \"DRAGGING\") {\n                    event.preventDefault();\n                    phase.actions.move(point);\n                    return;\n                }\n                !(phase.type === \"PENDING\") ?  true ? invariant(false, \"Cannot be IDLE\") : 0 : void 0;\n                const pending = phase.point;\n                if (!isSloppyClickThresholdExceeded(pending, point)) {\n                    return;\n                }\n                event.preventDefault();\n                const actions = phase.actions.fluidLift(point);\n                setPhase({\n                    type: \"DRAGGING\",\n                    actions\n                });\n            }\n        },\n        {\n            eventName: \"mouseup\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: (event)=>{\n                if (getPhase().type === \"DRAGGING\") {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type === \"PENDING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"scroll\",\n            options: {\n                passive: true,\n                capture: false\n            },\n            fn: ()=>{\n                if (getPhase().type === \"PENDING\") {\n                    cancel();\n                }\n            }\n        },\n        {\n            eventName: \"webkitmouseforcedown\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant(false, \"Unexpected phase\") : 0 : void 0;\n                if (phase.actions.shouldRespectForcePress()) {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useMouseSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle$1);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"mousedown\",\n            fn: function onMouseDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.button !== primaryButton) {\n                    return;\n                }\n                if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                event.preventDefault();\n                const point = {\n                    x: event.clientX,\n                    y: event.clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const preventForcePressBinding = useMemo(()=>({\n            eventName: \"webkitmouseforcewillbegin\",\n            fn: (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const id = api.findClosestDraggableId(event);\n                if (!id) {\n                    return;\n                }\n                const options = api.findOptionsForDraggable(id);\n                if (!options) {\n                    return;\n                }\n                if (options.shouldRespectForcePress) {\n                    return;\n                }\n                if (!api.canGetLock(id)) {\n                    return;\n                }\n                event.preventDefault();\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function listenForCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            preventForcePressBinding,\n            startCaptureBinding\n        ], options);\n    }, [\n        preventForcePressBinding,\n        startCaptureBinding\n    ]);\n    const stop = useCallback(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        phaseRef.current = idle$1;\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture\n    ]);\n    const cancel = useCallback(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const bindings = getCaptureBindings({\n            cancel,\n            completed: stop,\n            getPhase: ()=>phaseRef.current,\n            setPhase: (phase)=>{\n                phaseRef.current = phase;\n            }\n        });\n        unbindEventsRef.current = bindEvents(window, bindings, options);\n    }, [\n        cancel,\n        stop\n    ]);\n    const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n        !(phaseRef.current.type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        phaseRef.current = {\n            type: \"PENDING\",\n            point,\n            actions\n        };\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nfunction noop$1() {}\nconst scrollJumpKeys = {\n    [pageDown]: true,\n    [pageUp]: true,\n    [home]: true,\n    [end]: true\n};\nfunction getDraggingBindings(actions, stop) {\n    function cancel() {\n        stop();\n        actions.cancel();\n    }\n    function drop() {\n        stop();\n        actions.drop();\n    }\n    return [\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === space) {\n                    event.preventDefault();\n                    drop();\n                    return;\n                }\n                if (event.keyCode === arrowDown) {\n                    event.preventDefault();\n                    actions.moveDown();\n                    return;\n                }\n                if (event.keyCode === arrowUp) {\n                    event.preventDefault();\n                    actions.moveUp();\n                    return;\n                }\n                if (event.keyCode === arrowRight) {\n                    event.preventDefault();\n                    actions.moveRight();\n                    return;\n                }\n                if (event.keyCode === arrowLeft) {\n                    event.preventDefault();\n                    actions.moveLeft();\n                    return;\n                }\n                if (scrollJumpKeys[event.keyCode]) {\n                    event.preventDefault();\n                    return;\n                }\n                preventStandardKeyEvents(event);\n            }\n        },\n        {\n            eventName: \"mousedown\",\n            fn: cancel\n        },\n        {\n            eventName: \"mouseup\",\n            fn: cancel\n        },\n        {\n            eventName: \"click\",\n            fn: cancel\n        },\n        {\n            eventName: \"touchstart\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"wheel\",\n            fn: cancel,\n            options: {\n                passive: true\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useKeyboardSensor(api) {\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$1);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"keydown\",\n            fn: function onKeyDown(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                if (event.keyCode !== space) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const preDrag = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!preDrag) {\n                    return;\n                }\n                event.preventDefault();\n                let isCapturing = true;\n                const actions = preDrag.snapLift();\n                unbindEventsRef.current();\n                function stop() {\n                    !isCapturing ?  true ? invariant(false, \"Cannot stop capturing a keyboard drag when not capturing\") : 0 : void 0;\n                    isCapturing = false;\n                    unbindEventsRef.current();\n                    listenForCapture();\n                }\n                unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {\n                    capture: true,\n                    passive: false\n                });\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function tryStartCapture() {\n        const options = {\n            passive: false,\n            capture: true\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n        };\n    }, [\n        listenForCapture\n    ]);\n}\nconst idle = {\n    type: \"IDLE\"\n};\nconst timeForLongPress = 120;\nconst forcePressThreshold = 0.15;\nfunction getWindowBindings({ cancel, getPhase }) {\n    return [\n        {\n            eventName: \"orientationchange\",\n            fn: cancel\n        },\n        {\n            eventName: \"resize\",\n            fn: cancel\n        },\n        {\n            eventName: \"contextmenu\",\n            fn: (event)=>{\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: \"keydown\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                if (event.keyCode === escape) {\n                    event.preventDefault();\n                }\n                cancel();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction getHandleBindings({ cancel, completed, getPhase }) {\n    return [\n        {\n            eventName: \"touchmove\",\n            options: {\n                capture: false\n            },\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                phase.hasMoved = true;\n                const { clientX, clientY } = event.touches[0];\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                event.preventDefault();\n                phase.actions.move(point);\n            }\n        },\n        {\n            eventName: \"touchend\",\n            fn: (event)=>{\n                const phase = getPhase();\n                if (phase.type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                phase.actions.drop({\n                    shouldBlockNextClick: true\n                });\n                completed();\n            }\n        },\n        {\n            eventName: \"touchcancel\",\n            fn: (event)=>{\n                if (getPhase().type !== \"DRAGGING\") {\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n                cancel();\n            }\n        },\n        {\n            eventName: \"touchforcechange\",\n            fn: (event)=>{\n                const phase = getPhase();\n                !(phase.type !== \"IDLE\") ?  true ? invariant() : 0 : void 0;\n                const touch = event.touches[0];\n                if (!touch) {\n                    return;\n                }\n                const isForcePress = touch.force >= forcePressThreshold;\n                if (!isForcePress) {\n                    return;\n                }\n                const shouldRespect = phase.actions.shouldRespectForcePress();\n                if (phase.type === \"PENDING\") {\n                    if (shouldRespect) {\n                        cancel();\n                    }\n                    return;\n                }\n                if (shouldRespect) {\n                    if (phase.hasMoved) {\n                        event.preventDefault();\n                        return;\n                    }\n                    cancel();\n                    return;\n                }\n                event.preventDefault();\n            }\n        },\n        {\n            eventName: supportedEventName,\n            fn: cancel\n        }\n    ];\n}\nfunction useTouchSensor(api) {\n    const phaseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(idle);\n    const unbindEventsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(noop$2);\n    const getPhase = useCallback(function getPhase() {\n        return phaseRef.current;\n    }, []);\n    const setPhase = useCallback(function setPhase(phase) {\n        phaseRef.current = phase;\n    }, []);\n    const startCaptureBinding = useMemo(()=>({\n            eventName: \"touchstart\",\n            fn: function onTouchStart(event) {\n                if (event.defaultPrevented) {\n                    return;\n                }\n                const draggableId = api.findClosestDraggableId(event);\n                if (!draggableId) {\n                    return;\n                }\n                const actions = api.tryGetLock(draggableId, stop, {\n                    sourceEvent: event\n                });\n                if (!actions) {\n                    return;\n                }\n                const touch = event.touches[0];\n                const { clientX, clientY } = touch;\n                const point = {\n                    x: clientX,\n                    y: clientY\n                };\n                unbindEventsRef.current();\n                startPendingDrag(actions, point);\n            }\n        }), [\n        api\n    ]);\n    const listenForCapture = useCallback(function listenForCapture() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        unbindEventsRef.current = bindEvents(window, [\n            startCaptureBinding\n        ], options);\n    }, [\n        startCaptureBinding\n    ]);\n    const stop = useCallback(()=>{\n        const current = phaseRef.current;\n        if (current.type === \"IDLE\") {\n            return;\n        }\n        if (current.type === \"PENDING\") {\n            clearTimeout(current.longPressTimerId);\n        }\n        setPhase(idle);\n        unbindEventsRef.current();\n        listenForCapture();\n    }, [\n        listenForCapture,\n        setPhase\n    ]);\n    const cancel = useCallback(()=>{\n        const phase = phaseRef.current;\n        stop();\n        if (phase.type === \"DRAGGING\") {\n            phase.actions.cancel({\n                shouldBlockNextClick: true\n            });\n        }\n        if (phase.type === \"PENDING\") {\n            phase.actions.abort();\n        }\n    }, [\n        stop\n    ]);\n    const bindCapturingEvents = useCallback(function bindCapturingEvents() {\n        const options = {\n            capture: true,\n            passive: false\n        };\n        const args = {\n            cancel,\n            completed: stop,\n            getPhase\n        };\n        const unbindTarget = bindEvents(window, getHandleBindings(args), options);\n        const unbindWindow = bindEvents(window, getWindowBindings(args), options);\n        unbindEventsRef.current = function unbindAll() {\n            unbindTarget();\n            unbindWindow();\n        };\n    }, [\n        cancel,\n        getPhase,\n        stop\n    ]);\n    const startDragging = useCallback(function startDragging() {\n        const phase = getPhase();\n        !(phase.type === \"PENDING\") ?  true ? invariant(false, `Cannot start dragging from phase ${phase.type}`) : 0 : void 0;\n        const actions = phase.actions.fluidLift(phase.point);\n        setPhase({\n            type: \"DRAGGING\",\n            actions,\n            hasMoved: false\n        });\n    }, [\n        getPhase,\n        setPhase\n    ]);\n    const startPendingDrag = useCallback(function startPendingDrag(actions, point) {\n        !(getPhase().type === \"IDLE\") ?  true ? invariant(false, \"Expected to move from IDLE to PENDING drag\") : 0 : void 0;\n        const longPressTimerId = setTimeout(startDragging, timeForLongPress);\n        setPhase({\n            type: \"PENDING\",\n            point,\n            actions,\n            longPressTimerId\n        });\n        bindCapturingEvents();\n    }, [\n        bindCapturingEvents,\n        getPhase,\n        setPhase,\n        startDragging\n    ]);\n    useIsomorphicLayoutEffect(function mount() {\n        listenForCapture();\n        return function unmount() {\n            unbindEventsRef.current();\n            const phase = getPhase();\n            if (phase.type === \"PENDING\") {\n                clearTimeout(phase.longPressTimerId);\n                setPhase(idle);\n            }\n        };\n    }, [\n        getPhase,\n        listenForCapture,\n        setPhase\n    ]);\n    useIsomorphicLayoutEffect(function webkitHack() {\n        const unbind = bindEvents(window, [\n            {\n                eventName: \"touchmove\",\n                fn: ()=>{},\n                options: {\n                    capture: false,\n                    passive: false\n                }\n            }\n        ]);\n        return unbind;\n    }, []);\n}\nfunction useValidateSensorHooks(sensorHooks) {\n    useDev(()=>{\n        const previousRef = usePrevious(sensorHooks);\n        useDevSetupWarning(()=>{\n            !(previousRef.current.length === sensorHooks.length) ?  true ? invariant(false, \"Cannot change the amount of sensor hooks after mounting\") : 0 : void 0;\n        });\n    });\n}\nconst interactiveTagNames = [\n    \"input\",\n    \"button\",\n    \"textarea\",\n    \"select\",\n    \"option\",\n    \"optgroup\",\n    \"video\",\n    \"audio\"\n];\nfunction isAnInteractiveElement(parent, current) {\n    if (current == null) {\n        return false;\n    }\n    const hasAnInteractiveTag = interactiveTagNames.includes(current.tagName.toLowerCase());\n    if (hasAnInteractiveTag) {\n        return true;\n    }\n    const attribute = current.getAttribute(\"contenteditable\");\n    if (attribute === \"true\" || attribute === \"\") {\n        return true;\n    }\n    if (current === parent) {\n        return false;\n    }\n    return isAnInteractiveElement(parent, current.parentElement);\n}\nfunction isEventInInteractiveElement(draggable, event) {\n    const target = event.target;\n    if (!isHtmlElement(target)) {\n        return false;\n    }\n    return isAnInteractiveElement(draggable, target);\n}\nvar getBorderBoxCenterPosition = (el)=>(0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getRect)(el.getBoundingClientRect()).center;\nfunction isElement(el) {\n    return el instanceof getWindowFromEl(el).Element;\n}\nconst supportedMatchesName = (()=>{\n    const base = \"matches\";\n    if (typeof document === \"undefined\") {\n        return base;\n    }\n    const candidates = [\n        base,\n        \"msMatchesSelector\",\n        \"webkitMatchesSelector\"\n    ];\n    const value = candidates.find((name)=>name in Element.prototype);\n    return value || base;\n})();\nfunction closestPonyfill(el, selector) {\n    if (el == null) {\n        return null;\n    }\n    if (el[supportedMatchesName](selector)) {\n        return el;\n    }\n    return closestPonyfill(el.parentElement, selector);\n}\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    return closestPonyfill(el, selector);\n}\nfunction getSelector(contextId) {\n    return `[${dragHandle.contextId}=\"${contextId}\"]`;\n}\nfunction findClosestDragHandleFromEvent(contextId, event) {\n    const target = event.target;\n    if (!isElement(target)) {\n         true ? warning(\"event.target must be a Element\") : 0;\n        return null;\n    }\n    const selector = getSelector(contextId);\n    const handle = closest(target, selector);\n    if (!handle) {\n        return null;\n    }\n    if (!isHtmlElement(handle)) {\n         true ? warning(\"drag handle must be a HTMLElement\") : 0;\n        return null;\n    }\n    return handle;\n}\nfunction tryGetClosestDraggableIdFromEvent(contextId, event) {\n    const handle = findClosestDragHandleFromEvent(contextId, event);\n    if (!handle) {\n        return null;\n    }\n    return handle.getAttribute(dragHandle.draggableId);\n}\nfunction findDraggable(contextId, draggableId) {\n    const selector = `[${draggable.contextId}=\"${contextId}\"]`;\n    const possible = querySelectorAll(document, selector);\n    const draggable$1 = possible.find((el)=>{\n        return el.getAttribute(draggable.id) === draggableId;\n    });\n    if (!draggable$1) {\n        return null;\n    }\n    if (!isHtmlElement(draggable$1)) {\n         true ? warning(\"Draggable element is not a HTMLElement\") : 0;\n        return null;\n    }\n    return draggable$1;\n}\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction isActive({ expected, phase, isLockActive, shouldWarn }) {\n    if (!isLockActive()) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      `) : 0;\n        }\n        return false;\n    }\n    if (expected !== phase) {\n        if (shouldWarn) {\n             true ? warning(`\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: ${expected}\n        You called an action from outdated phase: ${phase}\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      `) : 0;\n        }\n        return false;\n    }\n    return true;\n}\nfunction canStart({ lockAPI, store, registry, draggableId }) {\n    if (lockAPI.isClaimed()) {\n        return false;\n    }\n    const entry = registry.draggable.findById(draggableId);\n    if (!entry) {\n         true ? warning(`Unable to find draggable with id: ${draggableId}`) : 0;\n        return false;\n    }\n    if (!entry.options.isEnabled) {\n        return false;\n    }\n    if (!canStartDrag(store.getState(), draggableId)) {\n        return false;\n    }\n    return true;\n}\nfunction tryStart({ lockAPI, contextId, store, registry, draggableId, forceSensorStop, sourceEvent }) {\n    const shouldStart = canStart({\n        lockAPI,\n        store,\n        registry,\n        draggableId\n    });\n    if (!shouldStart) {\n        return null;\n    }\n    const entry = registry.draggable.getById(draggableId);\n    const el = findDraggable(contextId, entry.descriptor.id);\n    if (!el) {\n         true ? warning(`Unable to find draggable element with id: ${draggableId}`) : 0;\n        return null;\n    }\n    if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {\n        return null;\n    }\n    const lock = lockAPI.claim(forceSensorStop || noop$2);\n    let phase = \"PRE_DRAG\";\n    function getShouldRespectForcePress() {\n        return entry.options.shouldRespectForcePress;\n    }\n    function isLockActive() {\n        return lockAPI.isActive(lock);\n    }\n    function tryDispatch(expected, getAction) {\n        if (isActive({\n            expected,\n            phase,\n            isLockActive,\n            shouldWarn: true\n        })) {\n            store.dispatch(getAction());\n        }\n    }\n    const tryDispatchWhenDragging = tryDispatch.bind(null, \"DRAGGING\");\n    function lift(args) {\n        function completed() {\n            lockAPI.release();\n            phase = \"COMPLETED\";\n        }\n        if (phase !== \"PRE_DRAG\") {\n            completed();\n             true ? invariant(false, `Cannot lift in phase ${phase}`) : 0;\n        }\n        store.dispatch(lift$1(args.liftActionArgs));\n        phase = \"DRAGGING\";\n        function finish(reason, options = {\n            shouldBlockNextClick: false\n        }) {\n            args.cleanup();\n            if (options.shouldBlockNextClick) {\n                const unbind = bindEvents(window, [\n                    {\n                        eventName: \"click\",\n                        fn: preventDefault,\n                        options: {\n                            once: true,\n                            passive: false,\n                            capture: true\n                        }\n                    }\n                ]);\n                setTimeout(unbind);\n            }\n            completed();\n            store.dispatch(drop({\n                reason\n            }));\n        }\n        return {\n            isActive: ()=>isActive({\n                    expected: \"DRAGGING\",\n                    phase,\n                    isLockActive,\n                    shouldWarn: false\n                }),\n            shouldRespectForcePress: getShouldRespectForcePress,\n            drop: (options)=>finish(\"DROP\", options),\n            cancel: (options)=>finish(\"CANCEL\", options),\n            ...args.actions\n        };\n    }\n    function fluidLift(clientSelection) {\n        const move$1 = (0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((client)=>{\n            tryDispatchWhenDragging(()=>move({\n                    client\n                }));\n        });\n        const api = lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection,\n                movementMode: \"FLUID\"\n            },\n            cleanup: ()=>move$1.cancel(),\n            actions: {\n                move: move$1\n            }\n        });\n        return {\n            ...api,\n            move: move$1\n        };\n    }\n    function snapLift() {\n        const actions = {\n            moveUp: ()=>tryDispatchWhenDragging(moveUp),\n            moveRight: ()=>tryDispatchWhenDragging(moveRight),\n            moveDown: ()=>tryDispatchWhenDragging(moveDown),\n            moveLeft: ()=>tryDispatchWhenDragging(moveLeft)\n        };\n        return lift({\n            liftActionArgs: {\n                id: draggableId,\n                clientSelection: getBorderBoxCenterPosition(el),\n                movementMode: \"SNAP\"\n            },\n            cleanup: noop$2,\n            actions\n        });\n    }\n    function abortPreDrag() {\n        const shouldRelease = isActive({\n            expected: \"PRE_DRAG\",\n            phase,\n            isLockActive,\n            shouldWarn: true\n        });\n        if (shouldRelease) {\n            lockAPI.release();\n        }\n    }\n    const preDrag = {\n        isActive: ()=>isActive({\n                expected: \"PRE_DRAG\",\n                phase,\n                isLockActive,\n                shouldWarn: false\n            }),\n        shouldRespectForcePress: getShouldRespectForcePress,\n        fluidLift,\n        snapLift,\n        abort: abortPreDrag\n    };\n    return preDrag;\n}\nconst defaultSensors = [\n    useMouseSensor,\n    useKeyboardSensor,\n    useTouchSensor\n];\nfunction useSensorMarshal({ contextId, store, registry, customSensors, enableDefaultSensors }) {\n    const useSensors = [\n        ...enableDefaultSensors ? defaultSensors : [],\n        ...customSensors || []\n    ];\n    const lockAPI = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>create())[0];\n    const tryAbandonLock = useCallback(function tryAbandonLock(previous, current) {\n        if (isDragging(previous) && !isDragging(current)) {\n            lockAPI.tryAbandon();\n        }\n    }, [\n        lockAPI\n    ]);\n    useIsomorphicLayoutEffect(function listenToStore() {\n        let previous = store.getState();\n        const unsubscribe = store.subscribe(()=>{\n            const current = store.getState();\n            tryAbandonLock(previous, current);\n            previous = current;\n        });\n        return unsubscribe;\n    }, [\n        lockAPI,\n        store,\n        tryAbandonLock\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        return lockAPI.tryAbandon;\n    }, [\n        lockAPI.tryAbandon\n    ]);\n    const canGetLock = useCallback((draggableId)=>{\n        return canStart({\n            lockAPI,\n            registry,\n            store,\n            draggableId\n        });\n    }, [\n        lockAPI,\n        registry,\n        store\n    ]);\n    const tryGetLock = useCallback((draggableId, forceStop, options)=>tryStart({\n            lockAPI,\n            registry,\n            contextId,\n            store,\n            draggableId,\n            forceSensorStop: forceStop || null,\n            sourceEvent: options && options.sourceEvent ? options.sourceEvent : null\n        }), [\n        contextId,\n        lockAPI,\n        registry,\n        store\n    ]);\n    const findClosestDraggableId = useCallback((event)=>tryGetClosestDraggableIdFromEvent(contextId, event), [\n        contextId\n    ]);\n    const findOptionsForDraggable = useCallback((id)=>{\n        const entry = registry.draggable.findById(id);\n        return entry ? entry.options : null;\n    }, [\n        registry.draggable\n    ]);\n    const tryReleaseLock = useCallback(function tryReleaseLock() {\n        if (!lockAPI.isClaimed()) {\n            return;\n        }\n        lockAPI.tryAbandon();\n        if (store.getState().phase !== \"IDLE\") {\n            store.dispatch(flush());\n        }\n    }, [\n        lockAPI,\n        store\n    ]);\n    const isLockClaimed = useCallback(()=>lockAPI.isClaimed(), [\n        lockAPI\n    ]);\n    const api = useMemo(()=>({\n            canGetLock,\n            tryGetLock,\n            findClosestDraggableId,\n            findOptionsForDraggable,\n            tryReleaseLock,\n            isLockClaimed\n        }), [\n        canGetLock,\n        tryGetLock,\n        findClosestDraggableId,\n        findOptionsForDraggable,\n        tryReleaseLock,\n        isLockClaimed\n    ]);\n    useValidateSensorHooks(useSensors);\n    for(let i = 0; i < useSensors.length; i++){\n        useSensors[i](api);\n    }\n}\nconst createResponders = (props)=>({\n        onBeforeCapture: (t)=>{\n            const onBeforeCapureCallback = ()=>{\n                if (props.onBeforeCapture) {\n                    props.onBeforeCapture(t);\n                }\n            };\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(onBeforeCapureCallback);\n        },\n        onBeforeDragStart: props.onBeforeDragStart,\n        onDragStart: props.onDragStart,\n        onDragEnd: props.onDragEnd,\n        onDragUpdate: props.onDragUpdate\n    });\nconst createAutoScrollerOptions = (props)=>({\n        ...defaultAutoScrollerOptions,\n        ...props.autoScrollerOptions,\n        durationDampening: {\n            ...defaultAutoScrollerOptions.durationDampening,\n            ...props.autoScrollerOptions\n        }\n    });\nfunction getStore(lazyRef) {\n    !lazyRef.current ?  true ? invariant(false, \"Could not find store from lazy ref\") : 0 : void 0;\n    return lazyRef.current;\n}\nfunction App(props) {\n    const { contextId, setCallbacks, sensors, nonce, dragHandleUsageInstructions } = props;\n    const lazyStoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    useStartupValidation();\n    const lastPropsRef = usePrevious(props);\n    const getResponders = useCallback(()=>{\n        return createResponders(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const getAutoScrollerOptions = useCallback(()=>{\n        return createAutoScrollerOptions(lastPropsRef.current);\n    }, [\n        lastPropsRef\n    ]);\n    const announce = useAnnouncer(contextId);\n    const dragHandleUsageInstructionsId = useHiddenTextElement({\n        contextId,\n        text: dragHandleUsageInstructions\n    });\n    const styleMarshal = useStyleMarshal(contextId, nonce);\n    const lazyDispatch = useCallback((action)=>{\n        getStore(lazyStoreRef).dispatch(action);\n    }, []);\n    const marshalCallbacks = useMemo(()=>(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n            publishWhileDragging,\n            updateDroppableScroll,\n            updateDroppableIsEnabled,\n            updateDroppableIsCombineEnabled,\n            collectionStarting\n        }, lazyDispatch), [\n        lazyDispatch\n    ]);\n    const registry = useRegistry();\n    const dimensionMarshal = useMemo(()=>{\n        return createDimensionMarshal(registry, marshalCallbacks);\n    }, [\n        registry,\n        marshalCallbacks\n    ]);\n    const autoScroller = useMemo(()=>createAutoScroller({\n            scrollWindow,\n            scrollDroppable: dimensionMarshal.scrollDroppable,\n            getAutoScrollerOptions,\n            ...(0,redux__WEBPACK_IMPORTED_MODULE_5__.bindActionCreators)({\n                move\n            }, lazyDispatch)\n        }), [\n        dimensionMarshal.scrollDroppable,\n        lazyDispatch,\n        getAutoScrollerOptions\n    ]);\n    const focusMarshal = useFocusMarshal(contextId);\n    const store = useMemo(()=>createStore({\n            announce,\n            autoScroller,\n            dimensionMarshal,\n            focusMarshal,\n            getResponders,\n            styleMarshal\n        }), [\n        announce,\n        autoScroller,\n        dimensionMarshal,\n        focusMarshal,\n        getResponders,\n        styleMarshal\n    ]);\n    if (true) {\n        if (lazyStoreRef.current && lazyStoreRef.current !== store) {\n             true ? warning(\"unexpected store change\") : 0;\n        }\n    }\n    lazyStoreRef.current = store;\n    const tryResetStore = useCallback(()=>{\n        const current = getStore(lazyStoreRef);\n        const state = current.getState();\n        if (state.phase !== \"IDLE\") {\n            current.dispatch(flush());\n        }\n    }, []);\n    const isDragging = useCallback(()=>{\n        const state = getStore(lazyStoreRef).getState();\n        if (state.phase === \"DROP_ANIMATING\") {\n            return true;\n        }\n        if (state.phase === \"IDLE\") {\n            return false;\n        }\n        return state.isDragging;\n    }, []);\n    const appCallbacks = useMemo(()=>({\n            isDragging,\n            tryAbort: tryResetStore\n        }), [\n        isDragging,\n        tryResetStore\n    ]);\n    setCallbacks(appCallbacks);\n    const getCanLift = useCallback((id)=>canStartDrag(getStore(lazyStoreRef).getState(), id), []);\n    const getIsMovementAllowed = useCallback(()=>isMovementAllowed(getStore(lazyStoreRef).getState()), []);\n    const appContext = useMemo(()=>({\n            marshal: dimensionMarshal,\n            focus: focusMarshal,\n            contextId,\n            canLift: getCanLift,\n            isMovementAllowed: getIsMovementAllowed,\n            dragHandleUsageInstructionsId,\n            registry\n        }), [\n        contextId,\n        dimensionMarshal,\n        dragHandleUsageInstructionsId,\n        focusMarshal,\n        getCanLift,\n        getIsMovementAllowed,\n        registry\n    ]);\n    useSensorMarshal({\n        contextId,\n        store,\n        registry,\n        customSensors: sensors || null,\n        enableDefaultSensors: props.enableDefaultSensors !== false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return tryResetStore;\n    }, [\n        tryResetStore\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n        value: appContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_redux__WEBPACK_IMPORTED_MODULE_6__.Provider, {\n        context: StoreContext,\n        store: store\n    }, props.children));\n}\nfunction useUniqueContextId() {\n    return react__WEBPACK_IMPORTED_MODULE_0___default().useId();\n}\nfunction DragDropContext(props) {\n    const contextId = useUniqueContextId();\n    const dragHandleUsageInstructions = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ErrorBoundary, null, (setCallbacks)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(App, {\n            nonce: props.nonce,\n            contextId: contextId,\n            setCallbacks: setCallbacks,\n            dragHandleUsageInstructions: dragHandleUsageInstructions,\n            enableDefaultSensors: props.enableDefaultSensors,\n            sensors: props.sensors,\n            onBeforeCapture: props.onBeforeCapture,\n            onBeforeDragStart: props.onBeforeDragStart,\n            onDragStart: props.onDragStart,\n            onDragUpdate: props.onDragUpdate,\n            onDragEnd: props.onDragEnd,\n            autoScrollerOptions: props.autoScrollerOptions\n        }, props.children));\n}\nconst zIndexOptions = {\n    dragging: 5000,\n    dropAnimating: 4500\n};\nconst getDraggingTransition = (shouldAnimateDragMovement, dropping)=>{\n    if (dropping) {\n        return transitions.drop(dropping.duration);\n    }\n    if (shouldAnimateDragMovement) {\n        return transitions.snap;\n    }\n    return transitions.fluid;\n};\nconst getDraggingOpacity = (isCombining, isDropAnimating)=>{\n    if (!isCombining) {\n        return undefined;\n    }\n    return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;\n};\nconst getShouldDraggingAnimate = (dragging)=>{\n    if (dragging.forceShouldAnimate != null) {\n        return dragging.forceShouldAnimate;\n    }\n    return dragging.mode === \"SNAP\";\n};\nfunction getDraggingStyle(dragging) {\n    const dimension = dragging.dimension;\n    const box = dimension.client;\n    const { offset, combineWith, dropping } = dragging;\n    const isCombining = Boolean(combineWith);\n    const shouldAnimate = getShouldDraggingAnimate(dragging);\n    const isDropAnimating = Boolean(dropping);\n    const transform = isDropAnimating ? transforms.drop(offset, isCombining) : transforms.moveTo(offset);\n    const style = {\n        position: \"fixed\",\n        top: box.marginBox.top,\n        left: box.marginBox.left,\n        boxSizing: \"border-box\",\n        width: box.borderBox.width,\n        height: box.borderBox.height,\n        transition: getDraggingTransition(shouldAnimate, dropping),\n        transform,\n        opacity: getDraggingOpacity(isCombining, isDropAnimating),\n        zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,\n        pointerEvents: \"none\"\n    };\n    return style;\n}\nfunction getSecondaryStyle(secondary) {\n    return {\n        transform: transforms.moveTo(secondary.offset),\n        transition: secondary.shouldAnimateDisplacement ? undefined : \"none\"\n    };\n}\nfunction getStyle$1(mapped) {\n    return mapped.type === \"DRAGGING\" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);\n}\nfunction getDimension$1(descriptor, el, windowScroll = origin) {\n    const computedStyles = window.getComputedStyle(el);\n    const borderBox = el.getBoundingClientRect();\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.calculateBox)(borderBox, computedStyles);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const placeholder = {\n        client,\n        tagName: el.tagName.toLowerCase(),\n        display: computedStyles.display\n    };\n    const displaceBy = {\n        x: client.marginBox.width,\n        y: client.marginBox.height\n    };\n    const dimension = {\n        descriptor,\n        placeholder,\n        displaceBy,\n        client,\n        page\n    };\n    return dimension;\n}\nfunction useDraggablePublisher(args) {\n    const uniqueId = useUniqueId(\"draggable\");\n    const { descriptor, registry, getDraggableRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled } = args;\n    const options = useMemo(()=>({\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        }), [\n        canDragInteractiveElements,\n        isEnabled,\n        shouldRespectForcePress\n    ]);\n    const getDimension = useCallback((windowScroll)=>{\n        const el = getDraggableRef();\n        !el ?  true ? invariant(false, \"Cannot get dimension when no ref is set\") : 0 : void 0;\n        return getDimension$1(descriptor, el, windowScroll);\n    }, [\n        descriptor,\n        getDraggableRef\n    ]);\n    const entry = useMemo(()=>({\n            uniqueId,\n            descriptor,\n            options,\n            getDimension\n        }), [\n        descriptor,\n        getDimension,\n        options,\n        uniqueId\n    ]);\n    const publishedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(entry);\n    const isFirstPublishRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    useIsomorphicLayoutEffect(()=>{\n        registry.draggable.register(publishedRef.current);\n        return ()=>registry.draggable.unregister(publishedRef.current);\n    }, [\n        registry.draggable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (isFirstPublishRef.current) {\n            isFirstPublishRef.current = false;\n            return;\n        }\n        const last = publishedRef.current;\n        publishedRef.current = entry;\n        registry.draggable.update(entry, last);\n    }, [\n        entry,\n        registry.draggable\n    ]);\n}\nvar DroppableContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nfunction checkIsValidInnerRef(el) {\n    !(el && isHtmlElement(el)) ?  true ? invariant(false, `\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/hello-pangea/dnd/blob/main/docs/guides/using-inner-ref.md\n  `) : 0 : void 0;\n}\nfunction useValidation$1(props, contextId, getRef) {\n    useDevSetupWarning(()=>{\n        function prefix(id) {\n            return `Draggable[id: ${id}]: `;\n        }\n        const id = props.draggableId;\n        !id ?  true ? invariant(false, \"Draggable requires a draggableId\") : 0 : void 0;\n        !(typeof id === \"string\") ?  true ? invariant(false, `Draggable requires a [string] draggableId.\n      Provided: [type: ${typeof id}] (value: ${id})`) : 0 : void 0;\n        !Number.isInteger(props.index) ?  true ? invariant(false, `${prefix(id)} requires an integer index prop`) : 0 : void 0;\n        if (props.mapped.type === \"DRAGGING\") {\n            return;\n        }\n        checkIsValidInnerRef(getRef());\n        if (props.isEnabled) {\n            !findDragHandle(contextId, id) ?  true ? invariant(false, `${prefix(id)} Unable to find drag handle`) : 0 : void 0;\n        }\n    });\n}\nfunction useClonePropValidation(isClone) {\n    useDev(()=>{\n        const initialRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isClone);\n        useDevSetupWarning(()=>{\n            !(isClone === initialRef.current) ?  true ? invariant(false, \"Draggable isClone prop value changed during component life\") : 0 : void 0;\n        }, [\n            isClone\n        ]);\n    });\n}\nfunction useRequiredContext(Context) {\n    const result = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    !result ?  true ? invariant(false, \"Could not find required context\") : 0 : void 0;\n    return result;\n}\nfunction preventHtml5Dnd(event) {\n    event.preventDefault();\n}\nconst Draggable = (props)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setRef = useCallback((el = null)=>{\n        ref.current = el;\n    }, []);\n    const getRef = useCallback(()=>ref.current, []);\n    const { contextId, dragHandleUsageInstructionsId, registry } = useRequiredContext(AppContext);\n    const { type, droppableId } = useRequiredContext(DroppableContext);\n    const descriptor = useMemo(()=>({\n            id: props.draggableId,\n            index: props.index,\n            type,\n            droppableId\n        }), [\n        props.draggableId,\n        props.index,\n        type,\n        droppableId\n    ]);\n    const { children, draggableId, isEnabled, shouldRespectForcePress, canDragInteractiveElements, isClone, mapped, dropAnimationFinished: dropAnimationFinishedAction } = props;\n    useValidation$1(props, contextId, getRef);\n    useClonePropValidation(isClone);\n    if (!isClone) {\n        const forPublisher = useMemo(()=>({\n                descriptor,\n                registry,\n                getDraggableRef: getRef,\n                canDragInteractiveElements,\n                shouldRespectForcePress,\n                isEnabled\n            }), [\n            descriptor,\n            registry,\n            getRef,\n            canDragInteractiveElements,\n            shouldRespectForcePress,\n            isEnabled\n        ]);\n        useDraggablePublisher(forPublisher);\n    }\n    const dragHandleProps = useMemo(()=>isEnabled ? {\n            tabIndex: 0,\n            role: \"button\",\n            \"aria-describedby\": dragHandleUsageInstructionsId,\n            \"data-rfd-drag-handle-draggable-id\": draggableId,\n            \"data-rfd-drag-handle-context-id\": contextId,\n            draggable: false,\n            onDragStart: preventHtml5Dnd\n        } : null, [\n        contextId,\n        dragHandleUsageInstructionsId,\n        draggableId,\n        isEnabled\n    ]);\n    const onMoveEnd = useCallback((event)=>{\n        if (mapped.type !== \"DRAGGING\") {\n            return;\n        }\n        if (!mapped.dropping) {\n            return;\n        }\n        if (event.propertyName !== \"transform\") {\n            return;\n        }\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(dropAnimationFinishedAction);\n    }, [\n        dropAnimationFinishedAction,\n        mapped\n    ]);\n    const provided = useMemo(()=>{\n        const style = getStyle$1(mapped);\n        const onTransitionEnd = mapped.type === \"DRAGGING\" && mapped.dropping ? onMoveEnd : undefined;\n        const result = {\n            innerRef: setRef,\n            draggableProps: {\n                \"data-rfd-draggable-context-id\": contextId,\n                \"data-rfd-draggable-id\": draggableId,\n                style,\n                onTransitionEnd\n            },\n            dragHandleProps\n        };\n        return result;\n    }, [\n        contextId,\n        dragHandleProps,\n        draggableId,\n        mapped,\n        onMoveEnd,\n        setRef\n    ]);\n    const rubric = useMemo(()=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }), [\n        descriptor.droppableId,\n        descriptor.id,\n        descriptor.index,\n        descriptor.type\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children(provided, mapped.snapshot, rubric));\n};\nvar isStrictEqual = (a, b)=>a === b;\nvar whatIsDraggedOverFromResult = (result)=>{\n    const { combine, destination } = result;\n    if (destination) {\n        return destination.droppableId;\n    }\n    if (combine) {\n        return combine.droppableId;\n    }\n    return null;\n};\nconst getCombineWithFromResult = (result)=>{\n    return result.combine ? result.combine.draggableId : null;\n};\nconst getCombineWithFromImpact = (impact)=>{\n    return impact.at && impact.at.type === \"COMBINE\" ? impact.at.combine.draggableId : null;\n};\nfunction getDraggableSelector() {\n    const memoizedOffset = memoizeOne((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = memoizeOne((mode, isClone, draggingOver = null, combineWith = null, dropping = null)=>({\n            isDragging: true,\n            isClone,\n            isDropAnimating: Boolean(dropping),\n            dropAnimation: dropping,\n            mode,\n            draggingOver,\n            combineWith,\n            combineTargetFor: null\n        }));\n    const getMemoizedProps = memoizeOne((offset, mode, dimension, isClone, draggingOver = null, combineWith = null, forceShouldAnimate = null)=>({\n            mapped: {\n                type: \"DRAGGING\",\n                dropping: null,\n                draggingOver,\n                combineWith,\n                mode,\n                offset,\n                dimension,\n                forceShouldAnimate,\n                snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)\n            }\n        }));\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id !== ownProps.draggableId) {\n                return null;\n            }\n            const offset = state.current.client.offset;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const draggingOver = whatIsDraggedOver(state.impact);\n            const combineWith = getCombineWithFromImpact(state.impact);\n            const forceShouldAnimate = state.forceShouldAnimate;\n            return getMemoizedProps(memoizedOffset(offset.x, offset.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId !== ownProps.draggableId) {\n                return null;\n            }\n            const isClone = ownProps.isClone;\n            const dimension = state.dimensions.draggables[ownProps.draggableId];\n            const result = completed.result;\n            const mode = result.mode;\n            const draggingOver = whatIsDraggedOverFromResult(result);\n            const combineWith = getCombineWithFromResult(result);\n            const duration = state.dropDuration;\n            const dropping = {\n                duration,\n                curve: curves.drop,\n                moveTo: state.newHomeClientOffset,\n                opacity: combineWith ? combine.opacity.drop : null,\n                scale: combineWith ? combine.scale.drop : null\n            };\n            return {\n                mapped: {\n                    type: \"DRAGGING\",\n                    offset: state.newHomeClientOffset,\n                    dimension,\n                    dropping,\n                    draggingOver,\n                    combineWith,\n                    mode,\n                    forceShouldAnimate: null,\n                    snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, dropping)\n                }\n            };\n        }\n        return null;\n    };\n    return selector;\n}\nfunction getSecondarySnapshot(combineTargetFor = null) {\n    return {\n        isDragging: false,\n        isDropAnimating: false,\n        isClone: false,\n        dropAnimation: null,\n        mode: null,\n        draggingOver: null,\n        combineTargetFor,\n        combineWith: null\n    };\n}\nconst atRest = {\n    mapped: {\n        type: \"SECONDARY\",\n        offset: origin,\n        combineTargetFor: null,\n        shouldAnimateDisplacement: true,\n        snapshot: getSecondarySnapshot(null)\n    }\n};\nfunction getSecondarySelector() {\n    const memoizedOffset = memoizeOne((x, y)=>({\n            x,\n            y\n        }));\n    const getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);\n    const getMemoizedProps = memoizeOne((offset, combineTargetFor = null, shouldAnimateDisplacement)=>({\n            mapped: {\n                type: \"SECONDARY\",\n                offset,\n                combineTargetFor,\n                shouldAnimateDisplacement,\n                snapshot: getMemoizedSnapshot(combineTargetFor)\n            }\n        }));\n    const getFallback = (combineTargetFor)=>{\n        return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;\n    };\n    const getProps = (ownId, draggingId, impact, afterCritical)=>{\n        const visualDisplacement = impact.displaced.visible[ownId];\n        const isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);\n        const combine = tryGetCombine(impact);\n        const combineTargetFor = combine && combine.draggableId === ownId ? draggingId : null;\n        if (!visualDisplacement) {\n            if (!isAfterCriticalInVirtualList) {\n                return getFallback(combineTargetFor);\n            }\n            if (impact.displaced.invisible[ownId]) {\n                return null;\n            }\n            const change = negate(afterCritical.displacedBy.point);\n            const offset = memoizedOffset(change.x, change.y);\n            return getMemoizedProps(offset, combineTargetFor, true);\n        }\n        if (isAfterCriticalInVirtualList) {\n            return getFallback(combineTargetFor);\n        }\n        const displaceBy = impact.displacedBy.point;\n        const offset = memoizedOffset(displaceBy.x, displaceBy.y);\n        return getMemoizedProps(offset, combineTargetFor, visualDisplacement.shouldAnimate);\n    };\n    const selector = (state, ownProps)=>{\n        if (isDragging(state)) {\n            if (state.critical.draggable.id === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (completed.result.draggableId === ownProps.draggableId) {\n                return null;\n            }\n            return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);\n        }\n        return null;\n    };\n    return selector;\n}\nconst makeMapStateToProps$1 = ()=>{\n    const draggingSelector = getDraggableSelector();\n    const secondarySelector = getSecondarySelector();\n    const selector = (state, ownProps)=>draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;\n    return selector;\n};\nconst mapDispatchToProps$1 = {\n    dropAnimationFinished: dropAnimationFinished\n};\nconst ConnectedDraggable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps$1, mapDispatchToProps$1, null, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Draggable);\nfunction PrivateDraggable(props) {\n    const droppableContext = useRequiredContext(DroppableContext);\n    const isUsingCloneFor = droppableContext.isUsingCloneFor;\n    if (isUsingCloneFor === props.draggableId && !props.isClone) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConnectedDraggable, props);\n}\nfunction PublicDraggable(props) {\n    const isEnabled = typeof props.isDragDisabled === \"boolean\" ? !props.isDragDisabled : true;\n    const canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);\n    const shouldRespectForcePress = Boolean(props.shouldRespectForcePress);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({}, props, {\n        isClone: false,\n        isEnabled: isEnabled,\n        canDragInteractiveElements: canDragInteractiveElements,\n        shouldRespectForcePress: shouldRespectForcePress\n    }));\n}\nconst isEqual = (base)=>(value)=>base === value;\nconst isScroll = isEqual(\"scroll\");\nconst isAuto = isEqual(\"auto\");\nconst isVisible = isEqual(\"visible\");\nconst isEither = (overflow, fn)=>fn(overflow.overflowX) || fn(overflow.overflowY);\nconst isBoth = (overflow, fn)=>fn(overflow.overflowX) && fn(overflow.overflowY);\nconst isElementScrollable = (el)=>{\n    const style = window.getComputedStyle(el);\n    const overflow = {\n        overflowX: style.overflowX,\n        overflowY: style.overflowY\n    };\n    return isEither(overflow, isScroll) || isEither(overflow, isAuto);\n};\nconst isBodyScrollable = ()=>{\n    if (false) {}\n    const body = getBodyElement();\n    const html = document.documentElement;\n    !html ?  true ? invariant() : 0 : void 0;\n    if (!isElementScrollable(body)) {\n        return false;\n    }\n    const htmlStyle = window.getComputedStyle(html);\n    const htmlOverflow = {\n        overflowX: htmlStyle.overflowX,\n        overflowY: htmlStyle.overflowY\n    };\n    if (isBoth(htmlOverflow, isVisible)) {\n        return false;\n    }\n     true ? warning(`\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/hello-pangea/dnd/blob/main/docs/guides/how-we-detect-scroll-containers.md\n  `) : 0;\n    return false;\n};\nconst getClosestScrollable = (el)=>{\n    if (el == null) {\n        return null;\n    }\n    if (el === document.body) {\n        return isBodyScrollable() ? el : null;\n    }\n    if (el === document.documentElement) {\n        return null;\n    }\n    if (!isElementScrollable(el)) {\n        return getClosestScrollable(el.parentElement);\n    }\n    return el;\n};\nvar checkForNestedScrollContainers = (scrollable)=>{\n    if (!scrollable) {\n        return;\n    }\n    const anotherScrollParent = getClosestScrollable(scrollable.parentElement);\n    if (!anotherScrollParent) {\n        return;\n    }\n     true ? warning(`\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  `) : 0;\n};\nvar getScroll = (el)=>({\n        x: el.scrollLeft,\n        y: el.scrollTop\n    });\nconst getIsFixed = (el)=>{\n    if (!el) {\n        return false;\n    }\n    const style = window.getComputedStyle(el);\n    if (style.position === \"fixed\") {\n        return true;\n    }\n    return getIsFixed(el.parentElement);\n};\nvar getEnv = (start)=>{\n    const closestScrollable = getClosestScrollable(start);\n    const isFixedOnPage = getIsFixed(start);\n    return {\n        closestScrollable,\n        isFixedOnPage\n    };\n};\nvar getDroppableDimension = ({ descriptor, isEnabled, isCombineEnabled, isFixedOnPage, direction, client, page, closest })=>{\n    const frame = (()=>{\n        if (!closest) {\n            return null;\n        }\n        const { scrollSize, client: frameClient } = closest;\n        const maxScroll = getMaxScroll({\n            scrollHeight: scrollSize.scrollHeight,\n            scrollWidth: scrollSize.scrollWidth,\n            height: frameClient.paddingBox.height,\n            width: frameClient.paddingBox.width\n        });\n        return {\n            pageMarginBox: closest.page.marginBox,\n            frameClient,\n            scrollSize,\n            shouldClipSubject: closest.shouldClipSubject,\n            scroll: {\n                initial: closest.scroll,\n                current: closest.scroll,\n                max: maxScroll,\n                diff: {\n                    value: origin,\n                    displacement: origin\n                }\n            }\n        };\n    })();\n    const axis = direction === \"vertical\" ? vertical : horizontal;\n    const subject = getSubject({\n        page,\n        withPlaceholder: null,\n        axis,\n        frame\n    });\n    const dimension = {\n        descriptor,\n        isCombineEnabled,\n        isFixedOnPage,\n        axis,\n        isEnabled,\n        client,\n        page,\n        frame,\n        subject\n    };\n    return dimension;\n};\nconst getClient = (targetRef, closestScrollable)=>{\n    const base = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(targetRef);\n    if (!closestScrollable) {\n        return base;\n    }\n    if (targetRef !== closestScrollable) {\n        return base;\n    }\n    const top = base.paddingBox.top - closestScrollable.scrollTop;\n    const left = base.paddingBox.left - closestScrollable.scrollLeft;\n    const bottom = top + closestScrollable.scrollHeight;\n    const right = left + closestScrollable.scrollWidth;\n    const paddingBox = {\n        top,\n        right,\n        bottom,\n        left\n    };\n    const borderBox = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.expand)(paddingBox, base.border);\n    const client = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.createBox)({\n        borderBox,\n        margin: base.margin,\n        border: base.border,\n        padding: base.padding\n    });\n    return client;\n};\nvar getDimension = ({ ref, descriptor, env, windowScroll, direction, isDropDisabled, isCombineEnabled, shouldClipSubject })=>{\n    const closestScrollable = env.closestScrollable;\n    const client = getClient(ref, closestScrollable);\n    const page = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(client, windowScroll);\n    const closest = (()=>{\n        if (!closestScrollable) {\n            return null;\n        }\n        const frameClient = (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.getBox)(closestScrollable);\n        const scrollSize = {\n            scrollHeight: closestScrollable.scrollHeight,\n            scrollWidth: closestScrollable.scrollWidth\n        };\n        return {\n            client: frameClient,\n            page: (0,css_box_model__WEBPACK_IMPORTED_MODULE_3__.withScroll)(frameClient, windowScroll),\n            scroll: getScroll(closestScrollable),\n            scrollSize,\n            shouldClipSubject\n        };\n    })();\n    const dimension = getDroppableDimension({\n        descriptor,\n        isEnabled: !isDropDisabled,\n        isCombineEnabled,\n        isFixedOnPage: env.isFixedOnPage,\n        direction,\n        client,\n        page,\n        closest\n    });\n    return dimension;\n};\nconst immediate = {\n    passive: false\n};\nconst delayed = {\n    passive: true\n};\nvar getListenerOptions = (options)=>options.shouldPublishImmediately ? immediate : delayed;\nconst getClosestScrollableFromDrag = (dragging)=>dragging && dragging.env.closestScrollable || null;\nfunction useDroppablePublisher(args) {\n    const whileDraggingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const appContext = useRequiredContext(AppContext);\n    const uniqueId = useUniqueId(\"droppable\");\n    const { registry, marshal } = appContext;\n    const previousRef = usePrevious(args);\n    const descriptor = useMemo(()=>({\n            id: args.droppableId,\n            type: args.type,\n            mode: args.mode\n        }), [\n        args.droppableId,\n        args.mode,\n        args.type\n    ]);\n    const publishedDescriptorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(descriptor);\n    const memoizedUpdateScroll = useMemo(()=>memoizeOne((x, y)=>{\n            !whileDraggingRef.current ?  true ? invariant(false, \"Can only update scroll when dragging\") : 0 : void 0;\n            const scroll = {\n                x,\n                y\n            };\n            marshal.updateDroppableScroll(descriptor.id, scroll);\n        }), [\n        descriptor.id,\n        marshal\n    ]);\n    const getClosestScroll = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        if (!dragging || !dragging.env.closestScrollable) {\n            return origin;\n        }\n        return getScroll(dragging.env.closestScrollable);\n    }, []);\n    const updateScroll = useCallback(()=>{\n        const scroll = getClosestScroll();\n        memoizedUpdateScroll(scroll.x, scroll.y);\n    }, [\n        getClosestScroll,\n        memoizedUpdateScroll\n    ]);\n    const scheduleScrollUpdate = useMemo(()=>(0,raf_schd__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(updateScroll), [\n        updateScroll\n    ]);\n    const onClosestScroll = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Could not find scroll options while scrolling\") : 0 : void 0;\n        const options = dragging.scrollOptions;\n        if (options.shouldPublishImmediately) {\n            updateScroll();\n            return;\n        }\n        scheduleScrollUpdate();\n    }, [\n        scheduleScrollUpdate,\n        updateScroll\n    ]);\n    const getDimensionAndWatchScroll = useCallback((windowScroll, options)=>{\n        !!whileDraggingRef.current ?  true ? invariant(false, \"Cannot collect a droppable while a drag is occurring\") : 0 : void 0;\n        const previous = previousRef.current;\n        const ref = previous.getDroppableRef();\n        !ref ?  true ? invariant(false, \"Cannot collect without a droppable ref\") : 0 : void 0;\n        const env = getEnv(ref);\n        const dragging = {\n            ref,\n            descriptor,\n            env,\n            scrollOptions: options\n        };\n        whileDraggingRef.current = dragging;\n        const dimension = getDimension({\n            ref,\n            descriptor,\n            env,\n            windowScroll,\n            direction: previous.direction,\n            isDropDisabled: previous.isDropDisabled,\n            isCombineEnabled: previous.isCombineEnabled,\n            shouldClipSubject: !previous.ignoreContainerClipping\n        });\n        const scrollable = env.closestScrollable;\n        if (scrollable) {\n            scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);\n            scrollable.addEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n            if (true) {\n                checkForNestedScrollContainers(scrollable);\n            }\n        }\n        return dimension;\n    }, [\n        appContext.contextId,\n        descriptor,\n        onClosestScroll,\n        previousRef\n    ]);\n    const getScrollWhileDragging = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !(dragging && closest) ?  true ? invariant(false, \"Can only recollect Droppable client for Droppables that have a scroll container\") : 0 : void 0;\n        return getScroll(closest);\n    }, []);\n    const dragStopped = useCallback(()=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot stop drag when no active drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        whileDraggingRef.current = null;\n        if (!closest) {\n            return;\n        }\n        scheduleScrollUpdate.cancel();\n        closest.removeAttribute(scrollContainer.contextId);\n        closest.removeEventListener(\"scroll\", onClosestScroll, getListenerOptions(dragging.scrollOptions));\n    }, [\n        onClosestScroll,\n        scheduleScrollUpdate\n    ]);\n    const scroll = useCallback((change)=>{\n        const dragging = whileDraggingRef.current;\n        !dragging ?  true ? invariant(false, \"Cannot scroll when there is no drag\") : 0 : void 0;\n        const closest = getClosestScrollableFromDrag(dragging);\n        !closest ?  true ? invariant(false, \"Cannot scroll a droppable with no closest scrollable\") : 0 : void 0;\n        closest.scrollTop += change.y;\n        closest.scrollLeft += change.x;\n    }, []);\n    const callbacks = useMemo(()=>{\n        return {\n            getDimensionAndWatchScroll,\n            getScrollWhileDragging,\n            dragStopped,\n            scroll\n        };\n    }, [\n        dragStopped,\n        getDimensionAndWatchScroll,\n        getScrollWhileDragging,\n        scroll\n    ]);\n    const entry = useMemo(()=>({\n            uniqueId,\n            descriptor,\n            callbacks\n        }), [\n        callbacks,\n        descriptor,\n        uniqueId\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        publishedDescriptorRef.current = entry.descriptor;\n        registry.droppable.register(entry);\n        return ()=>{\n            if (whileDraggingRef.current) {\n                 true ? warning(\"Unsupported: changing the droppableId or type of a Droppable during a drag\") : 0;\n                dragStopped();\n            }\n            registry.droppable.unregister(entry);\n        };\n    }, [\n        callbacks,\n        descriptor,\n        dragStopped,\n        entry,\n        marshal,\n        registry.droppable\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);\n    }, [\n        args.isDropDisabled,\n        marshal\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        if (!whileDraggingRef.current) {\n            return;\n        }\n        marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);\n    }, [\n        args.isCombineEnabled,\n        marshal\n    ]);\n}\nfunction noop() {}\nconst empty = {\n    width: 0,\n    height: 0,\n    margin: noSpacing\n};\nconst getSize = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    if (isAnimatingOpenOnMount) {\n        return empty;\n    }\n    if (animate === \"close\") {\n        return empty;\n    }\n    return {\n        height: placeholder.client.borderBox.height,\n        width: placeholder.client.borderBox.width,\n        margin: placeholder.client.margin\n    };\n};\nconst getStyle = ({ isAnimatingOpenOnMount, placeholder, animate })=>{\n    const size = getSize({\n        isAnimatingOpenOnMount,\n        placeholder,\n        animate\n    });\n    return {\n        display: placeholder.display,\n        boxSizing: \"border-box\",\n        width: size.width,\n        height: size.height,\n        marginTop: size.margin.top,\n        marginRight: size.margin.right,\n        marginBottom: size.margin.bottom,\n        marginLeft: size.margin.left,\n        flexShrink: \"0\",\n        flexGrow: \"0\",\n        pointerEvents: \"none\",\n        transition: animate !== \"none\" ? transitions.placeholder : null\n    };\n};\nconst Placeholder = (props)=>{\n    const animateOpenTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const tryClearAnimateOpenTimer = useCallback(()=>{\n        if (!animateOpenTimerRef.current) {\n            return;\n        }\n        clearTimeout(animateOpenTimerRef.current);\n        animateOpenTimerRef.current = null;\n    }, []);\n    const { animate, onTransitionEnd, onClose, contextId } = props;\n    const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.animate === \"open\");\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!isAnimatingOpenOnMount) {\n            return noop;\n        }\n        if (animate !== \"open\") {\n            tryClearAnimateOpenTimer();\n            setIsAnimatingOpenOnMount(false);\n            return noop;\n        }\n        if (animateOpenTimerRef.current) {\n            return noop;\n        }\n        animateOpenTimerRef.current = setTimeout(()=>{\n            animateOpenTimerRef.current = null;\n            setIsAnimatingOpenOnMount(false);\n        });\n        return tryClearAnimateOpenTimer;\n    }, [\n        animate,\n        isAnimatingOpenOnMount,\n        tryClearAnimateOpenTimer\n    ]);\n    const onSizeChangeEnd = useCallback((event)=>{\n        if (event.propertyName !== \"height\") {\n            return;\n        }\n        onTransitionEnd();\n        if (animate === \"close\") {\n            onClose();\n        }\n    }, [\n        animate,\n        onClose,\n        onTransitionEnd\n    ]);\n    const style = getStyle({\n        isAnimatingOpenOnMount,\n        animate: props.animate,\n        placeholder: props.placeholder\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(props.placeholder.tagName, {\n        style,\n        \"data-rfd-placeholder-context-id\": contextId,\n        onTransitionEnd: onSizeChangeEnd,\n        ref: props.innerRef\n    });\n};\nvar Placeholder$1 = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo(Placeholder);\nfunction isBoolean(value) {\n    return typeof value === \"boolean\";\n}\nfunction runChecks(args, checks) {\n    checks.forEach((check)=>check(args));\n}\nconst shared = [\n    function required({ props }) {\n        !props.droppableId ?  true ? invariant(false, \"A Droppable requires a droppableId prop\") : 0 : void 0;\n        !(typeof props.droppableId === \"string\") ?  true ? invariant(false, `A Droppable requires a [string] droppableId. Provided: [${typeof props.droppableId}]`) : 0 : void 0;\n    },\n    function boolean({ props }) {\n        !isBoolean(props.isDropDisabled) ?  true ? invariant(false, \"isDropDisabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.isCombineEnabled) ?  true ? invariant(false, \"isCombineEnabled must be a boolean\") : 0 : void 0;\n        !isBoolean(props.ignoreContainerClipping) ?  true ? invariant(false, \"ignoreContainerClipping must be a boolean\") : 0 : void 0;\n    },\n    function ref({ getDroppableRef }) {\n        checkIsValidInnerRef(getDroppableRef());\n    }\n];\nconst standard = [\n    function placeholder({ props, getPlaceholderRef }) {\n        if (!props.placeholder) {\n            return;\n        }\n        const ref = getPlaceholderRef();\n        if (ref) {\n            return;\n        }\n         true ? warning(`\n      Droppable setup issue [droppableId: \"${props.droppableId}\"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/hello-pangea/dnd/blob/main/docs/api/droppable.md\n    `) : 0;\n    }\n];\nconst virtual = [\n    function hasClone({ props }) {\n        !props.renderClone ?  true ? invariant(false, \"Must provide a clone render function (renderClone) for virtual lists\") : 0 : void 0;\n    },\n    function hasNoPlaceholder({ getPlaceholderRef }) {\n        !!getPlaceholderRef() ?  true ? invariant(false, \"Expected virtual list to not have a placeholder\") : 0 : void 0;\n    }\n];\nfunction useValidation(args) {\n    useDevSetupWarning(()=>{\n        runChecks(args, shared);\n        if (args.props.mode === \"standard\") {\n            runChecks(args, standard);\n        }\n        if (args.props.mode === \"virtual\") {\n            runChecks(args, virtual);\n        }\n    });\n}\nclass AnimateInOut extends (react__WEBPACK_IMPORTED_MODULE_0___default().PureComponent) {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            isVisible: Boolean(this.props.on),\n            data: this.props.on,\n            animate: this.props.shouldAnimate && this.props.on ? \"open\" : \"none\"\n        };\n        this.onClose = ()=>{\n            if (this.state.animate !== \"close\") {\n                return;\n            }\n            this.setState({\n                isVisible: false\n            });\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (!props.shouldAnimate) {\n            return {\n                isVisible: Boolean(props.on),\n                data: props.on,\n                animate: \"none\"\n            };\n        }\n        if (props.on) {\n            return {\n                isVisible: true,\n                data: props.on,\n                animate: \"open\"\n            };\n        }\n        if (state.isVisible) {\n            return {\n                isVisible: true,\n                data: state.data,\n                animate: \"close\"\n            };\n        }\n        return {\n            isVisible: false,\n            animate: \"close\",\n            data: null\n        };\n    }\n    render() {\n        if (!this.state.isVisible) {\n            return null;\n        }\n        const provided = {\n            onClose: this.onClose,\n            data: this.state.data,\n            animate: this.state.animate\n        };\n        return this.props.children(provided);\n    }\n}\nconst Droppable = (props)=>{\n    const appContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AppContext);\n    !appContext ?  true ? invariant(false, \"Could not find app context\") : 0 : void 0;\n    const { contextId, isMovementAllowed } = appContext;\n    const droppableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { children, droppableId, type, mode, direction, ignoreContainerClipping, isDropDisabled, isCombineEnabled, snapshot, useClone, updateViewportMaxScroll, getContainerForClone } = props;\n    const getDroppableRef = useCallback(()=>droppableRef.current, []);\n    const setDroppableRef = useCallback((value = null)=>{\n        droppableRef.current = value;\n    }, []);\n    const getPlaceholderRef = useCallback(()=>placeholderRef.current, []);\n    const setPlaceholderRef = useCallback((value = null)=>{\n        placeholderRef.current = value;\n    }, []);\n    useValidation({\n        props,\n        getDroppableRef,\n        getPlaceholderRef\n    });\n    const onPlaceholderTransitionEnd = useCallback(()=>{\n        if (isMovementAllowed()) {\n            updateViewportMaxScroll({\n                maxScroll: getMaxWindowScroll()\n            });\n        }\n    }, [\n        isMovementAllowed,\n        updateViewportMaxScroll\n    ]);\n    useDroppablePublisher({\n        droppableId,\n        type,\n        mode,\n        direction,\n        isDropDisabled,\n        isCombineEnabled,\n        ignoreContainerClipping,\n        getDroppableRef\n    });\n    const placeholder = useMemo(()=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimateInOut, {\n            on: props.placeholder,\n            shouldAnimate: props.shouldAnimatePlaceholder\n        }, ({ onClose, data, animate })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Placeholder$1, {\n                placeholder: data,\n                onClose: onClose,\n                innerRef: setPlaceholderRef,\n                animate: animate,\n                contextId: contextId,\n                onTransitionEnd: onPlaceholderTransitionEnd\n            })), [\n        contextId,\n        onPlaceholderTransitionEnd,\n        props.placeholder,\n        props.shouldAnimatePlaceholder,\n        setPlaceholderRef\n    ]);\n    const provided = useMemo(()=>({\n            innerRef: setDroppableRef,\n            placeholder,\n            droppableProps: {\n                \"data-rfd-droppable-id\": droppableId,\n                \"data-rfd-droppable-context-id\": contextId\n            }\n        }), [\n        contextId,\n        droppableId,\n        placeholder,\n        setDroppableRef\n    ]);\n    const isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;\n    const droppableContext = useMemo(()=>({\n            droppableId,\n            type,\n            isUsingCloneFor\n        }), [\n        droppableId,\n        isUsingCloneFor,\n        type\n    ]);\n    function getClone() {\n        if (!useClone) {\n            return null;\n        }\n        const { dragging, render } = useClone;\n        const node = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PrivateDraggable, {\n            draggableId: dragging.draggableId,\n            index: dragging.source.index,\n            isClone: true,\n            isEnabled: true,\n            shouldRespectForcePress: false,\n            canDragInteractiveElements: true\n        }, (draggableProvided, draggableSnapshot)=>render(draggableProvided, draggableSnapshot, dragging));\n        return /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1___default().createPortal(node, getContainerForClone());\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DroppableContext.Provider, {\n        value: droppableContext\n    }, children(provided, snapshot), getClone());\n};\nfunction getBody() {\n    !document.body ?  true ? invariant(false, \"document.body is not ready\") : 0 : void 0;\n    return document.body;\n}\nconst defaultProps = {\n    mode: \"standard\",\n    type: \"DEFAULT\",\n    direction: \"vertical\",\n    isDropDisabled: false,\n    isCombineEnabled: false,\n    ignoreContainerClipping: false,\n    renderClone: null,\n    getContainerForClone: getBody\n};\nconst attachDefaultPropsToOwnProps = (ownProps)=>{\n    let mergedProps = {\n        ...ownProps\n    };\n    let defaultPropKey;\n    for(defaultPropKey in defaultProps){\n        if (ownProps[defaultPropKey] === undefined) {\n            mergedProps = {\n                ...mergedProps,\n                [defaultPropKey]: defaultProps[defaultPropKey]\n            };\n        }\n    }\n    return mergedProps;\n};\nconst isMatchingType = (type, critical)=>type === critical.droppable.type;\nconst getDraggable = (critical, dimensions)=>dimensions.draggables[critical.draggable.id];\nconst makeMapStateToProps = ()=>{\n    const idleWithAnimation = {\n        placeholder: null,\n        shouldAnimatePlaceholder: true,\n        snapshot: {\n            isDraggingOver: false,\n            draggingOverWith: null,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: false\n        },\n        useClone: null\n    };\n    const idleWithoutAnimation = {\n        ...idleWithAnimation,\n        shouldAnimatePlaceholder: false\n    };\n    const getDraggableRubric = memoizeOne((descriptor)=>({\n            draggableId: descriptor.id,\n            type: descriptor.type,\n            source: {\n                index: descriptor.index,\n                droppableId: descriptor.droppableId\n            }\n        }));\n    const getMapProps = memoizeOne((id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone)=>{\n        const draggableId = dragging.descriptor.id;\n        const isHome = dragging.descriptor.droppableId === id;\n        if (isHome) {\n            const useClone = renderClone ? {\n                render: renderClone,\n                dragging: getDraggableRubric(dragging.descriptor)\n            } : null;\n            const snapshot = {\n                isDraggingOver: isDraggingOverForConsumer,\n                draggingOverWith: isDraggingOverForConsumer ? draggableId : null,\n                draggingFromThisWith: draggableId,\n                isUsingPlaceholder: true\n            };\n            return {\n                placeholder: dragging.placeholder,\n                shouldAnimatePlaceholder: false,\n                snapshot,\n                useClone\n            };\n        }\n        if (!isEnabled) {\n            return idleWithoutAnimation;\n        }\n        if (!isDraggingOverForImpact) {\n            return idleWithAnimation;\n        }\n        const snapshot = {\n            isDraggingOver: isDraggingOverForConsumer,\n            draggingOverWith: draggableId,\n            draggingFromThisWith: null,\n            isUsingPlaceholder: true\n        };\n        return {\n            placeholder: dragging.placeholder,\n            shouldAnimatePlaceholder: true,\n            snapshot,\n            useClone: null\n        };\n    });\n    const selector = (state, ownProps)=>{\n        const ownPropsWithDefaultProps = attachDefaultPropsToOwnProps(ownProps);\n        const id = ownPropsWithDefaultProps.droppableId;\n        const type = ownPropsWithDefaultProps.type;\n        const isEnabled = !ownPropsWithDefaultProps.isDropDisabled;\n        const renderClone = ownPropsWithDefaultProps.renderClone;\n        if (isDragging(state)) {\n            const critical = state.critical;\n            if (!isMatchingType(type, critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(critical, state.dimensions);\n            const isDraggingOver = whatIsDraggedOver(state.impact) === id;\n            return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);\n        }\n        if (state.phase === \"DROP_ANIMATING\") {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const dragging = getDraggable(completed.critical, state.dimensions);\n            return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, dragging, renderClone);\n        }\n        if (state.phase === \"IDLE\" && state.completed && !state.shouldFlush) {\n            const completed = state.completed;\n            if (!isMatchingType(type, completed.critical)) {\n                return idleWithoutAnimation;\n            }\n            const wasOver = whatIsDraggedOver(completed.impact) === id;\n            const wasCombining = Boolean(completed.impact.at && completed.impact.at.type === \"COMBINE\");\n            const isHome = completed.critical.droppable.id === id;\n            if (wasOver) {\n                return wasCombining ? idleWithAnimation : idleWithoutAnimation;\n            }\n            if (isHome) {\n                return idleWithAnimation;\n            }\n            return idleWithoutAnimation;\n        }\n        return idleWithoutAnimation;\n    };\n    return selector;\n};\nconst mapDispatchToProps = {\n    updateViewportMaxScroll: updateViewportMaxScroll\n};\nconst ConnectedDroppable = (0,react_redux__WEBPACK_IMPORTED_MODULE_6__.connect)(makeMapStateToProps, mapDispatchToProps, (stateProps, dispatchProps, ownProps)=>{\n    return {\n        ...attachDefaultPropsToOwnProps(ownProps),\n        ...stateProps,\n        ...dispatchProps\n    };\n}, {\n    context: StoreContext,\n    areStatePropsEqual: isStrictEqual\n})(Droppable);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RjtBQUN4QztBQUNtRDtBQUNuRDtBQUNxRDtBQUN0RTtBQUMyQjtBQUUxRCxNQUFNd0IsaUJBQWlCQyxrQkFBeUI7QUFDaEQsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxVQUFVQyxDQUFBQSxRQUFTQSxNQUFNQyxPQUFPLENBQUNKLGVBQWUsS0FBS0ksT0FBTyxDQUFDSCxxQkFBcUIsSUFBSUksSUFBSTtBQUNoRyxNQUFNQyxnQkFBZ0JDLENBQUFBLFVBQVdMLFFBQVEsQ0FBQzs7O0lBR3RDLEVBQUVBLFFBQVFLLFNBQVM7OztBQUd2QixDQUFDO0FBQ0QsTUFBTUMsc0JBQXNCRCxDQUFBQSxVQUFXO1FBQUNELGNBQWNDO1FBQVU7UUFBd0Q7UUFBb0I7S0FBa0I7QUFDOUosTUFBTUUsaUJBQWlCO0FBQ3ZCLFNBQVNDLElBQUlDLElBQUksRUFBRUosT0FBTztJQUN4QixJQUFJVCxnQkFBZ0I7UUFDbEI7SUFDRjtJQUNBLElBQUksS0FBdUQsRUFBRSxFQUU1RDtJQUNEZSxPQUFPLENBQUNGLEtBQUssSUFBSUgsb0JBQW9CRDtBQUN2QztBQUNBLE1BQU1PLFVBQVVKLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBQy9CLE1BQU1DLFFBQVFOLElBQUlLLElBQUksQ0FBQyxNQUFNO0FBRTdCLFNBQVNFLFVBQVU7QUFFbkIsU0FBU0MsV0FBV0MsTUFBTSxFQUFFQyxXQUFXO0lBQ3JDLE9BQU87UUFDTCxHQUFHRCxNQUFNO1FBQ1QsR0FBR0MsV0FBVztJQUNoQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0MsRUFBRSxFQUFFQyxRQUFRLEVBQUVDLGFBQWE7SUFDN0MsTUFBTUMsYUFBYUYsU0FBU0csR0FBRyxDQUFDQyxDQUFBQTtRQUM5QixNQUFNQyxVQUFVVixXQUFXTSxlQUFlRyxRQUFR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MEIsTUFBTVUsS0FBSyxLQUFLLFVBQVVWLE1BQU1pRyxTQUFTLElBQUksQ0FBQ2pHLE1BQU1rRyxXQUFXLEVBQUU7WUFDbkUsTUFBTUQsWUFBWWpHLE1BQU1pRyxTQUFTO1lBQ2pDLElBQUksQ0FBQzZ2QixlQUFldHVDLE1BQU15ZSxVQUFVNUYsUUFBUSxHQUFHO2dCQUM3QyxPQUFPaTJCO1lBQ1Q7WUFDQSxNQUFNL3dCLFVBQVUxRixrQkFBa0JvRyxVQUFVOVMsTUFBTSxNQUFNekg7WUFDeEQsTUFBTW1yQyxlQUFlcnBDLFFBQVF5WSxVQUFVOVMsTUFBTSxDQUFDQyxFQUFFLElBQUk2UyxVQUFVOVMsTUFBTSxDQUFDQyxFQUFFLENBQUM1TCxJQUFJLEtBQUs7WUFDakYsTUFBTW12QyxTQUFTMXdCLFVBQVU1RixRQUFRLENBQUNsUCxTQUFTLENBQUN6RixFQUFFLEtBQUtBO1lBQ25ELElBQUk2WixTQUFTO2dCQUNYLE9BQU9zeEIsZUFBZVosb0JBQW9CSztZQUM1QztZQUNBLElBQUlLLFFBQVE7Z0JBQ1YsT0FBT1Y7WUFDVDtZQUNBLE9BQU9LO1FBQ1Q7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsT0FBTzljO0FBQ1Q7QUFDQSxNQUFNc2QscUJBQXFCO0lBQ3pCcnZCLHlCQUF5QkE7QUFDM0I7QUFDQSxNQUFNc3ZCLHFCQUFxQjl3QyxvREFBT0EsQ0FBQyt2QyxxQkFBcUJjLG9CQUFvQixDQUFDRSxZQUFZQyxlQUFlNUk7SUFDdEcsT0FBTztRQUNMLEdBQUdzSCw2QkFBNkJ0SCxTQUFTO1FBQ3pDLEdBQUcySSxVQUFVO1FBQ2IsR0FBR0MsYUFBYTtJQUNsQjtBQUNGLEdBQUc7SUFDRGhlLFNBQVMrRTtJQUNUcVIsb0JBQW9CM0I7QUFDdEIsR0FBR2dIO0FBRTBJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHluYW1pYy1kYXRhLXRhYmxlLW1hbmFnZXIvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvZGlzdC9kbmQuZXNtLmpzP2M5OTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NLCB7IGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZSQxLCBjb21wb3NlLCBhcHBseU1pZGRsZXdhcmUsIGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IFByb3ZpZGVyLCBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHsgZ2V0UmVjdCwgZXhwYW5kLCBvZmZzZXQsIHdpdGhTY3JvbGwsIGNhbGN1bGF0ZUJveCwgZ2V0Qm94LCBjcmVhdGVCb3ggfSBmcm9tICdjc3MtYm94LW1vZGVsJztcbmltcG9ydCByYWZTY2hkIGZyb20gJ3JhZi1zY2hkJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcblxuY29uc3QgaXNQcm9kdWN0aW9uJDEgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuY29uc3Qgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG5jb25zdCBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuY29uc3QgY2xlYW4kMiA9IHZhbHVlID0+IHZhbHVlLnJlcGxhY2Uoc3BhY2VzQW5kVGFicywgJyAnKS5yZXBsYWNlKGxpbmVTdGFydFdpdGhTcGFjZXMsICcnKS50cmltKCk7XG5jb25zdCBnZXREZXZNZXNzYWdlID0gbWVzc2FnZSA9PiBjbGVhbiQyKGBcbiAgJWNAaGVsbG8tcGFuZ2VhL2RuZFxuXG4gICVjJHtjbGVhbiQyKG1lc3NhZ2UpfVxuXG4gICVj8J+Rt+KAjSBUaGlzIGlzIGEgZGV2ZWxvcG1lbnQgb25seSBtZXNzYWdlLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXG5gKTtcbmNvbnN0IGdldEZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlID0+IFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4yZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsICdsaW5lLWhlaWdodDogMS41JywgJ2NvbG9yOiAjNzIzODc0OyddO1xuY29uc3QgaXNEaXNhYmxlZEZsYWcgPSAnX19AaGVsbG8tcGFuZ2VhL2RuZC1kaXNhYmxlLWRldi13YXJuaW5ncyc7XG5mdW5jdGlvbiBsb2codHlwZSwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uJDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1tpc0Rpc2FibGVkRmxhZ10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZVt0eXBlXSguLi5nZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpKTtcbn1cbmNvbnN0IHdhcm5pbmcgPSBsb2cuYmluZChudWxsLCAnd2FybicpO1xuY29uc3QgZXJyb3IgPSBsb2cuYmluZChudWxsLCAnZXJyb3InKTtcblxuZnVuY3Rpb24gbm9vcCQyKCkge31cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhzaGFyZWQsIGZyb21CaW5kaW5nKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2hhcmVkLFxuICAgIC4uLmZyb21CaW5kaW5nXG4gIH07XG59XG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsLCBiaW5kaW5ncywgc2hhcmVkT3B0aW9ucykge1xuICBjb25zdCB1bmJpbmRpbmdzID0gYmluZGluZ3MubWFwKGJpbmRpbmcgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIGJpbmRpbmcub3B0aW9ucyk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmV2ZW50TmFtZSwgYmluZGluZy5mbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoYmluZGluZy5ldmVudE5hbWUsIGJpbmRpbmcuZm4sIG9wdGlvbnMpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gdW5iaW5kQWxsKCkge1xuICAgIHVuYmluZGluZ3MuZm9yRWFjaCh1bmJpbmQgPT4ge1xuICAgICAgdW5iaW5kKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5jb25zdCBwcmVmaXgkMSA9ICdJbnZhcmlhbnQgZmFpbGVkJztcbmNsYXNzIFJiZEludmFyaWFudCBleHRlbmRzIEVycm9yIHt9XG5SYmRJbnZhcmlhbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChwcmVmaXgkMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJiZEludmFyaWFudChgJHtwcmVmaXgkMX06ICR7bWVzc2FnZSB8fCAnJ31gKTtcbiAgfVxufVxuXG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnVuYmluZCA9IG5vb3AkMjtcbiAgICB0aGlzLm9uV2luZG93RXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmdldENhbGxiYWNrcygpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnRyeUFib3J0KCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbiBlcnJvciB3YXMgY2F1Z2h0IGJ5IG91ciB3aW5kb3cgJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB3aGlsZSBhIGRyYWcgd2FzIG9jY3VycmluZy5cbiAgICAgICAgVGhlIGFjdGl2ZSBkcmFnIGhhcyBiZWVuIGFib3J0ZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yO1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRDYWxsYmFja3MgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgQXBwQ2FsbGJhY2tzIGluIDxFcnJvckJvdW5kYXJ5Lz4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcztcbiAgICB9O1xuICAgIHRoaXMuc2V0Q2FsbGJhY2tzID0gY2FsbGJhY2tzID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW3tcbiAgICAgIGV2ZW50TmFtZTogJ2Vycm9yJyxcbiAgICAgIGZuOiB0aGlzLm9uV2luZG93RXJyb3JcbiAgICB9XSk7XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFJiZEludmFyaWFudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVuYmluZCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLnNldENhbGxiYWNrcyk7XG4gIH1cbn1cblxuY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gYFxuICBQcmVzcyBzcGFjZSBiYXIgdG8gc3RhcnQgYSBkcmFnLlxuICBXaGVuIGRyYWdnaW5nIHlvdSBjYW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0gYXJvdW5kIGFuZCBlc2NhcGUgdG8gY2FuY2VsLlxuICBTb21lIHNjcmVlbiByZWFkZXJzIG1heSByZXF1aXJlIHlvdSB0byBiZSBpbiBmb2N1cyBtb2RlIG9yIHRvIHVzZSB5b3VyIHBhc3MgdGhyb3VnaCBrZXlcbmA7XG5jb25zdCBwb3NpdGlvbiA9IGluZGV4ID0+IGluZGV4ICsgMTtcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gc3RhcnQgPT4gYFxuICBZb3UgaGF2ZSBsaWZ0ZWQgYW4gaXRlbSBpbiBwb3NpdGlvbiAke3Bvc2l0aW9uKHN0YXJ0LnNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgd2l0aExvY2F0aW9uID0gKHNvdXJjZSwgZGVzdGluYXRpb24pID0+IHtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gc291cmNlLmRyb3BwYWJsZUlkID09PSBkZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHBvc2l0aW9uKHNvdXJjZS5pbmRleCk7XG4gIGNvbnN0IGVuZFBvc2l0aW9uID0gcG9zaXRpb24oZGVzdGluYXRpb24uaW5kZXgpO1xuICBpZiAoaXNJbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIG1vdmVkIHRoZSBpdGVtIGZyb20gcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufVxuICAgICAgdG8gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgWW91IGhhdmUgbW92ZWQgdGhlIGl0ZW0gZnJvbSBwb3NpdGlvbiAke3N0YXJ0UG9zaXRpb259XG4gICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICB0byBsaXN0ICR7ZGVzdGluYXRpb24uZHJvcHBhYmxlSWR9XG4gICAgaW4gcG9zaXRpb24gJHtlbmRQb3NpdGlvbn1cbiAgYDtcbn07XG5jb25zdCB3aXRoQ29tYmluZSA9IChpZCwgc291cmNlLCBjb21iaW5lKSA9PiB7XG4gIGNvbnN0IGluSG9tZUxpc3QgPSBzb3VyY2UuZHJvcHBhYmxlSWQgPT09IGNvbWJpbmUuZHJvcHBhYmxlSWQ7XG4gIGlmIChpbkhvbWVMaXN0KSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFRoZSBpdGVtICR7aWR9XG4gICAgICBoYXMgYmVlbiBjb21iaW5lZCB3aXRoICR7Y29tYmluZS5kcmFnZ2FibGVJZH1gO1xuICB9XG4gIHJldHVybiBgXG4gICAgICBUaGUgaXRlbSAke2lkfVxuICAgICAgaW4gbGlzdCAke3NvdXJjZS5kcm9wcGFibGVJZH1cbiAgICAgIGhhcyBiZWVuIGNvbWJpbmVkIHdpdGggJHtjb21iaW5lLmRyYWdnYWJsZUlkfVxuICAgICAgaW4gbGlzdCAke2NvbWJpbmUuZHJvcHBhYmxlSWR9XG4gICAgYDtcbn07XG5jb25zdCBvbkRyYWdVcGRhdGUgPSB1cGRhdGUgPT4ge1xuICBjb25zdCBsb2NhdGlvbiA9IHVwZGF0ZS5kZXN0aW5hdGlvbjtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHdpdGhMb2NhdGlvbih1cGRhdGUuc291cmNlLCBsb2NhdGlvbik7XG4gIH1cbiAgY29uc3QgY29tYmluZSA9IHVwZGF0ZS5jb21iaW5lO1xuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiB3aXRoQ29tYmluZSh1cGRhdGUuZHJhZ2dhYmxlSWQsIHVwZGF0ZS5zb3VyY2UsIGNvbWJpbmUpO1xuICB9XG4gIHJldHVybiAnWW91IGFyZSBvdmVyIGFuIGFyZWEgdGhhdCBjYW5ub3QgYmUgZHJvcHBlZCBvbic7XG59O1xuY29uc3QgcmV0dXJuZWRUb1N0YXJ0ID0gc291cmNlID0+IGBcbiAgVGhlIGl0ZW0gaGFzIHJldHVybmVkIHRvIGl0cyBzdGFydGluZyBwb3NpdGlvblxuICBvZiAke3Bvc2l0aW9uKHNvdXJjZS5pbmRleCl9XG5gO1xuY29uc3Qgb25EcmFnRW5kID0gcmVzdWx0ID0+IHtcbiAgaWYgKHJlc3VsdC5yZWFzb24gPT09ICdDQU5DRUwnKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIE1vdmVtZW50IGNhbmNlbGxlZC5cbiAgICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSByZXN1bHQuZGVzdGluYXRpb247XG4gIGNvbnN0IGNvbWJpbmUgPSByZXN1bHQuY29tYmluZTtcbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIFlvdSBoYXZlIGRyb3BwZWQgdGhlIGl0ZW0uXG4gICAgICAke3dpdGhMb2NhdGlvbihyZXN1bHQuc291cmNlLCBsb2NhdGlvbil9XG4gICAgYDtcbiAgfVxuICBpZiAoY29tYmluZSkge1xuICAgIHJldHVybiBgXG4gICAgICBZb3UgaGF2ZSBkcm9wcGVkIHRoZSBpdGVtLlxuICAgICAgJHt3aXRoQ29tYmluZShyZXN1bHQuZHJhZ2dhYmxlSWQsIHJlc3VsdC5zb3VyY2UsIGNvbWJpbmUpfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBUaGUgaXRlbSBoYXMgYmVlbiBkcm9wcGVkIHdoaWxlIG5vdCBvdmVyIGEgZHJvcCBhcmVhLlxuICAgICR7cmV0dXJuZWRUb1N0YXJ0KHJlc3VsdC5zb3VyY2UpfVxuICBgO1xufTtcbmNvbnN0IHByZXNldCA9IHtcbiAgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnVXBkYXRlLFxuICBvbkRyYWdFbmRcbn07XG5cbmZ1bmN0aW9uIGlzRXF1YWwkMihmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihmaXJzdCkgJiYgTnVtYmVyLmlzTmFOKHNlY29uZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3SW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc0VxdWFsJDIobmV3SW5wdXRzW2ldLCBsYXN0SW5wdXRzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhnZXRSZXN1bHQsIGlucHV0cykge1xuICBjb25zdCBpbml0aWFsID0gdXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9KSlbMF07XG4gIGNvbnN0IGlzRmlyc3RSdW4gPSB1c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IGNvbW1pdHRlZCA9IHVzZVJlZihpbml0aWFsKTtcbiAgY29uc3QgdXNlQ2FjaGUgPSBpc0ZpcnN0UnVuLmN1cnJlbnQgfHwgQm9vbGVhbihpbnB1dHMgJiYgY29tbWl0dGVkLmN1cnJlbnQuaW5wdXRzICYmIGFyZUlucHV0c0VxdWFsKGlucHV0cywgY29tbWl0dGVkLmN1cnJlbnQuaW5wdXRzKSk7XG4gIGNvbnN0IGNhY2hlID0gdXNlQ2FjaGUgPyBjb21taXR0ZWQuY3VycmVudCA6IHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzRmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgIGNvbW1pdHRlZC5jdXJyZW50ID0gY2FjaGU7XG4gIH0sIFtjYWNoZV0pO1xuICByZXR1cm4gY2FjaGUucmVzdWx0O1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBjYWxsYmFjaywgaW5wdXRzKTtcbn1cblxuY29uc3Qgb3JpZ2luID0ge1xuICB4OiAwLFxuICB5OiAwXG59O1xuY29uc3QgYWRkID0gKHBvaW50MSwgcG9pbnQyKSA9PiAoe1xuICB4OiBwb2ludDEueCArIHBvaW50Mi54LFxuICB5OiBwb2ludDEueSArIHBvaW50Mi55XG59KTtcbmNvbnN0IHN1YnRyYWN0ID0gKHBvaW50MSwgcG9pbnQyKSA9PiAoe1xuICB4OiBwb2ludDEueCAtIHBvaW50Mi54LFxuICB5OiBwb2ludDEueSAtIHBvaW50Mi55XG59KTtcbmNvbnN0IGlzRXF1YWwkMSA9IChwb2ludDEsIHBvaW50MikgPT4gcG9pbnQxLnggPT09IHBvaW50Mi54ICYmIHBvaW50MS55ID09PSBwb2ludDIueTtcbmNvbnN0IG5lZ2F0ZSA9IHBvaW50ID0+ICh7XG4gIHg6IHBvaW50LnggIT09IDAgPyAtcG9pbnQueCA6IDAsXG4gIHk6IHBvaW50LnkgIT09IDAgPyAtcG9pbnQueSA6IDBcbn0pO1xuY29uc3QgcGF0Y2ggPSAobGluZSwgdmFsdWUsIG90aGVyVmFsdWUgPSAwKSA9PiB7XG4gIGlmIChsaW5lID09PSAneCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdmFsdWUsXG4gICAgICB5OiBvdGhlclZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IG90aGVyVmFsdWUsXG4gICAgeTogdmFsdWVcbiAgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChwb2ludDEsIHBvaW50MikgPT4gTWF0aC5zcXJ0KChwb2ludDIueCAtIHBvaW50MS54KSAqKiAyICsgKHBvaW50Mi55IC0gcG9pbnQxLnkpICoqIDIpO1xuY29uc3QgY2xvc2VzdCQxID0gKHRhcmdldCwgcG9pbnRzKSA9PiBNYXRoLm1pbiguLi5wb2ludHMubWFwKHBvaW50ID0+IGRpc3RhbmNlKHRhcmdldCwgcG9pbnQpKSk7XG5jb25zdCBhcHBseSA9IGZuID0+IHBvaW50ID0+ICh7XG4gIHg6IGZuKHBvaW50LngpLFxuICB5OiBmbihwb2ludC55KVxufSk7XG5cbnZhciBleGVjdXRlQ2xpcCA9IChmcmFtZSwgc3ViamVjdCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBnZXRSZWN0KHtcbiAgICB0b3A6IE1hdGgubWF4KHN1YmplY3QudG9wLCBmcmFtZS50b3ApLFxuICAgIHJpZ2h0OiBNYXRoLm1pbihzdWJqZWN0LnJpZ2h0LCBmcmFtZS5yaWdodCksXG4gICAgYm90dG9tOiBNYXRoLm1pbihzdWJqZWN0LmJvdHRvbSwgZnJhbWUuYm90dG9tKSxcbiAgICBsZWZ0OiBNYXRoLm1heChzdWJqZWN0LmxlZnQsIGZyYW1lLmxlZnQpXG4gIH0pO1xuICBpZiAocmVzdWx0LndpZHRoIDw9IDAgfHwgcmVzdWx0LmhlaWdodCA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IG9mZnNldEJ5UG9zaXRpb24gPSAoc3BhY2luZywgcG9pbnQpID0+ICh7XG4gIHRvcDogc3BhY2luZy50b3AgKyBwb2ludC55LFxuICBsZWZ0OiBzcGFjaW5nLmxlZnQgKyBwb2ludC54LFxuICBib3R0b206IHNwYWNpbmcuYm90dG9tICsgcG9pbnQueSxcbiAgcmlnaHQ6IHNwYWNpbmcucmlnaHQgKyBwb2ludC54XG59KTtcbmNvbnN0IGdldENvcm5lcnMgPSBzcGFjaW5nID0+IFt7XG4gIHg6IHNwYWNpbmcubGVmdCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5yaWdodCxcbiAgeTogc3BhY2luZy50b3Bcbn0sIHtcbiAgeDogc3BhY2luZy5sZWZ0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufSwge1xuICB4OiBzcGFjaW5nLnJpZ2h0LFxuICB5OiBzcGFjaW5nLmJvdHRvbVxufV07XG5jb25zdCBub1NwYWNpbmcgPSB7XG4gIHRvcDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMFxufTtcblxuY29uc3Qgc2Nyb2xsJDEgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0QnlQb3NpdGlvbih0YXJnZXQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuY29uc3QgaW5jcmVhc2UgPSAodGFyZ2V0LCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpID0+IHtcbiAgaWYgKHdpdGhQbGFjZWhvbGRlciAmJiB3aXRoUGxhY2Vob2xkZXIuaW5jcmVhc2VkQnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGFyZ2V0LFxuICAgICAgW2F4aXMuZW5kXTogdGFyZ2V0W2F4aXMuZW5kXSArIHdpdGhQbGFjZWhvbGRlci5pbmNyZWFzZWRCeVtheGlzLmxpbmVdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IGNsaXAgPSAodGFyZ2V0LCBmcmFtZSkgPT4ge1xuICBpZiAoZnJhbWUgJiYgZnJhbWUuc2hvdWxkQ2xpcFN1YmplY3QpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUNsaXAoZnJhbWUucGFnZU1hcmdpbkJveCwgdGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZ2V0UmVjdCh0YXJnZXQpO1xufTtcbnZhciBnZXRTdWJqZWN0ID0gKHtcbiAgcGFnZSxcbiAgd2l0aFBsYWNlaG9sZGVyLFxuICBheGlzLFxuICBmcmFtZVxufSkgPT4ge1xuICBjb25zdCBzY3JvbGxlZCA9IHNjcm9sbCQxKHBhZ2UubWFyZ2luQm94LCBmcmFtZSk7XG4gIGNvbnN0IGluY3JlYXNlZCA9IGluY3JlYXNlKHNjcm9sbGVkLCBheGlzLCB3aXRoUGxhY2Vob2xkZXIpO1xuICBjb25zdCBjbGlwcGVkID0gY2xpcChpbmNyZWFzZWQsIGZyYW1lKTtcbiAgcmV0dXJuIHtcbiAgICBwYWdlLFxuICAgIHdpdGhQbGFjZWhvbGRlcixcbiAgICBhY3RpdmU6IGNsaXBwZWRcbiAgfTtcbn07XG5cbnZhciBzY3JvbGxEcm9wcGFibGUgPSAoZHJvcHBhYmxlLCBuZXdTY3JvbGwpID0+IHtcbiAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHNjcm9sbGFibGUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGNvbnN0IHNjcm9sbERpZmYgPSBzdWJ0cmFjdChuZXdTY3JvbGwsIHNjcm9sbGFibGUuc2Nyb2xsLmluaXRpYWwpO1xuICBjb25zdCBzY3JvbGxEaXNwbGFjZW1lbnQgPSBuZWdhdGUoc2Nyb2xsRGlmZik7XG4gIGNvbnN0IGZyYW1lID0ge1xuICAgIC4uLnNjcm9sbGFibGUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiBzY3JvbGxhYmxlLnNjcm9sbC5pbml0aWFsLFxuICAgICAgY3VycmVudDogbmV3U2Nyb2xsLFxuICAgICAgZGlmZjoge1xuICAgICAgICB2YWx1ZTogc2Nyb2xsRGlmZixcbiAgICAgICAgZGlzcGxhY2VtZW50OiBzY3JvbGxEaXNwbGFjZW1lbnRcbiAgICAgIH0sXG4gICAgICBtYXg6IHNjcm9sbGFibGUuc2Nyb2xsLm1heFxuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBkcm9wcGFibGUuc3ViamVjdC53aXRoUGxhY2Vob2xkZXIsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWVcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgZnJhbWUsXG4gICAgc3ViamVjdFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gbWVtb2l6ZU9uZShyZXN1bHRGbiwgaXNFcXVhbCA9IGFyZUlucHV0c0VxdWFsKSB7XG4gIGxldCBjYWNoZSA9IG51bGw7XG4gIGZ1bmN0aW9uIG1lbW9pemVkKC4uLm5ld0FyZ3MpIHtcbiAgICBpZiAoY2FjaGUgJiYgY2FjaGUubGFzdFRoaXMgPT09IHRoaXMgJiYgaXNFcXVhbChuZXdBcmdzLCBjYWNoZS5sYXN0QXJncykpIHtcbiAgICAgIHJldHVybiBjYWNoZS5sYXN0UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgY2FjaGUgPSB7XG4gICAgICBsYXN0UmVzdWx0LFxuICAgICAgbGFzdEFyZ3M6IG5ld0FyZ3MsXG4gICAgICBsYXN0VGhpczogdGhpc1xuICAgIH07XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjYWNoZSA9IG51bGw7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuY29uc3QgdG9Ecm9wcGFibGVNYXAgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gZHJvcHBhYmxlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICByZXR1cm4gcHJldmlvdXM7XG59LCB7fSkpO1xuY29uc3QgdG9EcmFnZ2FibGVNYXAgPSBtZW1vaXplT25lKGRyYWdnYWJsZXMgPT4gZHJhZ2dhYmxlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiB7XG4gIHByZXZpb3VzW2N1cnJlbnQuZGVzY3JpcHRvci5pZF0gPSBjdXJyZW50O1xuICByZXR1cm4gcHJldmlvdXM7XG59LCB7fSkpO1xuY29uc3QgdG9Ecm9wcGFibGVMaXN0ID0gbWVtb2l6ZU9uZShkcm9wcGFibGVzID0+IE9iamVjdC52YWx1ZXMoZHJvcHBhYmxlcykpO1xuY29uc3QgdG9EcmFnZ2FibGVMaXN0ID0gbWVtb2l6ZU9uZShkcmFnZ2FibGVzID0+IE9iamVjdC52YWx1ZXMoZHJhZ2dhYmxlcykpO1xuXG52YXIgZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZSA9IG1lbW9pemVPbmUoKGRyb3BwYWJsZUlkLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IHRvRHJhZ2dhYmxlTGlzdChkcmFnZ2FibGVzKS5maWx0ZXIoZHJhZ2dhYmxlID0+IGRyb3BwYWJsZUlkID09PSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZCkuc29ydCgoYSwgYikgPT4gYS5kZXNjcmlwdG9yLmluZGV4IC0gYi5kZXNjcmlwdG9yLmluZGV4KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5mdW5jdGlvbiB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIHtcbiAgaWYgKGltcGFjdC5hdCAmJiBpbXBhY3QuYXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgcmV0dXJuIGltcGFjdC5hdC5kZXN0aW5hdGlvbjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRyeUdldENvbWJpbmUoaW1wYWN0KSB7XG4gIGlmIChpbXBhY3QuYXQgJiYgaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJykge1xuICAgIHJldHVybiBpbXBhY3QuYXQuY29tYmluZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHJlbW92ZURyYWdnYWJsZUZyb21MaXN0ID0gbWVtb2l6ZU9uZSgocmVtb3ZlLCBsaXN0KSA9PiBsaXN0LmZpbHRlcihpdGVtID0+IGl0ZW0uZGVzY3JpcHRvci5pZCAhPT0gcmVtb3ZlLmRlc2NyaXB0b3IuaWQpKTtcblxudmFyIG1vdmVUb05leHRDb21iaW5lID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBkcmFnZ2FibGUsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgcHJldmlvdXNJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihwcmV2aW91c0ltcGFjdCk7XG4gIGlmICghbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbXBhY3QodGFyZ2V0KSB7XG4gICAgY29uc3QgYXQgPSB7XG4gICAgICB0eXBlOiAnQ09NQklORScsXG4gICAgICBjb21iaW5lOiB7XG4gICAgICAgIGRyYWdnYWJsZUlkOiB0YXJnZXQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJldmlvdXNJbXBhY3QsXG4gICAgICBhdFxuICAgIH07XG4gIH1cbiAgY29uc3QgYWxsID0gcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLmFsbDtcbiAgY29uc3QgY2xvc2VzdElkID0gYWxsLmxlbmd0aCA/IGFsbFswXSA6IG51bGw7XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY2xvc2VzdElkID8gZ2V0SW1wYWN0KGNsb3Nlc3RJZCkgOiBudWxsO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2FibGUgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgaWYgKCFjbG9zZXN0SWQpIHtcbiAgICBpZiAoIXdpdGhvdXREcmFnZ2FibGUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHdpdGhvdXREcmFnZ2FibGVbd2l0aG91dERyYWdnYWJsZS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZ2V0SW1wYWN0KGxhc3QuZGVzY3JpcHRvci5pZCk7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkNsb3Nlc3QgPSB3aXRob3V0RHJhZ2dhYmxlLmZpbmRJbmRleChkID0+IGQuZGVzY3JpcHRvci5pZCA9PT0gY2xvc2VzdElkKTtcbiAgIShpbmRleE9mQ2xvc2VzdCAhPT0gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgZGlzcGxhY2VkIGl0ZW0gaW4gc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9IGluZGV4T2ZDbG9zZXN0IC0gMTtcbiAgaWYgKHByb3Bvc2VkSW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYmVmb3JlID0gd2l0aG91dERyYWdnYWJsZVtwcm9wb3NlZEluZGV4XTtcbiAgcmV0dXJuIGdldEltcGFjdChiZWZvcmUuZGVzY3JpcHRvci5pZCk7XG59O1xuXG52YXIgaXNIb21lT2YgPSAoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPT4gZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQgPT09IGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQ7XG5cbmNvbnN0IG5vRGlzcGxhY2VkQnkgPSB7XG4gIHBvaW50OiBvcmlnaW4sXG4gIHZhbHVlOiAwXG59O1xuY29uc3QgZW1wdHlHcm91cHMgPSB7XG4gIGludmlzaWJsZToge30sXG4gIHZpc2libGU6IHt9LFxuICBhbGw6IFtdXG59O1xuY29uc3Qgbm9JbXBhY3QgPSB7XG4gIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gIGRpc3BsYWNlZEJ5OiBub0Rpc3BsYWNlZEJ5LFxuICBhdDogbnVsbFxufTtcblxudmFyIGlzV2l0aGluID0gKGxvd2VyQm91bmQsIHVwcGVyQm91bmQpID0+IHZhbHVlID0+IGxvd2VyQm91bmQgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdXBwZXJCb3VuZDtcblxudmFyIGlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSA9IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QudG9wKSAmJiBpc1dpdGhpblZlcnRpY2FsKHN1YmplY3QuYm90dG9tKSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNQYXJ0aWFsbHlWaXNpYmxlVmVydGljYWxseSA9IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC50b3ApIHx8IGlzV2l0aGluVmVydGljYWwoc3ViamVjdC5ib3R0b20pO1xuICAgIGNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZUhvcml6b250YWxseSA9IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LmxlZnQpIHx8IGlzV2l0aGluSG9yaXpvbnRhbChzdWJqZWN0LnJpZ2h0KTtcbiAgICBjb25zdCBpc1BhcnRpYWxseUNvbnRhaW5lZCA9IGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5O1xuICAgIGlmIChpc1BhcnRpYWxseUNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGlzQmlnZ2VyVmVydGljYWxseSA9IHN1YmplY3QudG9wIDwgZnJhbWUudG9wICYmIHN1YmplY3QuYm90dG9tID4gZnJhbWUuYm90dG9tO1xuICAgIGNvbnN0IGlzQmlnZ2VySG9yaXpvbnRhbGx5ID0gc3ViamVjdC5sZWZ0IDwgZnJhbWUubGVmdCAmJiBzdWJqZWN0LnJpZ2h0ID4gZnJhbWUucmlnaHQ7XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNCaWdnZXJIb3Jpem9udGFsbHk7XG4gICAgaWYgKGlzVGFyZ2V0QmlnZ2VyVGhhbkZyYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaXNUYXJnZXRCaWdnZXJPbk9uZUF4aXMgPSBpc0JpZ2dlclZlcnRpY2FsbHkgJiYgaXNQYXJ0aWFsbHlWaXNpYmxlSG9yaXpvbnRhbGx5IHx8IGlzQmlnZ2VySG9yaXpvbnRhbGx5ICYmIGlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHk7XG4gICAgcmV0dXJuIGlzVGFyZ2V0QmlnZ2VyT25PbmVBeGlzO1xuICB9O1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGNvbnN0IGlzV2l0aGluVmVydGljYWwgPSBpc1dpdGhpbihmcmFtZS50b3AsIGZyYW1lLmJvdHRvbSk7XG4gIGNvbnN0IGlzV2l0aGluSG9yaXpvbnRhbCA9IGlzV2l0aGluKGZyYW1lLmxlZnQsIGZyYW1lLnJpZ2h0KTtcbiAgcmV0dXJuIHN1YmplY3QgPT4ge1xuICAgIGNvbnN0IGlzQ29udGFpbmVkID0gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QubGVmdCkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHN1YmplY3QucmlnaHQpO1xuICAgIHJldHVybiBpc0NvbnRhaW5lZDtcbiAgfTtcbn07XG5cbmNvbnN0IHZlcnRpY2FsID0ge1xuICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGxpbmU6ICd5JyxcbiAgY3Jvc3NBeGlzTGluZTogJ3gnLFxuICBzdGFydDogJ3RvcCcsXG4gIGVuZDogJ2JvdHRvbScsXG4gIHNpemU6ICdoZWlnaHQnLFxuICBjcm9zc0F4aXNTdGFydDogJ2xlZnQnLFxuICBjcm9zc0F4aXNFbmQ6ICdyaWdodCcsXG4gIGNyb3NzQXhpc1NpemU6ICd3aWR0aCdcbn07XG5jb25zdCBob3Jpem9udGFsID0ge1xuICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyxcbiAgbGluZTogJ3gnLFxuICBjcm9zc0F4aXNMaW5lOiAneScsXG4gIHN0YXJ0OiAnbGVmdCcsXG4gIGVuZDogJ3JpZ2h0JyxcbiAgc2l6ZTogJ3dpZHRoJyxcbiAgY3Jvc3NBeGlzU3RhcnQ6ICd0b3AnLFxuICBjcm9zc0F4aXNFbmQ6ICdib3R0b20nLFxuICBjcm9zc0F4aXNTaXplOiAnaGVpZ2h0J1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMgPSBheGlzID0+IGZyYW1lID0+IHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gc3ViamVjdCA9PiB7XG4gICAgaWYgKGF4aXMgPT09IHZlcnRpY2FsKSB7XG4gICAgICByZXR1cm4gaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LnRvcCkgJiYgaXNXaXRoaW5WZXJ0aWNhbChzdWJqZWN0LmJvdHRvbSk7XG4gICAgfVxuICAgIHJldHVybiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5sZWZ0KSAmJiBpc1dpdGhpbkhvcml6b250YWwoc3ViamVjdC5yaWdodCk7XG4gIH07XG59O1xuXG5jb25zdCBnZXREcm9wcGFibGVEaXNwbGFjZWQgPSAodGFyZ2V0LCBkZXN0aW5hdGlvbikgPT4ge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCA6IG9yaWdpbjtcbiAgcmV0dXJuIG9mZnNldEJ5UG9zaXRpb24odGFyZ2V0LCBkaXNwbGFjZW1lbnQpO1xufTtcbmNvbnN0IGlzVmlzaWJsZUluRHJvcHBhYmxlID0gKHRhcmdldCwgZGVzdGluYXRpb24sIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKSA9PiB7XG4gIGlmICghZGVzdGluYXRpb24uc3ViamVjdC5hY3RpdmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKGRlc3RpbmF0aW9uLnN1YmplY3QuYWN0aXZlKSh0YXJnZXQpO1xufTtcbmNvbnN0IGlzVmlzaWJsZUluVmlld3BvcnQgPSAodGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pID0+IGlzVmlzaWJsZVRocm91Z2hGcmFtZUZuKHZpZXdwb3J0KSh0YXJnZXQpO1xuY29uc3QgaXNWaXNpYmxlJDEgPSAoe1xuICB0YXJnZXQ6IHRvQmVEaXNwbGFjZWQsXG4gIGRlc3RpbmF0aW9uLFxuICB2aWV3cG9ydCxcbiAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm5cbn0pID0+IHtcbiAgY29uc3QgZGlzcGxhY2VkVGFyZ2V0ID0gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA/IGdldERyb3BwYWJsZURpc3BsYWNlZCh0b0JlRGlzcGxhY2VkLCBkZXN0aW5hdGlvbikgOiB0b0JlRGlzcGxhY2VkO1xuICByZXR1cm4gaXNWaXNpYmxlSW5Ecm9wcGFibGUoZGlzcGxhY2VkVGFyZ2V0LCBkZXN0aW5hdGlvbiwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pICYmIGlzVmlzaWJsZUluVmlld3BvcnQoZGlzcGxhY2VkVGFyZ2V0LCB2aWV3cG9ydCwgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm4pO1xufTtcbmNvbnN0IGlzUGFydGlhbGx5VmlzaWJsZSA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lXG59KTtcbmNvbnN0IGlzVG90YWxseVZpc2libGUgPSBhcmdzID0+IGlzVmlzaWJsZSQxKHtcbiAgLi4uYXJncyxcbiAgaXNWaXNpYmxlVGhyb3VnaEZyYW1lRm46IGlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVcbn0pO1xuY29uc3QgaXNUb3RhbGx5VmlzaWJsZU9uQXhpcyA9IGFyZ3MgPT4gaXNWaXNpYmxlJDEoe1xuICAuLi5hcmdzLFxuICBpc1Zpc2libGVUaHJvdWdoRnJhbWVGbjogaXNUb3RhbGx5VmlzaWJsZVRocm91Z2hGcmFtZU9uQXhpcyhhcmdzLmRlc3RpbmF0aW9uLmF4aXMpXG59KTtcblxuY29uc3QgZ2V0U2hvdWxkQW5pbWF0ZSA9IChpZCwgbGFzdCwgZm9yY2VTaG91bGRBbmltYXRlKSA9PiB7XG4gIGlmICh0eXBlb2YgZm9yY2VTaG91bGRBbmltYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbnZpc2libGUsXG4gICAgdmlzaWJsZVxuICB9ID0gbGFzdDtcbiAgaWYgKGludmlzaWJsZVtpZF0pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJldmlvdXMgPSB2aXNpYmxlW2lkXTtcbiAgcmV0dXJuIHByZXZpb3VzID8gcHJldmlvdXMuc2hvdWxkQW5pbWF0ZSA6IHRydWU7XG59O1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KGRyYWdnYWJsZSwgZGlzcGxhY2VkQnkpIHtcbiAgY29uc3QgbWFyZ2luQm94ID0gZHJhZ2dhYmxlLnBhZ2UubWFyZ2luQm94O1xuICBjb25zdCBleHBhbmRCeSA9IHtcbiAgICB0b3A6IGRpc3BsYWNlZEJ5LnBvaW50LnksXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IGRpc3BsYWNlZEJ5LnBvaW50LnhcbiAgfTtcbiAgcmV0dXJuIGdldFJlY3QoZXhwYW5kKG1hcmdpbkJveCwgZXhwYW5kQnkpKTtcbn1cbmZ1bmN0aW9uIGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gIGFmdGVyRHJhZ2dpbmcsXG4gIGRlc3RpbmF0aW9uLFxuICBkaXNwbGFjZWRCeSxcbiAgdmlld3BvcnQsXG4gIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgbGFzdFxufSkge1xuICByZXR1cm4gYWZ0ZXJEcmFnZ2luZy5yZWR1Y2UoZnVuY3Rpb24gcHJvY2Vzcyhncm91cHMsIGRyYWdnYWJsZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChkcmFnZ2FibGUsIGRpc3BsYWNlZEJ5KTtcbiAgICBjb25zdCBpZCA9IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkO1xuICAgIGdyb3Vwcy5hbGwucHVzaChpZCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gaXNQYXJ0aWFsbHlWaXNpYmxlKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCFpc1Zpc2libGUpIHtcbiAgICAgIGdyb3Vwcy5pbnZpc2libGVbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGUgPSBnZXRTaG91bGRBbmltYXRlKGlkLCBsYXN0LCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHtcbiAgICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICAgIHNob3VsZEFuaW1hdGVcbiAgICB9O1xuICAgIGdyb3Vwcy52aXNpYmxlW2lkXSA9IGRpc3BsYWNlbWVudDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9LCB7XG4gICAgYWxsOiBbXSxcbiAgICB2aXNpYmxlOiB7fSxcbiAgICBpbnZpc2libGU6IHt9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleE9mTGFzdEl0ZW0oZHJhZ2dhYmxlcywgb3B0aW9ucykge1xuICBpZiAoIWRyYWdnYWJsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgaW5kZXhPZkxhc3RJdGVtID0gZHJhZ2dhYmxlc1tkcmFnZ2FibGVzLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIHJldHVybiBvcHRpb25zLmluSG9tZUxpc3QgPyBpbmRleE9mTGFzdEl0ZW0gOiBpbmRleE9mTGFzdEl0ZW0gKyAxO1xufVxuZnVuY3Rpb24gZ29BdEVuZCh7XG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBpbkhvbWVMaXN0LFxuICBkaXNwbGFjZWRCeSxcbiAgZGVzdGluYXRpb25cbn0pIHtcbiAgY29uc3QgbmV3SW5kZXggPSBnZXRJbmRleE9mTGFzdEl0ZW0oaW5zaWRlRGVzdGluYXRpb24sIHtcbiAgICBpbkhvbWVMaXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgZGlzcGxhY2VkQnksXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgIGRlc3RpbmF0aW9uOiB7XG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLFxuICAgICAgICBpbmRleDogbmV3SW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgZHJhZ2dhYmxlLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZGVzdGluYXRpb24sXG4gIHZpZXdwb3J0LFxuICBkaXNwbGFjZWRCeSxcbiAgbGFzdCxcbiAgaW5kZXgsXG4gIGZvcmNlU2hvdWxkQW5pbWF0ZVxufSkge1xuICBjb25zdCBpbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gaW5zaWRlRGVzdGluYXRpb24uZmluZChpdGVtID0+IGl0ZW0uZGVzY3JpcHRvci5pbmRleCA9PT0gaW5kZXgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIGdvQXRFbmQoe1xuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBpbkhvbWVMaXN0LFxuICAgICAgZGlzcGxhY2VkQnksXG4gICAgICBkZXN0aW5hdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHdpdGhvdXREcmFnZ2luZyA9IHJlbW92ZURyYWdnYWJsZUZyb21MaXN0KGRyYWdnYWJsZSwgaW5zaWRlRGVzdGluYXRpb24pO1xuICBjb25zdCBzbGljZUZyb20gPSBpbnNpZGVEZXN0aW5hdGlvbi5pbmRleE9mKG1hdGNoKTtcbiAgY29uc3QgaW1wYWN0ZWQgPSB3aXRob3V0RHJhZ2dpbmcuc2xpY2Uoc2xpY2VGcm9tKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBpbXBhY3RlZCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGVcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjoge1xuICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgaW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGVJZCwgYWZ0ZXJDcml0aWNhbCkge1xuICByZXR1cm4gQm9vbGVhbihhZnRlckNyaXRpY2FsLmVmZmVjdGVkW2RyYWdnYWJsZUlkXSk7XG59XG5cbnZhciBmcm9tQ29tYmluZSA9ICh7XG4gIGlzTW92aW5nRm9yd2FyZCxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIGNvbWJpbmUsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFkZXN0aW5hdGlvbi5pc0NvbWJpbmVFbmFibGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29tYmluZUlkID0gY29tYmluZS5kcmFnZ2FibGVJZDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBkcmFnZ2FibGVzW2NvbWJpbmVJZF07XG4gIGNvbnN0IGNvbWJpbmVXaXRoSW5kZXggPSBjb21iaW5lV2l0aC5kZXNjcmlwdG9yLmluZGV4O1xuICBjb25zdCBkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChjb21iaW5lSWQsIGFmdGVyQ3JpdGljYWwpO1xuICBpZiAoZGlkQ29tYmluZVdpdGhTdGFydEFmdGVyQ3JpdGljYWwpIHtcbiAgICBpZiAoaXNNb3ZpbmdGb3J3YXJkKSB7XG4gICAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXggLSAxO1xuICB9XG4gIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICByZXR1cm4gY29tYmluZVdpdGhJbmRleCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVXaXRoSW5kZXg7XG59O1xuXG52YXIgZnJvbVJlb3JkZXIgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGlzSW5Ib21lTGlzdCxcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGxvY2F0aW9uXG59KSA9PiB7XG4gIGlmICghaW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY3VycmVudEluZGV4ID0gbG9jYXRpb24uaW5kZXg7XG4gIGNvbnN0IHByb3Bvc2VkSW5kZXggPSBpc01vdmluZ0ZvcndhcmQgPyBjdXJyZW50SW5kZXggKyAxIDogY3VycmVudEluZGV4IC0gMTtcbiAgY29uc3QgZmlyc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uWzBdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IGluc2lkZURlc3RpbmF0aW9uW2luc2lkZURlc3RpbmF0aW9uLmxlbmd0aCAtIDFdLmRlc2NyaXB0b3IuaW5kZXg7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBpc0luSG9tZUxpc3QgPyBsYXN0SW5kZXggOiBsYXN0SW5kZXggKyAxO1xuICBpZiAocHJvcG9zZWRJbmRleCA8IGZpcnN0SW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocHJvcG9zZWRJbmRleCA+IHVwcGVyQm91bmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcHJvcG9zZWRJbmRleDtcbn07XG5cbnZhciBtb3ZlVG9OZXh0SW5kZXggPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGlzSW5Ib21lTGlzdCxcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCB3YXNBdCA9IHByZXZpb3VzSW1wYWN0LmF0O1xuICAhd2FzQXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgbW92ZSBpbiBkaXJlY3Rpb24gd2l0aG91dCBwcmV2aW91cyBpbXBhY3QgbG9jYXRpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBpZiAod2FzQXQudHlwZSA9PT0gJ1JFT1JERVInKSB7XG4gICAgY29uc3QgbmV3SW5kZXggPSBmcm9tUmVvcmRlcih7XG4gICAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgICBpc0luSG9tZUxpc3QsXG4gICAgICBsb2NhdGlvbjogd2FzQXQuZGVzdGluYXRpb24sXG4gICAgICBpbnNpZGVEZXN0aW5hdGlvblxuICAgIH0pO1xuICAgIGlmIChuZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgZGlzcGxhY2VkQnk6IHByZXZpb3VzSW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbmV3SW5kZXggPSBmcm9tQ29tYmluZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgY29tYmluZTogd2FzQXQuY29tYmluZSxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAobmV3SW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVSZW9yZGVySW1wYWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW5zaWRlRGVzdGluYXRpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQsXG4gICAgbGFzdDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWRCeSxcbiAgICBpbmRleDogbmV3SW5kZXhcbiAgfSk7XG59O1xuXG52YXIgZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50ID0gKHtcbiAgZGlzcGxhY2VkLFxuICBhZnRlckNyaXRpY2FsLFxuICBjb21iaW5lV2l0aCxcbiAgZGlzcGxhY2VkQnlcbn0pID0+IHtcbiAgY29uc3QgaXNEaXNwbGFjZWQgPSBCb29sZWFuKGRpc3BsYWNlZC52aXNpYmxlW2NvbWJpbmVXaXRoXSB8fCBkaXNwbGFjZWQuaW52aXNpYmxlW2NvbWJpbmVXaXRoXSk7XG4gIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwoY29tYmluZVdpdGgsIGFmdGVyQ3JpdGljYWwpKSB7XG4gICAgcmV0dXJuIGlzRGlzcGxhY2VkID8gb3JpZ2luIDogbmVnYXRlKGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgfVxuICByZXR1cm4gaXNEaXNwbGFjZWQgPyBkaXNwbGFjZWRCeS5wb2ludCA6IG9yaWdpbjtcbn07XG5cbnZhciB3aGVuQ29tYmluaW5nID0gKHtcbiAgYWZ0ZXJDcml0aWNhbCxcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGVzXG59KSA9PiB7XG4gIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICFjb21iaW5lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgY29tYmluZVdpdGggPSBjb21iaW5lLmRyYWdnYWJsZUlkO1xuICBjb25zdCBjZW50ZXIgPSBkcmFnZ2FibGVzW2NvbWJpbmVXaXRoXS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGRpc3BsYWNlQnkgPSBnZXRDb21iaW5lZEl0ZW1EaXNwbGFjZW1lbnQoe1xuICAgIGRpc3BsYWNlZDogaW1wYWN0LmRpc3BsYWNlZCxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGNvbWJpbmVXaXRoLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnlcbiAgfSk7XG4gIHJldHVybiBhZGQoY2VudGVyLCBkaXNwbGFjZUJ5KTtcbn07XG5cbmNvbnN0IGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIgPSAoYXhpcywgYm94KSA9PiBib3gubWFyZ2luW2F4aXMuc3RhcnRdICsgYm94LmJvcmRlckJveFtheGlzLnNpemVdIC8gMjtcbmNvbnN0IGRpc3RhbmNlRnJvbUVuZFRvQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIGJveCkgPT4gYm94Lm1hcmdpbltheGlzLmVuZF0gKyBib3guYm9yZGVyQm94W2F4aXMuc2l6ZV0gLyAyO1xuY29uc3QgZ2V0Q3Jvc3NBeGlzQm9yZGVyQm94Q2VudGVyID0gKGF4aXMsIHRhcmdldCwgaXNNb3ZpbmcpID0+IHRhcmdldFtheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLm1hcmdpbltheGlzLmNyb3NzQXhpc1N0YXJ0XSArIGlzTW92aW5nLmJvcmRlckJveFtheGlzLmNyb3NzQXhpc1NpemVdIC8gMjtcbmNvbnN0IGdvQWZ0ZXIgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuZW5kXSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29CZWZvcmUgPSAoe1xuICBheGlzLFxuICBtb3ZlUmVsYXRpdmVUbyxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94W2F4aXMuc3RhcnRdIC0gZGlzdGFuY2VGcm9tRW5kVG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZVJlbGF0aXZlVG8ubWFyZ2luQm94LCBpc01vdmluZykpO1xuY29uc3QgZ29JbnRvU3RhcnQgPSAoe1xuICBheGlzLFxuICBtb3ZlSW50byxcbiAgaXNNb3Zpbmdcbn0pID0+IHBhdGNoKGF4aXMubGluZSwgbW92ZUludG8uY29udGVudEJveFtheGlzLnN0YXJ0XSArIGRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIoYXhpcywgaXNNb3ZpbmcpLCBnZXRDcm9zc0F4aXNCb3JkZXJCb3hDZW50ZXIoYXhpcywgbW92ZUludG8uY29udGVudEJveCwgaXNNb3ZpbmcpKTtcblxudmFyIHdoZW5SZW9yZGVyaW5nID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZSxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBpbnNpZGVEZXN0aW5hdGlvbiA9IGdldERyYWdnYWJsZXNJbnNpZGVEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBkcmFnZ2FibGVQYWdlID0gZHJhZ2dhYmxlLnBhZ2U7XG4gIGNvbnN0IGF4aXMgPSBkcm9wcGFibGUuYXhpcztcbiAgaWYgKCFpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ29JbnRvU3RhcnQoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVJbnRvOiBkcm9wcGFibGUucGFnZSxcbiAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpc3BsYWNlZCxcbiAgICBkaXNwbGFjZWRCeVxuICB9ID0gaW1wYWN0O1xuICBjb25zdCBjbG9zZXN0QWZ0ZXIgPSBkaXNwbGFjZWQuYWxsWzBdO1xuICBpZiAoY2xvc2VzdEFmdGVyKSB7XG4gICAgY29uc3QgY2xvc2VzdCA9IGRyYWdnYWJsZXNbY2xvc2VzdEFmdGVyXTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGNsb3Nlc3RBZnRlciwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICAgIHJldHVybiBnb0JlZm9yZSh7XG4gICAgICAgIGF4aXMsXG4gICAgICAgIG1vdmVSZWxhdGl2ZVRvOiBjbG9zZXN0LnBhZ2UsXG4gICAgICAgIGlzTW92aW5nOiBkcmFnZ2FibGVQYWdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aERpc3BsYWNlbWVudCA9IG9mZnNldChjbG9zZXN0LnBhZ2UsIGRpc3BsYWNlZEJ5LnBvaW50KTtcbiAgICByZXR1cm4gZ29CZWZvcmUoe1xuICAgICAgYXhpcyxcbiAgICAgIG1vdmVSZWxhdGl2ZVRvOiB3aXRoRGlzcGxhY2VtZW50LFxuICAgICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsYXN0ID0gaW5zaWRlRGVzdGluYXRpb25baW5zaWRlRGVzdGluYXRpb24ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0LmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgcmV0dXJuIGRyYWdnYWJsZVBhZ2UuYm9yZGVyQm94LmNlbnRlcjtcbiAgfVxuICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsKGxhc3QuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkpIHtcbiAgICBjb25zdCBwYWdlID0gb2Zmc2V0KGxhc3QucGFnZSwgbmVnYXRlKGFmdGVyQ3JpdGljYWwuZGlzcGxhY2VkQnkucG9pbnQpKTtcbiAgICByZXR1cm4gZ29BZnRlcih7XG4gICAgICBheGlzLFxuICAgICAgbW92ZVJlbGF0aXZlVG86IHBhZ2UsXG4gICAgICBpc01vdmluZzogZHJhZ2dhYmxlUGFnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBnb0FmdGVyKHtcbiAgICBheGlzLFxuICAgIG1vdmVSZWxhdGl2ZVRvOiBsYXN0LnBhZ2UsXG4gICAgaXNNb3Zpbmc6IGRyYWdnYWJsZVBhZ2VcbiAgfSk7XG59O1xuXG52YXIgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCA9IChkcm9wcGFibGUsIHBvaW50KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIHJldHVybiBhZGQocG9pbnQsIGZyYW1lLnNjcm9sbC5kaWZmLmRpc3BsYWNlbWVudCk7XG59O1xuXG5jb25zdCBnZXRSZXN1bHRXaXRob3V0RHJvcHBhYmxlRGlzcGxhY2VtZW50ID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRyb3BwYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveC5jZW50ZXI7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWRyb3BwYWJsZSkge1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIGlmIChhdC50eXBlID09PSAnUkVPUkRFUicpIHtcbiAgICByZXR1cm4gd2hlblJlb3JkZXJpbmcoe1xuICAgICAgaW1wYWN0LFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGRyb3BwYWJsZSxcbiAgICAgIGFmdGVyQ3JpdGljYWxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gd2hlbkNvbWJpbmluZyh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG52YXIgZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QgPSBhcmdzID0+IHtcbiAgY29uc3Qgd2l0aG91dERpc3BsYWNlbWVudCA9IGdldFJlc3VsdFdpdGhvdXREcm9wcGFibGVEaXNwbGFjZW1lbnQoYXJncyk7XG4gIGNvbnN0IGRyb3BwYWJsZSA9IGFyZ3MuZHJvcHBhYmxlO1xuICBjb25zdCB3aXRoRGlzcGxhY2VtZW50ID0gZHJvcHBhYmxlID8gd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudChkcm9wcGFibGUsIHdpdGhvdXREaXNwbGFjZW1lbnQpIDogd2l0aG91dERpc3BsYWNlbWVudDtcbiAgcmV0dXJuIHdpdGhEaXNwbGFjZW1lbnQ7XG59O1xuXG52YXIgc2Nyb2xsVmlld3BvcnQgPSAodmlld3BvcnQsIG5ld1Njcm9sbCkgPT4ge1xuICBjb25zdCBkaWZmID0gc3VidHJhY3QobmV3U2Nyb2xsLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IG5lZ2F0ZShkaWZmKTtcbiAgY29uc3QgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3A6IG5ld1Njcm9sbC55LFxuICAgIGJvdHRvbTogbmV3U2Nyb2xsLnkgKyB2aWV3cG9ydC5mcmFtZS5oZWlnaHQsXG4gICAgbGVmdDogbmV3U2Nyb2xsLngsXG4gICAgcmlnaHQ6IG5ld1Njcm9sbC54ICsgdmlld3BvcnQuZnJhbWUud2lkdGhcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgZnJhbWUsXG4gICAgc2Nyb2xsOiB7XG4gICAgICBpbml0aWFsOiB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCxcbiAgICAgIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgICAgIGN1cnJlbnQ6IG5ld1Njcm9sbCxcbiAgICAgIGRpZmY6IHtcbiAgICAgICAgdmFsdWU6IGRpZmYsXG4gICAgICAgIGRpc3BsYWNlbWVudFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZWQ7XG59O1xuXG5mdW5jdGlvbiBnZXREcmFnZ2FibGVzJDEoaWRzLCBkcmFnZ2FibGVzKSB7XG4gIHJldHVybiBpZHMubWFwKGlkID0+IGRyYWdnYWJsZXNbaWRdKTtcbn1cbmZ1bmN0aW9uIHRyeUdldFZpc2libGUoaWQsIGdyb3Vwcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IGdyb3Vwc1tpXS52aXNpYmxlW2lkXTtcbiAgICBpZiAoZGlzcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBzcGVjdWxhdGl2ZWx5SW5jcmVhc2UgPSAoe1xuICBpbXBhY3QsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlcyxcbiAgbWF4U2Nyb2xsQ2hhbmdlXG59KSA9PiB7XG4gIGNvbnN0IHNjcm9sbGVkVmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydCh2aWV3cG9ydCwgYWRkKHZpZXdwb3J0LnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKTtcbiAgY29uc3Qgc2Nyb2xsZWREcm9wcGFibGUgPSBkZXN0aW5hdGlvbi5mcmFtZSA/IHNjcm9sbERyb3BwYWJsZShkZXN0aW5hdGlvbiwgYWRkKGRlc3RpbmF0aW9uLmZyYW1lLnNjcm9sbC5jdXJyZW50LCBtYXhTY3JvbGxDaGFuZ2UpKSA6IGRlc3RpbmF0aW9uO1xuICBjb25zdCBsYXN0ID0gaW1wYWN0LmRpc3BsYWNlZDtcbiAgY29uc3Qgd2l0aFZpZXdwb3J0U2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHNjcm9sbGVkVmlld3BvcnQuZnJhbWUsXG4gICAgbGFzdCxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCB3aXRoRHJvcHBhYmxlU2Nyb2xsID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nOiBnZXREcmFnZ2FibGVzJDEobGFzdC5hbGwsIGRyYWdnYWJsZXMpLFxuICAgIGRlc3RpbmF0aW9uOiBzY3JvbGxlZERyb3BwYWJsZSxcbiAgICBkaXNwbGFjZWRCeTogaW1wYWN0LmRpc3BsYWNlZEJ5LFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBsYXN0LFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGludmlzaWJsZSA9IHt9O1xuICBjb25zdCB2aXNpYmxlID0ge307XG4gIGNvbnN0IGdyb3VwcyA9IFtsYXN0LCB3aXRoVmlld3BvcnRTY3JvbGwsIHdpdGhEcm9wcGFibGVTY3JvbGxdO1xuICBsYXN0LmFsbC5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0cnlHZXRWaXNpYmxlKGlkLCBncm91cHMpO1xuICAgIGlmIChkaXNwbGFjZW1lbnQpIHtcbiAgICAgIHZpc2libGVbaWRdID0gZGlzcGxhY2VtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZpc2libGVbaWRdID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IG5ld0ltcGFjdCA9IHtcbiAgICAuLi5pbXBhY3QsXG4gICAgZGlzcGxhY2VkOiB7XG4gICAgICBhbGw6IGxhc3QuYWxsLFxuICAgICAgaW52aXNpYmxlLFxuICAgICAgdmlzaWJsZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG5ld0ltcGFjdDtcbn07XG5cbnZhciB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQgPSAodmlld3BvcnQsIHBvaW50KSA9PiBhZGQodmlld3BvcnQuc2Nyb2xsLmRpZmYuZGlzcGxhY2VtZW50LCBwb2ludCk7XG5cbnZhciBnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIGRyYWdnYWJsZSxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3Qgd2l0aG91dFBhZ2VTY3JvbGxDaGFuZ2UgPSB3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQodmlld3BvcnQsIHBhZ2VCb3JkZXJCb3hDZW50ZXIpO1xuICBjb25zdCBvZmZzZXQgPSBzdWJ0cmFjdCh3aXRob3V0UGFnZVNjcm9sbENoYW5nZSwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIHJldHVybiBhZGQoZHJhZ2dhYmxlLmNsaWVudC5ib3JkZXJCb3guY2VudGVyLCBvZmZzZXQpO1xufTtcblxudmFyIGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBkZXN0aW5hdGlvbixcbiAgbmV3UGFnZUJvcmRlckJveENlbnRlcixcbiAgdmlld3BvcnQsXG4gIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQsXG4gIG9ubHlPbk1haW5BeGlzID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgY2hhbmdlTmVlZGVkID0gc3VidHJhY3QobmV3UGFnZUJvcmRlckJveENlbnRlciwgZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LmNlbnRlcik7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBvZmZzZXRCeVBvc2l0aW9uKGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveCwgY2hhbmdlTmVlZGVkKTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICB0YXJnZXQ6IHNoaWZ0ZWQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCxcbiAgICB2aWV3cG9ydFxuICB9O1xuICByZXR1cm4gb25seU9uTWFpbkF4aXMgPyBpc1RvdGFsbHlWaXNpYmxlT25BeGlzKGFyZ3MpIDogaXNUb3RhbGx5VmlzaWJsZShhcmdzKTtcbn07XG5cbnZhciBtb3ZlVG9OZXh0UGxhY2UgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIGRyYWdnYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyLFxuICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgaXNJbkhvbWVMaXN0ID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbik7XG4gIGNvbnN0IGltcGFjdCA9IG1vdmVUb05leHRDb21iaW5lKHtcbiAgICBpc01vdmluZ0ZvcndhcmQsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0XG4gIH0pIHx8IG1vdmVUb05leHRJbmRleCh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIGlzSW5Ib21lTGlzdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiA9IGlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uKHtcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb24sXG4gICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydDogdmlld3BvcnQuZnJhbWUsXG4gICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgb25seU9uTWFpbkF4aXM6IHRydWVcbiAgfSk7XG4gIGlmIChpc1Zpc2libGVJbk5ld0xvY2F0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgICAgcGFnZUJvcmRlckJveENlbnRlcixcbiAgICAgIGRyYWdnYWJsZSxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgIGltcGFjdCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCBkaXN0YW5jZSA9IHN1YnRyYWN0KHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcik7XG4gIGNvbnN0IGNhdXRpb3VzID0gc3BlY3VsYXRpdmVseUluY3JlYXNlKHtcbiAgICBpbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgZGVzdGluYXRpb24sXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBtYXhTY3JvbGxDaGFuZ2U6IGRpc3RhbmNlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbjogcHJldmlvdXNDbGllbnRTZWxlY3Rpb24sXG4gICAgaW1wYWN0OiBjYXV0aW91cyxcbiAgICBzY3JvbGxKdW1wUmVxdWVzdDogZGlzdGFuY2VcbiAgfTtcbn07XG5cbmNvbnN0IGdldEtub3duQWN0aXZlID0gZHJvcHBhYmxlID0+IHtcbiAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZTtcbiAgIXJlY3QgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZ2V0IGNsaXBwZWQgYXJlYSBmcm9tIGRyb3BwYWJsZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiByZWN0O1xufTtcbnZhciBnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlID0gKHtcbiAgaXNNb3ZpbmdGb3J3YXJkLFxuICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICBzb3VyY2UsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGFjdGl2ZSA9IHNvdXJjZS5zdWJqZWN0LmFjdGl2ZTtcbiAgaWYgKCFhY3RpdmUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gc291cmNlLmF4aXM7XG4gIGNvbnN0IGlzQmV0d2VlblNvdXJjZUNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5zdGFydF0sIGFjdGl2ZVtheGlzLmVuZF0pO1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlICE9PSBzb3VyY2UpLmZpbHRlcihkcm9wcGFibGUgPT4gZHJvcHBhYmxlLmlzRW5hYmxlZCkuZmlsdGVyKGRyb3BwYWJsZSA9PiBCb29sZWFuKGRyb3BwYWJsZS5zdWJqZWN0LmFjdGl2ZSkpLmZpbHRlcihkcm9wcGFibGUgPT4gaXNQYXJ0aWFsbHlWaXNpYmxlVGhyb3VnaEZyYW1lKHZpZXdwb3J0LmZyYW1lKShnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpKSkuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgYWN0aXZlT2ZUYXJnZXQgPSBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpO1xuICAgIGlmIChpc01vdmluZ0ZvcndhcmQpIHtcbiAgICAgIHJldHVybiBhY3RpdmVbYXhpcy5jcm9zc0F4aXNFbmRdIDwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNFbmRdO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlT2ZUYXJnZXRbYXhpcy5jcm9zc0F4aXNTdGFydF0gPCBhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gIH0pLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZU9mVGFyZ2V0ID0gZ2V0S25vd25BY3RpdmUoZHJvcHBhYmxlKTtcbiAgICBjb25zdCBpc0JldHdlZW5EZXN0aW5hdGlvbkNsaXBwZWQgPSBpc1dpdGhpbihhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSwgYWN0aXZlT2ZUYXJnZXRbYXhpcy5lbmRdKTtcbiAgICByZXR1cm4gaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLnN0YXJ0XSkgfHwgaXNCZXR3ZWVuU291cmNlQ2xpcHBlZChhY3RpdmVPZlRhcmdldFtheGlzLmVuZF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5zdGFydF0pIHx8IGlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZChhY3RpdmVbYXhpcy5lbmRdKTtcbiAgfSkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IGZpcnN0ID0gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3Qgc2Vjb25kID0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgaWYgKGlzTW92aW5nRm9yd2FyZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gc2Vjb25kIC0gZmlyc3Q7XG4gIH0pLmZpbHRlcigoZHJvcHBhYmxlLCBpbmRleCwgYXJyYXkpID0+IGdldEtub3duQWN0aXZlKGRyb3BwYWJsZSlbYXhpcy5jcm9zc0F4aXNTdGFydF0gPT09IGdldEtub3duQWN0aXZlKGFycmF5WzBdKVtheGlzLmNyb3NzQXhpc1N0YXJ0XSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXTtcbiAgfVxuICBjb25zdCBjb250YWlucyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGRyb3BwYWJsZSA9PiB7XG4gICAgY29uc3QgaXNXaXRoaW5Ecm9wcGFibGUgPSBpc1dpdGhpbihnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuc3RhcnRdLCBnZXRLbm93bkFjdGl2ZShkcm9wcGFibGUpW2F4aXMuZW5kXSk7XG4gICAgcmV0dXJuIGlzV2l0aGluRHJvcHBhYmxlKHBhZ2VCb3JkZXJCb3hDZW50ZXJbYXhpcy5saW5lXSk7XG4gIH0pO1xuICBpZiAoY29udGFpbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWzBdO1xuICB9XG4gIGlmIChjb250YWlucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zLnNvcnQoKGEsIGIpID0+IGdldEtub3duQWN0aXZlKGEpW2F4aXMuc3RhcnRdIC0gZ2V0S25vd25BY3RpdmUoYilbYXhpcy5zdGFydF0pWzBdO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBmaXJzdCA9IGNsb3Nlc3QkMShwYWdlQm9yZGVyQm94Q2VudGVyLCBnZXRDb3JuZXJzKGdldEtub3duQWN0aXZlKGEpKSk7XG4gICAgY29uc3Qgc2Vjb25kID0gY2xvc2VzdCQxKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIGdldENvcm5lcnMoZ2V0S25vd25BY3RpdmUoYikpKTtcbiAgICBpZiAoZmlyc3QgIT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0IC0gc2Vjb25kO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0S25vd25BY3RpdmUoYSlbYXhpcy5zdGFydF0gLSBnZXRLbm93bkFjdGl2ZShiKVtheGlzLnN0YXJ0XTtcbiAgfSlbMF07XG59O1xuXG5jb25zdCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlciA9IChkcmFnZ2FibGUsIGFmdGVyQ3JpdGljYWwpID0+IHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICByZXR1cm4gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkLCBhZnRlckNyaXRpY2FsKSA/IHN1YnRyYWN0KG9yaWdpbmFsLCBhZnRlckNyaXRpY2FsLmRpc3BsYWNlZEJ5LnBvaW50KSA6IG9yaWdpbmFsO1xufTtcbmNvbnN0IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94ID0gKGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbCA9IGRyYWdnYWJsZS5wYWdlLmJvcmRlckJveDtcbiAgcmV0dXJuIGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChkcmFnZ2FibGUuZGVzY3JpcHRvci5pZCwgYWZ0ZXJDcml0aWNhbCkgPyBvZmZzZXRCeVBvc2l0aW9uKG9yaWdpbmFsLCBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCkpIDogb3JpZ2luYWw7XG59O1xuXG52YXIgZ2V0Q2xvc2VzdERyYWdnYWJsZSA9ICh7XG4gIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIHZpZXdwb3J0LFxuICBkZXN0aW5hdGlvbixcbiAgaW5zaWRlRGVzdGluYXRpb24sXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgY29uc3Qgc29ydGVkID0gaW5zaWRlRGVzdGluYXRpb24uZmlsdGVyKGRyYWdnYWJsZSA9PiBpc1RvdGFsbHlWaXNpYmxlKHtcbiAgICB0YXJnZXQ6IGdldEN1cnJlbnRQYWdlQm9yZGVyQm94KGRyYWdnYWJsZSwgYWZ0ZXJDcml0aWNhbCksXG4gICAgZGVzdGluYXRpb24sXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQ6IHRydWVcbiAgfSkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZVRvQSA9IGRpc3RhbmNlKHBhZ2VCb3JkZXJCb3hDZW50ZXIsIHdpdGhEcm9wcGFibGVEaXNwbGFjZW1lbnQoZGVzdGluYXRpb24sIGdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyKGEsIGFmdGVyQ3JpdGljYWwpKSk7XG4gICAgY29uc3QgZGlzdGFuY2VUb0IgPSBkaXN0YW5jZShwYWdlQm9yZGVyQm94Q2VudGVyLCB3aXRoRHJvcHBhYmxlRGlzcGxhY2VtZW50KGRlc3RpbmF0aW9uLCBnZXRDdXJyZW50UGFnZUJvcmRlckJveENlbnRlcihiLCBhZnRlckNyaXRpY2FsKSkpO1xuICAgIGlmIChkaXN0YW5jZVRvQSA8IGRpc3RhbmNlVG9CKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZVRvQiA8IGRpc3RhbmNlVG9BKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGEuZGVzY3JpcHRvci5pbmRleCAtIGIuZGVzY3JpcHRvci5pbmRleDtcbiAgfSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gfHwgbnVsbDtcbn07XG5cbnZhciBnZXREaXNwbGFjZWRCeSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gZ2V0RGlzcGxhY2VkQnkoYXhpcywgZGlzcGxhY2VCeSkge1xuICBjb25zdCBkaXNwbGFjZW1lbnQgPSBkaXNwbGFjZUJ5W2F4aXMubGluZV07XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGRpc3BsYWNlbWVudCxcbiAgICBwb2ludDogcGF0Y2goYXhpcy5saW5lLCBkaXNwbGFjZW1lbnQpXG4gIH07XG59KTtcblxuY29uc3QgZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciA9IChkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcykgPT4ge1xuICBjb25zdCBheGlzID0gZHJvcHBhYmxlLmF4aXM7XG4gIGlmIChkcm9wcGFibGUuZGVzY3JpcHRvci5tb2RlID09PSAndmlydHVhbCcpIHtcbiAgICByZXR1cm4gcGF0Y2goYXhpcy5saW5lLCBwbGFjZWhvbGRlclNpemVbYXhpcy5saW5lXSk7XG4gIH1cbiAgY29uc3QgYXZhaWxhYmxlU3BhY2UgPSBkcm9wcGFibGUuc3ViamVjdC5wYWdlLmNvbnRlbnRCb3hbYXhpcy5zaXplXTtcbiAgY29uc3QgaW5zaWRlRHJvcHBhYmxlID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHNwYWNlVXNlZCA9IGluc2lkZURyb3BwYWJsZS5yZWR1Y2UoKHN1bSwgZGltZW5zaW9uKSA9PiBzdW0gKyBkaW1lbnNpb24uY2xpZW50Lm1hcmdpbkJveFtheGlzLnNpemVdLCAwKTtcbiAgY29uc3QgcmVxdWlyZWRTcGFjZSA9IHNwYWNlVXNlZCArIHBsYWNlaG9sZGVyU2l6ZVtheGlzLmxpbmVdO1xuICBjb25zdCBuZWVkc1RvR3Jvd0J5ID0gcmVxdWlyZWRTcGFjZSAtIGF2YWlsYWJsZVNwYWNlO1xuICBpZiAobmVlZHNUb0dyb3dCeSA8PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGNoKGF4aXMubGluZSwgbmVlZHNUb0dyb3dCeSk7XG59O1xuY29uc3Qgd2l0aE1heFNjcm9sbCA9IChmcmFtZSwgbWF4KSA9PiAoe1xuICAuLi5mcmFtZSxcbiAgc2Nyb2xsOiB7XG4gICAgLi4uZnJhbWUuc2Nyb2xsLFxuICAgIG1heFxuICB9XG59KTtcbmNvbnN0IGFkZFBsYWNlaG9sZGVyID0gKGRyb3BwYWJsZSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVzKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICAhIWlzSG9tZU9mKGRyYWdnYWJsZSwgZHJvcHBhYmxlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBub3QgYWRkIHBsYWNlaG9sZGVyIHNwYWNlIHRvIGhvbWUgbGlzdCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEhZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGFkZCBwbGFjZWhvbGRlciBzaXplIHRvIGEgc3ViamVjdCB3aGVuIGl0IGFscmVhZHkgaGFzIG9uZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHBsYWNlaG9sZGVyU2l6ZSA9IGdldERpc3BsYWNlZEJ5KGRyb3BwYWJsZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSkucG9pbnQ7XG4gIGNvbnN0IHJlcXVpcmVkR3Jvd3RoID0gZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlcihkcm9wcGFibGUsIHBsYWNlaG9sZGVyU2l6ZSwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IGFkZGVkID0ge1xuICAgIHBsYWNlaG9sZGVyU2l6ZSxcbiAgICBpbmNyZWFzZWRCeTogcmVxdWlyZWRHcm93dGgsXG4gICAgb2xkRnJhbWVNYXhTY3JvbGw6IGRyb3BwYWJsZS5mcmFtZSA/IGRyb3BwYWJsZS5mcmFtZS5zY3JvbGwubWF4IDogbnVsbFxuICB9O1xuICBpZiAoIWZyYW1lKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogYWRkZWQsXG4gICAgICBheGlzOiBkcm9wcGFibGUuYXhpcyxcbiAgICAgIGZyYW1lOiBkcm9wcGFibGUuZnJhbWVcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZHJvcHBhYmxlLFxuICAgICAgc3ViamVjdFxuICAgIH07XG4gIH1cbiAgY29uc3QgbWF4U2Nyb2xsID0gcmVxdWlyZWRHcm93dGggPyBhZGQoZnJhbWUuc2Nyb2xsLm1heCwgcmVxdWlyZWRHcm93dGgpIDogZnJhbWUuc2Nyb2xsLm1heDtcbiAgY29uc3QgbmV3RnJhbWUgPSB3aXRoTWF4U2Nyb2xsKGZyYW1lLCBtYXhTY3JvbGwpO1xuICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgcGFnZTogZHJvcHBhYmxlLnN1YmplY3QucGFnZSxcbiAgICB3aXRoUGxhY2Vob2xkZXI6IGFkZGVkLFxuICAgIGF4aXM6IGRyb3BwYWJsZS5heGlzLFxuICAgIGZyYW1lOiBuZXdGcmFtZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfTtcbn07XG5jb25zdCByZW1vdmVQbGFjZWhvbGRlciA9IGRyb3BwYWJsZSA9PiB7XG4gIGNvbnN0IGFkZGVkID0gZHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyO1xuICAhYWRkZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcmVtb3ZlIHBsYWNlaG9sZGVyIGZvcm0gc3ViamVjdCB3aGVuIHRoZXJlIHdhcyBub25lJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gZ2V0U3ViamVjdCh7XG4gICAgICBwYWdlOiBkcm9wcGFibGUuc3ViamVjdC5wYWdlLFxuICAgICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgICBmcmFtZTogbnVsbCxcbiAgICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcm9wcGFibGUsXG4gICAgICBzdWJqZWN0XG4gICAgfTtcbiAgfVxuICBjb25zdCBvbGRNYXhTY3JvbGwgPSBhZGRlZC5vbGRGcmFtZU1heFNjcm9sbDtcbiAgIW9sZE1heFNjcm9sbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyb3BwYWJsZSB3aXRoIGZyYW1lIHRvIGhhdmUgb2xkIG1heCBmcmFtZSBzY3JvbGwgd2hlbiByZW1vdmluZyBwbGFjZWhvbGRlcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IG5ld0ZyYW1lID0gd2l0aE1heFNjcm9sbChmcmFtZSwgb2xkTWF4U2Nyb2xsKTtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2U6IGRyb3BwYWJsZS5zdWJqZWN0LnBhZ2UsXG4gICAgYXhpczogZHJvcHBhYmxlLmF4aXMsXG4gICAgZnJhbWU6IG5ld0ZyYW1lLFxuICAgIHdpdGhQbGFjZWhvbGRlcjogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBmcmFtZTogbmV3RnJhbWVcbiAgfTtcbn07XG5cbnZhciBtb3ZlVG9OZXdEcm9wcGFibGUgPSAoe1xuICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gIG1vdmVSZWxhdGl2ZVRvLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgZHJhZ2dhYmxlLFxuICBkcmFnZ2FibGVzLFxuICBkZXN0aW5hdGlvbixcbiAgdmlld3BvcnQsXG4gIGFmdGVyQ3JpdGljYWxcbn0pID0+IHtcbiAgaWYgKCFtb3ZlUmVsYXRpdmVUbykge1xuICAgIGlmIChpbnNpZGVEZXN0aW5hdGlvbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9wb3NlZCA9IHtcbiAgICAgIGRpc3BsYWNlZDogZW1wdHlHcm91cHMsXG4gICAgICBkaXNwbGFjZWRCeTogbm9EaXNwbGFjZWRCeSxcbiAgICAgIGF0OiB7XG4gICAgICAgIHR5cGU6ICdSRU9SREVSJyxcbiAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogZGVzdGluYXRpb24uZGVzY3JpcHRvci5pZCxcbiAgICAgICAgICBpbmRleDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9wb3NlZFBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgICBpbXBhY3Q6IHByb3Bvc2VkLFxuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgZHJvcHBhYmxlOiBkZXN0aW5hdGlvbixcbiAgICAgIGRyYWdnYWJsZXMsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSk7XG4gICAgY29uc3Qgd2l0aFBsYWNlaG9sZGVyID0gaXNIb21lT2YoZHJhZ2dhYmxlLCBkZXN0aW5hdGlvbikgPyBkZXN0aW5hdGlvbiA6IGFkZFBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCBkcmFnZ2FibGUsIGRyYWdnYWJsZXMpO1xuICAgIGNvbnN0IGlzVmlzaWJsZUluTmV3TG9jYXRpb24gPSBpc1RvdGFsbHlWaXNpYmxlSW5OZXdMb2NhdGlvbih7XG4gICAgICBkcmFnZ2FibGUsXG4gICAgICBkZXN0aW5hdGlvbjogd2l0aFBsYWNlaG9sZGVyLFxuICAgICAgbmV3UGFnZUJvcmRlckJveENlbnRlcjogcHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgICAgd2l0aERyb3BwYWJsZURpc3BsYWNlbWVudDogZmFsc2UsXG4gICAgICBvbmx5T25NYWluQXhpczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBpc1Zpc2libGVJbk5ld0xvY2F0aW9uID8gcHJvcG9zZWQgOiBudWxsO1xuICB9XG4gIGNvbnN0IGlzR29pbmdCZWZvcmVUYXJnZXQgPSBCb29sZWFuKHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdIDw9IG1vdmVSZWxhdGl2ZVRvLnBhZ2UuYm9yZGVyQm94LmNlbnRlcltkZXN0aW5hdGlvbi5heGlzLmxpbmVdKTtcbiAgY29uc3QgcHJvcG9zZWRJbmRleCA9ICgoKSA9PiB7XG4gICAgY29uc3QgcmVsYXRpdmVUbyA9IG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaW5kZXg7XG4gICAgaWYgKG1vdmVSZWxhdGl2ZVRvLmRlc2NyaXB0b3IuaWQgPT09IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmlkKSB7XG4gICAgICByZXR1cm4gcmVsYXRpdmVUbztcbiAgICB9XG4gICAgaWYgKGlzR29pbmdCZWZvcmVUYXJnZXQpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVUbyArIDE7XG4gIH0pKCk7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoZGVzdGluYXRpb24uYXhpcywgZHJhZ2dhYmxlLmRpc3BsYWNlQnkpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVvcmRlckltcGFjdCh7XG4gICAgZHJhZ2dhYmxlLFxuICAgIGluc2lkZURlc3RpbmF0aW9uLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIHZpZXdwb3J0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGxhc3Q6IGVtcHR5R3JvdXBzLFxuICAgIGluZGV4OiBwcm9wb3NlZEluZGV4XG4gIH0pO1xufTtcblxudmFyIG1vdmVDcm9zc0F4aXMgPSAoe1xuICBpc01vdmluZ0ZvcndhcmQsXG4gIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgZHJhZ2dhYmxlLFxuICBpc092ZXIsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gZ2V0QmVzdENyb3NzQXhpc0Ryb3BwYWJsZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBzb3VyY2U6IGlzT3ZlcixcbiAgICBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGRlc3RpbmF0aW9uLmRlc2NyaXB0b3IuaWQsIGRyYWdnYWJsZXMpO1xuICBjb25zdCBtb3ZlUmVsYXRpdmVUbyA9IGdldENsb3Nlc3REcmFnZ2FibGUoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXI6IHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICB2aWV3cG9ydCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBjb25zdCBpbXBhY3QgPSBtb3ZlVG9OZXdEcm9wcGFibGUoe1xuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkZXN0aW5hdGlvbixcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBtb3ZlUmVsYXRpdmVUbyxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pO1xuICBpZiAoIWltcGFjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHBhZ2VCb3JkZXJCb3hDZW50ZXIgPSBnZXRQYWdlQm9yZGVyQm94Q2VudGVyRnJvbUltcGFjdCh7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgY29uc3QgY2xpZW50U2VsZWN0aW9uID0gZ2V0Q2xpZW50RnJvbVBhZ2VCb3JkZXJCb3hDZW50ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBpbXBhY3QsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgfTtcbn07XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlciA9IGltcGFjdCA9PiB7XG4gIGNvbnN0IGF0ID0gaW1wYWN0LmF0O1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiBhdC5kZXN0aW5hdGlvbi5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gYXQuY29tYmluZS5kcm9wcGFibGVJZDtcbn07XG5cbmNvbnN0IGdldERyb3BwYWJsZU92ZXIkMSA9IChpbXBhY3QsIGRyb3BwYWJsZXMpID0+IHtcbiAgY29uc3QgaWQgPSB3aGF0SXNEcmFnZ2VkT3ZlcihpbXBhY3QpO1xuICByZXR1cm4gaWQgPyBkcm9wcGFibGVzW2lkXSA6IG51bGw7XG59O1xudmFyIG1vdmVJbkRpcmVjdGlvbiA9ICh7XG4gIHN0YXRlLFxuICB0eXBlXG59KSA9PiB7XG4gIGNvbnN0IGlzQWN0dWFsbHlPdmVyID0gZ2V0RHJvcHBhYmxlT3ZlciQxKHN0YXRlLmltcGFjdCwgc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzKTtcbiAgY29uc3QgaXNNYWluQXhpc01vdmVtZW50QWxsb3dlZCA9IEJvb2xlYW4oaXNBY3R1YWxseU92ZXIpO1xuICBjb25zdCBob21lID0gc3RhdGUuZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IGlzT3ZlciA9IGlzQWN0dWFsbHlPdmVyIHx8IGhvbWU7XG4gIGNvbnN0IGRpcmVjdGlvbiA9IGlzT3Zlci5heGlzLmRpcmVjdGlvbjtcbiAgY29uc3QgaXNNb3ZpbmdPbk1haW5BeGlzID0gZGlyZWN0aW9uID09PSAndmVydGljYWwnICYmICh0eXBlID09PSAnTU9WRV9VUCcgfHwgdHlwZSA9PT0gJ01PVkVfRE9XTicpIHx8IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmICh0eXBlID09PSAnTU9WRV9MRUZUJyB8fCB0eXBlID09PSAnTU9WRV9SSUdIVCcpO1xuICBpZiAoaXNNb3ZpbmdPbk1haW5BeGlzICYmICFpc01haW5BeGlzTW92ZW1lbnRBbGxvd2VkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaXNNb3ZpbmdGb3J3YXJkID0gdHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgdHlwZSA9PT0gJ01PVkVfUklHSFQnO1xuICBjb25zdCBkcmFnZ2FibGUgPSBzdGF0ZS5kaW1lbnNpb25zLmRyYWdnYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbiAgY29uc3QgcHJldmlvdXNQYWdlQm9yZGVyQm94Q2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gc3RhdGUuZGltZW5zaW9ucztcbiAgcmV0dXJuIGlzTW92aW5nT25NYWluQXhpcyA/IG1vdmVUb05leHRQbGFjZSh7XG4gICAgaXNNb3ZpbmdGb3J3YXJkLFxuICAgIHByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlcixcbiAgICBkcmFnZ2FibGUsXG4gICAgZGVzdGluYXRpb246IGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydCxcbiAgICBwcmV2aW91c0NsaWVudFNlbGVjdGlvbjogc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLFxuICAgIHByZXZpb3VzSW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KSA6IG1vdmVDcm9zc0F4aXMoe1xuICAgIGlzTW92aW5nRm9yd2FyZCxcbiAgICBwcmV2aW91c1BhZ2VCb3JkZXJCb3hDZW50ZXIsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGlzT3ZlcixcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycgfHwgc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJztcbn1cblxuZnVuY3Rpb24gaXNQb3NpdGlvbkluRnJhbWUoZnJhbWUpIHtcbiAgY29uc3QgaXNXaXRoaW5WZXJ0aWNhbCA9IGlzV2l0aGluKGZyYW1lLnRvcCwgZnJhbWUuYm90dG9tKTtcbiAgY29uc3QgaXNXaXRoaW5Ib3Jpem9udGFsID0gaXNXaXRoaW4oZnJhbWUubGVmdCwgZnJhbWUucmlnaHQpO1xuICByZXR1cm4gZnVuY3Rpb24gcnVuKHBvaW50KSB7XG4gICAgcmV0dXJuIGlzV2l0aGluVmVydGljYWwocG9pbnQueSkgJiYgaXNXaXRoaW5Ib3Jpem9udGFsKHBvaW50LngpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNPdmVybGFwKGZpcnN0LCBzZWNvbmQpIHtcbiAgcmV0dXJuIGZpcnN0LmxlZnQgPCBzZWNvbmQucmlnaHQgJiYgZmlyc3QucmlnaHQgPiBzZWNvbmQubGVmdCAmJiBmaXJzdC50b3AgPCBzZWNvbmQuYm90dG9tICYmIGZpcnN0LmJvdHRvbSA+IHNlY29uZC50b3A7XG59XG5mdW5jdGlvbiBnZXRGdXJ0aGVzdEF3YXkoe1xuICBwYWdlQm9yZGVyQm94LFxuICBkcmFnZ2FibGUsXG4gIGNhbmRpZGF0ZXNcbn0pIHtcbiAgY29uc3Qgc3RhcnRDZW50ZXIgPSBkcmFnZ2FibGUucGFnZS5ib3JkZXJCb3guY2VudGVyO1xuICBjb25zdCBzb3J0ZWQgPSBjYW5kaWRhdGVzLm1hcChjYW5kaWRhdGUgPT4ge1xuICAgIGNvbnN0IGF4aXMgPSBjYW5kaWRhdGUuYXhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBwYXRjaChjYW5kaWRhdGUuYXhpcy5saW5lLCBwYWdlQm9yZGVyQm94LmNlbnRlcltheGlzLmxpbmVdLCBjYW5kaWRhdGUucGFnZS5ib3JkZXJCb3guY2VudGVyW2F4aXMuY3Jvc3NBeGlzTGluZV0pO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogY2FuZGlkYXRlLmRlc2NyaXB0b3IuaWQsXG4gICAgICBkaXN0YW5jZTogZGlzdGFuY2Uoc3RhcnRDZW50ZXIsIHRhcmdldClcbiAgICB9O1xuICB9KS5zb3J0KChhLCBiKSA9PiBiLmRpc3RhbmNlIC0gYS5kaXN0YW5jZSk7XG4gIHJldHVybiBzb3J0ZWRbMF0gPyBzb3J0ZWRbMF0uaWQgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RHJvcHBhYmxlT3Zlcih7XG4gIHBhZ2VCb3JkZXJCb3gsXG4gIGRyYWdnYWJsZSxcbiAgZHJvcHBhYmxlc1xufSkge1xuICBjb25zdCBjYW5kaWRhdGVzID0gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihpdGVtID0+IHtcbiAgICBpZiAoIWl0ZW0uaXNFbmFibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IGl0ZW0uc3ViamVjdC5hY3RpdmU7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFnZXRIYXNPdmVybGFwKHBhZ2VCb3JkZXJCb3gsIGFjdGl2ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzUG9zaXRpb25JbkZyYW1lKGFjdGl2ZSkocGFnZUJvcmRlckJveC5jZW50ZXIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGl0ZW0uYXhpcztcbiAgICBjb25zdCBjaGlsZENlbnRlciA9IGFjdGl2ZS5jZW50ZXJbYXhpcy5jcm9zc0F4aXNMaW5lXTtcbiAgICBjb25zdCBjcm9zc0F4aXNTdGFydCA9IHBhZ2VCb3JkZXJCb3hbYXhpcy5jcm9zc0F4aXNTdGFydF07XG4gICAgY29uc3QgY3Jvc3NBeGlzRW5kID0gcGFnZUJvcmRlckJveFtheGlzLmNyb3NzQXhpc0VuZF07XG4gICAgY29uc3QgaXNDb250YWluZWQgPSBpc1dpdGhpbihhY3RpdmVbYXhpcy5jcm9zc0F4aXNTdGFydF0sIGFjdGl2ZVtheGlzLmNyb3NzQXhpc0VuZF0pO1xuICAgIGNvbnN0IGlzU3RhcnRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNTdGFydCk7XG4gICAgY29uc3QgaXNFbmRDb250YWluZWQgPSBpc0NvbnRhaW5lZChjcm9zc0F4aXNFbmQpO1xuICAgIGlmICghaXNTdGFydENvbnRhaW5lZCAmJiAhaXNFbmRDb250YWluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNTdGFydENvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIGNyb3NzQXhpc1N0YXJ0IDwgY2hpbGRDZW50ZXI7XG4gICAgfVxuICAgIHJldHVybiBjcm9zc0F4aXNFbmQgPiBjaGlsZENlbnRlcjtcbiAgfSk7XG4gIGlmICghY2FuZGlkYXRlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlc1swXS5kZXNjcmlwdG9yLmlkO1xuICB9XG4gIHJldHVybiBnZXRGdXJ0aGVzdEF3YXkoe1xuICAgIHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGNhbmRpZGF0ZXNcbiAgfSk7XG59XG5cbmNvbnN0IG9mZnNldFJlY3RCeVBvc2l0aW9uID0gKHJlY3QsIHBvaW50KSA9PiBnZXRSZWN0KG9mZnNldEJ5UG9zaXRpb24ocmVjdCwgcG9pbnQpKTtcblxudmFyIHdpdGhEcm9wcGFibGVTY3JvbGwgPSAoZHJvcHBhYmxlLCBhcmVhKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFJlY3RCeVBvc2l0aW9uKGFyZWEsIGZyYW1lLnNjcm9sbC5kaWZmLnZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGdldElzRGlzcGxhY2VkKHtcbiAgZGlzcGxhY2VkLFxuICBpZFxufSkge1xuICByZXR1cm4gQm9vbGVhbihkaXNwbGFjZWQudmlzaWJsZVtpZF0gfHwgZGlzcGxhY2VkLmludmlzaWJsZVtpZF0pO1xufVxuXG5mdW5jdGlvbiBhdEluZGV4KHtcbiAgZHJhZ2dhYmxlLFxuICBjbG9zZXN0LFxuICBpbkhvbWVMaXN0XG59KSB7XG4gIGlmICghY2xvc2VzdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaW5Ib21lTGlzdCkge1xuICAgIHJldHVybiBjbG9zZXN0LmRlc2NyaXB0b3IuaW5kZXg7XG4gIH1cbiAgaWYgKGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCA+IGRyYWdnYWJsZS5kZXNjcmlwdG9yLmluZGV4KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleCAtIDE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3QuZGVzY3JpcHRvci5pbmRleDtcbn1cbnZhciBnZXRSZW9yZGVySW1wYWN0ID0gKHtcbiAgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGw6IHRhcmdldFJlY3QsXG4gIGRyYWdnYWJsZSxcbiAgZGVzdGluYXRpb24sXG4gIGluc2lkZURlc3RpbmF0aW9uLFxuICBsYXN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY2xvc2VzdCA9IHdpdGhvdXREcmFnZ2luZy5maW5kKGNoaWxkID0+IHtcbiAgICBjb25zdCBpZCA9IGNoaWxkLmRlc2NyaXB0b3IuaWQ7XG4gICAgY29uc3QgY2hpbGRDZW50ZXIgPSBjaGlsZC5wYWdlLmJvcmRlckJveC5jZW50ZXJbYXhpcy5saW5lXTtcbiAgICBjb25zdCBkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSA9IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbChpZCwgYWZ0ZXJDcml0aWNhbCk7XG4gICAgY29uc3QgaXNEaXNwbGFjZWQgPSBnZXRJc0Rpc3BsYWNlZCh7XG4gICAgICBkaXNwbGFjZWQ6IGxhc3QsXG4gICAgICBpZFxuICAgIH0pO1xuICAgIGlmIChkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSkge1xuICAgICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRFbmQgPD0gY2hpbGRDZW50ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlciAtIGRpc3BsYWNlbWVudDtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGxhY2VkKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0RW5kIDw9IGNoaWxkQ2VudGVyICsgZGlzcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPCBjaGlsZENlbnRlcjtcbiAgfSkgfHwgbnVsbDtcbiAgY29uc3QgbmV3SW5kZXggPSBhdEluZGV4KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgY2xvc2VzdCxcbiAgICBpbkhvbWVMaXN0OiBpc0hvbWVPZihkcmFnZ2FibGUsIGRlc3RpbmF0aW9uKVxuICB9KTtcbiAgcmV0dXJuIGNhbGN1bGF0ZVJlb3JkZXJJbXBhY3Qoe1xuICAgIGRyYWdnYWJsZSxcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBkZXN0aW5hdGlvbixcbiAgICB2aWV3cG9ydCxcbiAgICBsYXN0LFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGluZGV4OiBuZXdJbmRleFxuICB9KTtcbn07XG5cbmNvbnN0IGNvbWJpbmVUaHJlc2hvbGREaXZpc29yID0gNDtcbnZhciBnZXRDb21iaW5lSW1wYWN0ID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBwYWdlQm9yZGVyQm94V2l0aERyb3BwYWJsZVNjcm9sbDogdGFyZ2V0UmVjdCxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGRlc3RpbmF0aW9uLFxuICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBpZiAoIWRlc3RpbmF0aW9uLmlzQ29tYmluZUVuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBheGlzID0gZGVzdGluYXRpb24uYXhpcztcbiAgY29uc3QgZGlzcGxhY2VkQnkgPSBnZXREaXNwbGFjZWRCeShkZXN0aW5hdGlvbi5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGRpc3BsYWNlbWVudCA9IGRpc3BsYWNlZEJ5LnZhbHVlO1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHRhcmdldFJlY3RbYXhpcy5zdGFydF07XG4gIGNvbnN0IHRhcmdldEVuZCA9IHRhcmdldFJlY3RbYXhpcy5lbmRdO1xuICBjb25zdCB3aXRob3V0RHJhZ2dpbmcgPSByZW1vdmVEcmFnZ2FibGVGcm9tTGlzdChkcmFnZ2FibGUsIGluc2lkZURlc3RpbmF0aW9uKTtcbiAgY29uc3QgY29tYmluZVdpdGggPSB3aXRob3V0RHJhZ2dpbmcuZmluZChjaGlsZCA9PiB7XG4gICAgY29uc3QgaWQgPSBjaGlsZC5kZXNjcmlwdG9yLmlkO1xuICAgIGNvbnN0IGNoaWxkUmVjdCA9IGNoaWxkLnBhZ2UuYm9yZGVyQm94O1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGNoaWxkUmVjdFtheGlzLnNpemVdO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNoaWxkU2l6ZSAvIGNvbWJpbmVUaHJlc2hvbGREaXZpc29yO1xuICAgIGNvbnN0IGRpZFN0YXJ0QWZ0ZXJDcml0aWNhbCQxID0gZGlkU3RhcnRBZnRlckNyaXRpY2FsKGlkLCBhZnRlckNyaXRpY2FsKTtcbiAgICBjb25zdCBpc0Rpc3BsYWNlZCA9IGdldElzRGlzcGxhY2VkKHtcbiAgICAgIGRpc3BsYWNlZDogcHJldmlvdXNJbXBhY3QuZGlzcGxhY2VkLFxuICAgICAgaWRcbiAgICB9KTtcbiAgICBpZiAoZGlkU3RhcnRBZnRlckNyaXRpY2FsJDEpIHtcbiAgICAgIGlmIChpc0Rpc3BsYWNlZCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0RW5kID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldEVuZCA8IGNoaWxkUmVjdFtheGlzLmVuZF0gLSB0aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0U3RhcnQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gLSBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0U3RhcnQgPCBjaGlsZFJlY3RbYXhpcy5lbmRdIC0gZGlzcGxhY2VtZW50IC0gdGhyZXNob2xkO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwbGFjZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbmQgPiBjaGlsZFJlY3RbYXhpcy5zdGFydF0gKyBkaXNwbGFjZW1lbnQgKyB0aHJlc2hvbGQgJiYgdGFyZ2V0RW5kIDwgY2hpbGRSZWN0W2F4aXMuZW5kXSArIGRpc3BsYWNlbWVudCAtIHRocmVzaG9sZDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFN0YXJ0ID4gY2hpbGRSZWN0W2F4aXMuc3RhcnRdICsgdGhyZXNob2xkICYmIHRhcmdldFN0YXJ0IDwgY2hpbGRSZWN0W2F4aXMuZW5kXSAtIHRocmVzaG9sZDtcbiAgfSk7XG4gIGlmICghY29tYmluZVdpdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkQnksXG4gICAgZGlzcGxhY2VkOiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgYXQ6IHtcbiAgICAgIHR5cGU6ICdDT01CSU5FJyxcbiAgICAgIGNvbWJpbmU6IHtcbiAgICAgICAgZHJhZ2dhYmxlSWQ6IGNvbWJpbmVXaXRoLmRlc2NyaXB0b3IuaWQsXG4gICAgICAgIGRyb3BwYWJsZUlkOiBkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gaW1wYWN0O1xufTtcblxudmFyIGdldERyYWdJbXBhY3QgPSAoe1xuICBwYWdlT2Zmc2V0LFxuICBkcmFnZ2FibGUsXG4gIGRyYWdnYWJsZXMsXG4gIGRyb3BwYWJsZXMsXG4gIHByZXZpb3VzSW1wYWN0LFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBwYWdlQm9yZGVyQm94ID0gb2Zmc2V0UmVjdEJ5UG9zaXRpb24oZHJhZ2dhYmxlLnBhZ2UuYm9yZGVyQm94LCBwYWdlT2Zmc2V0KTtcbiAgY29uc3QgZGVzdGluYXRpb25JZCA9IGdldERyb3BwYWJsZU92ZXIoe1xuICAgIHBhZ2VCb3JkZXJCb3gsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZGVzdGluYXRpb25JZCkge1xuICAgIHJldHVybiBub0ltcGFjdDtcbiAgfVxuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25JZF07XG4gIGNvbnN0IGluc2lkZURlc3RpbmF0aW9uID0gZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZShkZXN0aW5hdGlvbi5kZXNjcmlwdG9yLmlkLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgcGFnZUJvcmRlckJveFdpdGhEcm9wcGFibGVTY3JvbGwgPSB3aXRoRHJvcHBhYmxlU2Nyb2xsKGRlc3RpbmF0aW9uLCBwYWdlQm9yZGVyQm94KTtcbiAgcmV0dXJuIGdldENvbWJpbmVJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZSxcbiAgICBwcmV2aW91c0ltcGFjdCxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0pIHx8IGdldFJlb3JkZXJJbXBhY3Qoe1xuICAgIHBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsLFxuICAgIGRyYWdnYWJsZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBpbnNpZGVEZXN0aW5hdGlvbixcbiAgICBsYXN0OiBwcmV2aW91c0ltcGFjdC5kaXNwbGFjZWQsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbn07XG5cbnZhciBwYXRjaERyb3BwYWJsZU1hcCA9IChkcm9wcGFibGVzLCB1cGRhdGVkKSA9PiAoe1xuICAuLi5kcm9wcGFibGVzLFxuICBbdXBkYXRlZC5kZXNjcmlwdG9yLmlkXTogdXBkYXRlZFxufSk7XG5cbmNvbnN0IGNsZWFyVW51c2VkUGxhY2Vob2xkZXIgPSAoe1xuICBwcmV2aW91c0ltcGFjdCxcbiAgaW1wYWN0LFxuICBkcm9wcGFibGVzXG59KSA9PiB7XG4gIGNvbnN0IGxhc3QgPSB3aGF0SXNEcmFnZ2VkT3ZlcihwcmV2aW91c0ltcGFjdCk7XG4gIGNvbnN0IG5vdyA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghbGFzdCkge1xuICAgIHJldHVybiBkcm9wcGFibGVzO1xuICB9XG4gIGlmIChsYXN0ID09PSBub3cpIHtcbiAgICByZXR1cm4gZHJvcHBhYmxlcztcbiAgfVxuICBjb25zdCBsYXN0RHJvcHBhYmxlID0gZHJvcHBhYmxlc1tsYXN0XTtcbiAgaWYgKCFsYXN0RHJvcHBhYmxlLnN1YmplY3Qud2l0aFBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIGRyb3BwYWJsZXM7XG4gIH1cbiAgY29uc3QgdXBkYXRlZCA9IHJlbW92ZVBsYWNlaG9sZGVyKGxhc3REcm9wcGFibGUpO1xuICByZXR1cm4gcGF0Y2hEcm9wcGFibGVNYXAoZHJvcHBhYmxlcywgdXBkYXRlZCk7XG59O1xudmFyIHJlY29tcHV0ZVBsYWNlaG9sZGVycyA9ICh7XG4gIGRyYWdnYWJsZSxcbiAgZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlcyxcbiAgcHJldmlvdXNJbXBhY3QsXG4gIGltcGFjdFxufSkgPT4ge1xuICBjb25zdCBjbGVhbmVkID0gY2xlYXJVbnVzZWRQbGFjZWhvbGRlcih7XG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgaW1wYWN0LFxuICAgIGRyb3BwYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGlzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGltcGFjdCk7XG4gIGlmICghaXNPdmVyKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZHJvcHBhYmxlc1tpc092ZXJdO1xuICBpZiAoaXNIb21lT2YoZHJhZ2dhYmxlLCBkcm9wcGFibGUpKSB7XG4gICAgcmV0dXJuIGNsZWFuZWQ7XG4gIH1cbiAgaWYgKGRyb3BwYWJsZS5zdWJqZWN0LndpdGhQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBjbGVhbmVkO1xuICB9XG4gIGNvbnN0IHBhdGNoZWQgPSBhZGRQbGFjZWhvbGRlcihkcm9wcGFibGUsIGRyYWdnYWJsZSwgZHJhZ2dhYmxlcyk7XG4gIHJldHVybiBwYXRjaERyb3BwYWJsZU1hcChjbGVhbmVkLCBwYXRjaGVkKTtcbn07XG5cbnZhciB1cGRhdGUgPSAoe1xuICBzdGF0ZSxcbiAgY2xpZW50U2VsZWN0aW9uOiBmb3JjZWRDbGllbnRTZWxlY3Rpb24sXG4gIGRpbWVuc2lvbnM6IGZvcmNlZERpbWVuc2lvbnMsXG4gIHZpZXdwb3J0OiBmb3JjZWRWaWV3cG9ydCxcbiAgaW1wYWN0OiBmb3JjZWRJbXBhY3QsXG4gIHNjcm9sbEp1bXBSZXF1ZXN0XG59KSA9PiB7XG4gIGNvbnN0IHZpZXdwb3J0ID0gZm9yY2VkVmlld3BvcnQgfHwgc3RhdGUudmlld3BvcnQ7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBmb3JjZWREaW1lbnNpb25zIHx8IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGZvcmNlZENsaWVudFNlbGVjdGlvbiB8fCBzdGF0ZS5jdXJyZW50LmNsaWVudC5zZWxlY3Rpb247XG4gIGNvbnN0IG9mZnNldCA9IHN1YnRyYWN0KGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuaW5pdGlhbC5jbGllbnQuc2VsZWN0aW9uKTtcbiAgY29uc3QgY2xpZW50ID0ge1xuICAgIG9mZnNldCxcbiAgICBzZWxlY3Rpb246IGNsaWVudFNlbGVjdGlvbixcbiAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChzdGF0ZS5pbml0aWFsLmNsaWVudC5ib3JkZXJCb3hDZW50ZXIsIG9mZnNldClcbiAgfTtcbiAgY29uc3QgcGFnZSA9IHtcbiAgICBzZWxlY3Rpb246IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuY3VycmVudCksXG4gICAgYm9yZGVyQm94Q2VudGVyOiBhZGQoY2xpZW50LmJvcmRlckJveENlbnRlciwgdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQpLFxuICAgIG9mZnNldDogYWRkKGNsaWVudC5vZmZzZXQsIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICB9O1xuICBjb25zdCBjdXJyZW50ID0ge1xuICAgIGNsaWVudCxcbiAgICBwYWdlXG4gIH07XG4gIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgY3VycmVudFxuICAgIH07XG4gIH1cbiAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IG5ld0ltcGFjdCA9IGZvcmNlZEltcGFjdCB8fCBnZXREcmFnSW1wYWN0KHtcbiAgICBwYWdlT2Zmc2V0OiBwYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlczogZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXM6IGRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICBwcmV2aW91c0ltcGFjdDogc3RhdGUuaW1wYWN0LFxuICAgIHZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IHdpdGhVcGRhdGVkUGxhY2Vob2xkZXJzID0gcmVjb21wdXRlUGxhY2Vob2xkZXJzKHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgcHJldmlvdXNJbXBhY3Q6IHN0YXRlLmltcGFjdCxcbiAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlczogZGltZW5zaW9ucy5kcm9wcGFibGVzXG4gIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgY3VycmVudCxcbiAgICBkaW1lbnNpb25zOiB7XG4gICAgICBkcmFnZ2FibGVzOiBkaW1lbnNpb25zLmRyYWdnYWJsZXMsXG4gICAgICBkcm9wcGFibGVzOiB3aXRoVXBkYXRlZFBsYWNlaG9sZGVyc1xuICAgIH0sXG4gICAgaW1wYWN0OiBuZXdJbXBhY3QsXG4gICAgdmlld3BvcnQsXG4gICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IHNjcm9sbEp1bXBSZXF1ZXN0IHx8IG51bGwsXG4gICAgZm9yY2VTaG91bGRBbmltYXRlOiBzY3JvbGxKdW1wUmVxdWVzdCA/IGZhbHNlIDogbnVsbFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlcyhpZHMsIGRyYWdnYWJsZXMpIHtcbiAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gZHJhZ2dhYmxlc1tpZF0pO1xufVxudmFyIHJlY29tcHV0ZSA9ICh7XG4gIGltcGFjdCxcbiAgdmlld3BvcnQsXG4gIGRyYWdnYWJsZXMsXG4gIGRlc3RpbmF0aW9uLFxuICBmb3JjZVNob3VsZEFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3QgbGFzdCA9IGltcGFjdC5kaXNwbGFjZWQ7XG4gIGNvbnN0IGFmdGVyRHJhZ2dpbmcgPSBnZXREcmFnZ2FibGVzKGxhc3QuYWxsLCBkcmFnZ2FibGVzKTtcbiAgY29uc3QgZGlzcGxhY2VkID0gZ2V0RGlzcGxhY2VtZW50R3JvdXBzKHtcbiAgICBhZnRlckRyYWdnaW5nLFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRpc3BsYWNlZEJ5OiBpbXBhY3QuZGlzcGxhY2VkQnksXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LmZyYW1lLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZSxcbiAgICBsYXN0XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmltcGFjdCxcbiAgICBkaXNwbGFjZWRcbiAgfTtcbn07XG5cbnZhciBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIgPSAoe1xuICBpbXBhY3QsXG4gIGRyYWdnYWJsZSxcbiAgZHJvcHBhYmxlLFxuICBkcmFnZ2FibGVzLFxuICB2aWV3cG9ydCxcbiAgYWZ0ZXJDcml0aWNhbFxufSkgPT4ge1xuICBjb25zdCBwYWdlQm9yZGVyQm94Q2VudGVyID0gZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3Qoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGUsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIGdldENsaWVudEZyb21QYWdlQm9yZGVyQm94Q2VudGVyKHtcbiAgICBwYWdlQm9yZGVyQm94Q2VudGVyLFxuICAgIGRyYWdnYWJsZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbn07XG5cbnZhciByZWZyZXNoU25hcCA9ICh7XG4gIHN0YXRlLFxuICBkaW1lbnNpb25zOiBmb3JjZWREaW1lbnNpb25zLFxuICB2aWV3cG9ydDogZm9yY2VkVmlld3BvcnRcbn0pID0+IHtcbiAgIShzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBuZWVkc1Zpc2liaWxpdHlDaGVjayA9IHN0YXRlLmltcGFjdDtcbiAgY29uc3Qgdmlld3BvcnQgPSBmb3JjZWRWaWV3cG9ydCB8fCBzdGF0ZS52aWV3cG9ydDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGZvcmNlZERpbWVuc2lvbnMgfHwgc3RhdGUuZGltZW5zaW9ucztcbiAgY29uc3Qge1xuICAgIGRyYWdnYWJsZXMsXG4gICAgZHJvcHBhYmxlc1xuICB9ID0gZGltZW5zaW9ucztcbiAgY29uc3QgZHJhZ2dhYmxlID0gZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBpc092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihuZWVkc1Zpc2liaWxpdHlDaGVjayk7XG4gICFpc092ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG92ZXIgYSBkZXN0aW5hdGlvbiBpbiBTTkFQIG1vdmVtZW50IG1vZGUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRyb3BwYWJsZXNbaXNPdmVyXTtcbiAgY29uc3QgaW1wYWN0ID0gcmVjb21wdXRlKHtcbiAgICBpbXBhY3Q6IG5lZWRzVmlzaWJpbGl0eUNoZWNrLFxuICAgIHZpZXdwb3J0LFxuICAgIGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXNcbiAgfSk7XG4gIGNvbnN0IGNsaWVudFNlbGVjdGlvbiA9IGdldENsaWVudEJvcmRlckJveENlbnRlcih7XG4gICAgaW1wYWN0LFxuICAgIGRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IGRlc3RpbmF0aW9uLFxuICAgIGRyYWdnYWJsZXMsXG4gICAgdmlld3BvcnQsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbFxuICB9KTtcbiAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgaW1wYWN0LFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zLFxuICAgIHZpZXdwb3J0XG4gIH0pO1xufTtcblxudmFyIGdldEhvbWVMb2NhdGlvbiA9IGRlc2NyaXB0b3IgPT4gKHtcbiAgaW5kZXg6IGRlc2NyaXB0b3IuaW5kZXgsXG4gIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG59KTtcblxudmFyIGdldExpZnRFZmZlY3QgPSAoe1xuICBkcmFnZ2FibGUsXG4gIGhvbWUsXG4gIGRyYWdnYWJsZXMsXG4gIHZpZXdwb3J0XG59KSA9PiB7XG4gIGNvbnN0IGRpc3BsYWNlZEJ5ID0gZ2V0RGlzcGxhY2VkQnkoaG9tZS5heGlzLCBkcmFnZ2FibGUuZGlzcGxhY2VCeSk7XG4gIGNvbnN0IGluc2lkZUhvbWUgPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGhvbWUuZGVzY3JpcHRvci5pZCwgZHJhZ2dhYmxlcyk7XG4gIGNvbnN0IHJhd0luZGV4ID0gaW5zaWRlSG9tZS5pbmRleE9mKGRyYWdnYWJsZSk7XG4gICEocmF3SW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGRyYWdnYWJsZSB0byBiZSBpbnNpZGUgaG9tZSBsaXN0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgYWZ0ZXJEcmFnZ2luZyA9IGluc2lkZUhvbWUuc2xpY2UocmF3SW5kZXggKyAxKTtcbiAgY29uc3QgZWZmZWN0ZWQgPSBhZnRlckRyYWdnaW5nLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0pID0+IHtcbiAgICBwcmV2aW91c1tpdGVtLmRlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH0sIHt9KTtcbiAgY29uc3QgYWZ0ZXJDcml0aWNhbCA9IHtcbiAgICBpblZpcnR1YWxMaXN0OiBob21lLmRlc2NyaXB0b3IubW9kZSA9PT0gJ3ZpcnR1YWwnLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGVmZmVjdGVkXG4gIH07XG4gIGNvbnN0IGRpc3BsYWNlZCA9IGdldERpc3BsYWNlbWVudEdyb3Vwcyh7XG4gICAgYWZ0ZXJEcmFnZ2luZyxcbiAgICBkZXN0aW5hdGlvbjogaG9tZSxcbiAgICBkaXNwbGFjZWRCeSxcbiAgICBsYXN0OiBudWxsLFxuICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5mcmFtZSxcbiAgICBmb3JjZVNob3VsZEFuaW1hdGU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbXBhY3QgPSB7XG4gICAgZGlzcGxhY2VkLFxuICAgIGRpc3BsYWNlZEJ5LFxuICAgIGF0OiB7XG4gICAgICB0eXBlOiAnUkVPUkRFUicsXG4gICAgICBkZXN0aW5hdGlvbjogZ2V0SG9tZUxvY2F0aW9uKGRyYWdnYWJsZS5kZXNjcmlwdG9yKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBpbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbFxuICB9O1xufTtcblxudmFyIHBhdGNoRGltZW5zaW9uTWFwID0gKGRpbWVuc2lvbnMsIHVwZGF0ZWQpID0+ICh7XG4gIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgZHJvcHBhYmxlczogcGF0Y2hEcm9wcGFibGVNYXAoZGltZW5zaW9ucy5kcm9wcGFibGVzLCB1cGRhdGVkKVxufSk7XG5cbmNvbnN0IHN0YXJ0ID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuY29uc3QgZmluaXNoID0ga2V5ID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG52YXIgb2Zmc2V0RHJhZ2dhYmxlID0gKHtcbiAgZHJhZ2dhYmxlLFxuICBvZmZzZXQ6IG9mZnNldCQxLFxuICBpbml0aWFsV2luZG93U2Nyb2xsXG59KSA9PiB7XG4gIGNvbnN0IGNsaWVudCA9IG9mZnNldChkcmFnZ2FibGUuY2xpZW50LCBvZmZzZXQkMSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgaW5pdGlhbFdpbmRvd1Njcm9sbCk7XG4gIGNvbnN0IG1vdmVkID0ge1xuICAgIC4uLmRyYWdnYWJsZSxcbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgLi4uZHJhZ2dhYmxlLnBsYWNlaG9sZGVyLFxuICAgICAgY2xpZW50XG4gICAgfSxcbiAgICBjbGllbnQsXG4gICAgcGFnZVxuICB9O1xuICByZXR1cm4gbW92ZWQ7XG59O1xuXG52YXIgZ2V0RnJhbWUgPSBkcm9wcGFibGUgPT4ge1xuICBjb25zdCBmcmFtZSA9IGRyb3BwYWJsZS5mcmFtZTtcbiAgIWZyYW1lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgRHJvcHBhYmxlIHRvIGhhdmUgYSBmcmFtZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBmcmFtZTtcbn07XG5cbnZhciBhZGp1c3RBZGRpdGlvbnNGb3JTY3JvbGxDaGFuZ2VzID0gKHtcbiAgYWRkaXRpb25zLFxuICB1cGRhdGVkRHJvcHBhYmxlcyxcbiAgdmlld3BvcnRcbn0pID0+IHtcbiAgY29uc3Qgd2luZG93U2Nyb2xsQ2hhbmdlID0gdmlld3BvcnQuc2Nyb2xsLmRpZmYudmFsdWU7XG4gIHJldHVybiBhZGRpdGlvbnMubWFwKGRyYWdnYWJsZSA9PiB7XG4gICAgY29uc3QgZHJvcHBhYmxlSWQgPSBkcmFnZ2FibGUuZGVzY3JpcHRvci5kcm9wcGFibGVJZDtcbiAgICBjb25zdCBtb2RpZmllZCA9IHVwZGF0ZWREcm9wcGFibGVzW2Ryb3BwYWJsZUlkXTtcbiAgICBjb25zdCBmcmFtZSA9IGdldEZyYW1lKG1vZGlmaWVkKTtcbiAgICBjb25zdCBkcm9wcGFibGVTY3JvbGxDaGFuZ2UgPSBmcmFtZS5zY3JvbGwuZGlmZi52YWx1ZTtcbiAgICBjb25zdCB0b3RhbENoYW5nZSA9IGFkZCh3aW5kb3dTY3JvbGxDaGFuZ2UsIGRyb3BwYWJsZVNjcm9sbENoYW5nZSk7XG4gICAgY29uc3QgbW92ZWQgPSBvZmZzZXREcmFnZ2FibGUoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgb2Zmc2V0OiB0b3RhbENoYW5nZSxcbiAgICAgIGluaXRpYWxXaW5kb3dTY3JvbGw6IHZpZXdwb3J0LnNjcm9sbC5pbml0aWFsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vdmVkO1xuICB9KTtcbn07XG5cbnZhciBwdWJsaXNoV2hpbGVEcmFnZ2luZ0luVmlydHVhbCA9ICh7XG4gIHN0YXRlLFxuICBwdWJsaXNoZWRcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgd2l0aFNjcm9sbENoYW5nZSA9IHB1Ymxpc2hlZC5tb2RpZmllZC5tYXAodXBkYXRlID0+IHtcbiAgICBjb25zdCBleGlzdGluZyA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1t1cGRhdGUuZHJvcHBhYmxlSWRdO1xuICAgIGNvbnN0IHNjcm9sbGVkID0gc2Nyb2xsRHJvcHBhYmxlKGV4aXN0aW5nLCB1cGRhdGUuc2Nyb2xsKTtcbiAgICByZXR1cm4gc2Nyb2xsZWQ7XG4gIH0pO1xuICBjb25zdCBkcm9wcGFibGVzID0ge1xuICAgIC4uLnN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlcyxcbiAgICAuLi50b0Ryb3BwYWJsZU1hcCh3aXRoU2Nyb2xsQ2hhbmdlKVxuICB9O1xuICBjb25zdCB1cGRhdGVkQWRkaXRpb25zID0gdG9EcmFnZ2FibGVNYXAoYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyh7XG4gICAgYWRkaXRpb25zOiBwdWJsaXNoZWQuYWRkaXRpb25zLFxuICAgIHVwZGF0ZWREcm9wcGFibGVzOiBkcm9wcGFibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KSk7XG4gIGNvbnN0IGRyYWdnYWJsZXMgPSB7XG4gICAgLi4uc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzLFxuICAgIC4uLnVwZGF0ZWRBZGRpdGlvbnNcbiAgfTtcbiAgcHVibGlzaGVkLnJlbW92YWxzLmZvckVhY2goaWQgPT4ge1xuICAgIGRlbGV0ZSBkcmFnZ2FibGVzW2lkXTtcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB7XG4gICAgZHJvcHBhYmxlcyxcbiAgICBkcmFnZ2FibGVzXG4gIH07XG4gIGNvbnN0IHdhc092ZXJJZCA9IHdoYXRJc0RyYWdnZWRPdmVyKHN0YXRlLmltcGFjdCk7XG4gIGNvbnN0IHdhc092ZXIgPSB3YXNPdmVySWQgPyBkaW1lbnNpb25zLmRyb3BwYWJsZXNbd2FzT3ZlcklkXSA6IG51bGw7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCBob21lID0gZGltZW5zaW9ucy5kcm9wcGFibGVzW3N0YXRlLmNyaXRpY2FsLmRyb3BwYWJsZS5pZF07XG4gIGNvbnN0IHtcbiAgICBpbXBhY3Q6IG9uTGlmdEltcGFjdCxcbiAgICBhZnRlckNyaXRpY2FsXG4gIH0gPSBnZXRMaWZ0RWZmZWN0KHtcbiAgICBkcmFnZ2FibGUsXG4gICAgaG9tZSxcbiAgICBkcmFnZ2FibGVzLFxuICAgIHZpZXdwb3J0OiBzdGF0ZS52aWV3cG9ydFxuICB9KTtcbiAgY29uc3QgcHJldmlvdXNJbXBhY3QgPSB3YXNPdmVyICYmIHdhc092ZXIuaXNDb21iaW5lRW5hYmxlZCA/IHN0YXRlLmltcGFjdCA6IG9uTGlmdEltcGFjdDtcbiAgY29uc3QgaW1wYWN0ID0gZ2V0RHJhZ0ltcGFjdCh7XG4gICAgcGFnZU9mZnNldDogc3RhdGUuY3VycmVudC5wYWdlLm9mZnNldCxcbiAgICBkcmFnZ2FibGU6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdLFxuICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICBkcm9wcGFibGVzOiBkaW1lbnNpb25zLmRyb3BwYWJsZXMsXG4gICAgcHJldmlvdXNJbXBhY3QsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGZpbmlzaCgpO1xuICBjb25zdCBkcmFnZ2luZ1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIHBoYXNlOiAnRFJBR0dJTkcnLFxuICAgIGltcGFjdCxcbiAgICBvbkxpZnRJbXBhY3QsXG4gICAgZGltZW5zaW9ucyxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogZmFsc2VcbiAgfTtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmdTdGF0ZTtcbiAgfVxuICBjb25zdCBkcm9wUGVuZGluZyA9IHtcbiAgICAuLi5kcmFnZ2luZ1N0YXRlLFxuICAgIHBoYXNlOiAnRFJPUF9QRU5ESU5HJyxcbiAgICByZWFzb246IHN0YXRlLnJlYXNvbixcbiAgICBpc1dhaXRpbmc6IGZhbHNlXG4gIH07XG4gIHJldHVybiBkcm9wUGVuZGluZztcbn07XG5cbmNvbnN0IGlzU25hcHBpbmcgPSBzdGF0ZSA9PiBzdGF0ZS5tb3ZlbWVudE1vZGUgPT09ICdTTkFQJztcbmNvbnN0IHBvc3REcm9wcGFibGVDaGFuZ2UgPSAoc3RhdGUsIHVwZGF0ZWQsIGlzRW5hYmxlZENoYW5naW5nKSA9PiB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSBwYXRjaERpbWVuc2lvbk1hcChzdGF0ZS5kaW1lbnNpb25zLCB1cGRhdGVkKTtcbiAgaWYgKCFpc1NuYXBwaW5nKHN0YXRlKSB8fCBpc0VuYWJsZWRDaGFuZ2luZykge1xuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICBkaW1lbnNpb25zXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZnJlc2hTbmFwKHtcbiAgICBzdGF0ZSxcbiAgICBkaW1lbnNpb25zXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5pc0RyYWdnaW5nICYmIHN0YXRlLm1vdmVtZW50TW9kZSA9PT0gJ1NOQVAnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc2Nyb2xsSnVtcFJlcXVlc3Q6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IGlkbGUkMiA9IHtcbiAgcGhhc2U6ICdJRExFJyxcbiAgY29tcGxldGVkOiBudWxsLFxuICBzaG91bGRGbHVzaDogZmFsc2Vcbn07XG52YXIgcmVkdWNlciA9IChzdGF0ZSA9IGlkbGUkMiwgYWN0aW9uKSA9PiB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0ZMVVNIJykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pZGxlJDIsXG4gICAgICBzaG91bGRGbHVzaDogdHJ1ZVxuICAgIH07XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnSU5JVElBTF9QVUJMSVNIJykge1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdJTklUSUFMX1BVQkxJU0ggbXVzdCBjb21lIGFmdGVyIGEgSURMRSBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgY3JpdGljYWwsXG4gICAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGRpbWVuc2lvbnMsXG4gICAgICBtb3ZlbWVudE1vZGVcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgY29uc3QgZHJhZ2dhYmxlID0gZGltZW5zaW9ucy5kcmFnZ2FibGVzW2NyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gICAgY29uc3QgaG9tZSA9IGRpbWVuc2lvbnMuZHJvcHBhYmxlc1tjcml0aWNhbC5kcm9wcGFibGUuaWRdO1xuICAgIGNvbnN0IGNsaWVudCA9IHtcbiAgICAgIHNlbGVjdGlvbjogY2xpZW50U2VsZWN0aW9uLFxuICAgICAgYm9yZGVyQm94Q2VudGVyOiBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIsXG4gICAgICBvZmZzZXQ6IG9yaWdpblxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgIGNsaWVudCxcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgc2VsZWN0aW9uOiBhZGQoY2xpZW50LnNlbGVjdGlvbiwgdmlld3BvcnQuc2Nyb2xsLmluaXRpYWwpLFxuICAgICAgICBib3JkZXJCb3hDZW50ZXI6IGFkZChjbGllbnQuc2VsZWN0aW9uLCB2aWV3cG9ydC5zY3JvbGwuaW5pdGlhbCksXG4gICAgICAgIG9mZnNldDogYWRkKGNsaWVudC5zZWxlY3Rpb24sIHZpZXdwb3J0LnNjcm9sbC5kaWZmLnZhbHVlKVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaXNXaW5kb3dTY3JvbGxBbGxvd2VkID0gdG9Ecm9wcGFibGVMaXN0KGRpbWVuc2lvbnMuZHJvcHBhYmxlcykuZXZlcnkoaXRlbSA9PiAhaXRlbS5pc0ZpeGVkT25QYWdlKTtcbiAgICBjb25zdCB7XG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsXG4gICAgfSA9IGdldExpZnRFZmZlY3Qoe1xuICAgICAgZHJhZ2dhYmxlLFxuICAgICAgaG9tZSxcbiAgICAgIGRyYWdnYWJsZXM6IGRpbWVuc2lvbnMuZHJhZ2dhYmxlcyxcbiAgICAgIHZpZXdwb3J0XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcGhhc2U6ICdEUkFHR0lORycsXG4gICAgICBpc0RyYWdnaW5nOiB0cnVlLFxuICAgICAgY3JpdGljYWwsXG4gICAgICBtb3ZlbWVudE1vZGUsXG4gICAgICBkaW1lbnNpb25zLFxuICAgICAgaW5pdGlhbCxcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWwsXG4gICAgICBpc1dpbmRvd1Njcm9sbEFsbG93ZWQsXG4gICAgICBpbXBhY3QsXG4gICAgICBhZnRlckNyaXRpY2FsLFxuICAgICAgb25MaWZ0SW1wYWN0OiBpbXBhY3QsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiBudWxsLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0NPTExFQ1RJT05fU1RBUlRJTkcnKSB7XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnQ09MTEVDVElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgZnJvbSBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwaGFzZTogJ0NPTExFQ1RJTkcnXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSB7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0NPTExFQ1RJTkcnIHx8IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBVbmV4cGVjdGVkICR7YWN0aW9uLnR5cGV9IHJlY2VpdmVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcHVibGlzaFdoaWxlRHJhZ2dpbmdJblZpcnR1YWwoe1xuICAgICAgc3RhdGUsXG4gICAgICBwdWJsaXNoZWQ6IGFjdGlvbi5wYXlsb2FkXG4gICAgfSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRScpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSBub3QgcGVybWl0dGVkIGluIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBjbGllbnQ6IGNsaWVudFNlbGVjdGlvblxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBpZiAoaXNFcXVhbCQxKGNsaWVudFNlbGVjdGlvbiwgc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlKHtcbiAgICAgIHN0YXRlLFxuICAgICAgY2xpZW50U2VsZWN0aW9uLFxuICAgICAgaW1wYWN0OiBpc1NuYXBwaW5nKHN0YXRlKSA/IHN0YXRlLmltcGFjdCA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX1NDUk9MTCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlU2Nyb2xsSnVtcFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7YWN0aW9uLnR5cGV9IG5vdCBwZXJtaXR0ZWQgaW4gcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgbmV3U2Nyb2xsXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsZWQgPSBzY3JvbGxEcm9wcGFibGUodGFyZ2V0LCBuZXdTY3JvbGwpO1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCBzY3JvbGxlZCwgZmFsc2UpO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9EUk9QUEFCTEVfSVNfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHRhcmdldCA9IHN0YXRlLmRpbWVuc2lvbnMuZHJvcHBhYmxlc1tpZF07XG4gICAgIXRhcmdldCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBmaW5kIERyb3BwYWJsZVtpZDogJHtpZH1dIHRvIHRvZ2dsZSBpdHMgZW5hYmxlZCBzdGF0ZWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgISh0YXJnZXQuaXNFbmFibGVkICE9PSBpc0VuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNFbmFibGVkIHRvICR7U3RyaW5nKGlzRW5hYmxlZCl9XG4gICAgICBidXQgaXQgaXMgYWxyZWFkeSAke1N0cmluZyh0YXJnZXQuaXNFbmFibGVkKX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpc0VuYWJsZWRcbiAgICB9O1xuICAgIHJldHVybiBwb3N0RHJvcHBhYmxlQ2hhbmdlKHN0YXRlLCB1cGRhdGVkLCB0cnVlKTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgICFpc01vdmVtZW50QWxsb3dlZChzdGF0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBdHRlbXB0aW5nIHRvIG1vdmUgaW4gYW4gdW5zdXBwb3J0ZWQgcGhhc2UgJHtzdGF0ZS5waGFzZX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaXNDb21iaW5lRW5hYmxlZFxuICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICBjb25zdCB0YXJnZXQgPSBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbaWRdO1xuICAgICF0YXJnZXQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBEcm9wcGFibGVbaWQ6ICR7aWR9XSB0byB0b2dnbGUgaXRzIGlzQ29tYmluZUVuYWJsZWQgc3RhdGVgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICEodGFyZ2V0LmlzQ29tYmluZUVuYWJsZWQgIT09IGlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgVHJ5aW5nIHRvIHNldCBkcm9wcGFibGUgaXNDb21iaW5lRW5hYmxlZCB0byAke1N0cmluZyhpc0NvbWJpbmVFbmFibGVkKX1cbiAgICAgIGJ1dCBpdCBpcyBhbHJlYWR5ICR7U3RyaW5nKHRhcmdldC5pc0NvbWJpbmVFbmFibGVkKX1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpc0NvbWJpbmVFbmFibGVkXG4gICAgfTtcbiAgICByZXR1cm4gcG9zdERyb3BwYWJsZUNoYW5nZShzdGF0ZSwgdXBkYXRlZCwgdHJ1ZSk7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnTU9WRV9CWV9XSU5ET1dfU0NST0xMJykge1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycgfHwgc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIWlzTW92ZW1lbnRBbGxvd2VkKHN0YXRlKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBtb3ZlIGJ5IHdpbmRvdyBpbiBwaGFzZSAke3N0YXRlLnBoYXNlfWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgIXN0YXRlLmlzV2luZG93U2Nyb2xsQWxsb3dlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1dpbmRvdyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIGZpeGVkIGxpc3RzJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTY3JvbGwgPSBhY3Rpb24ucGF5bG9hZC5uZXdTY3JvbGw7XG4gICAgaWYgKGlzRXF1YWwkMShzdGF0ZS52aWV3cG9ydC5zY3JvbGwuY3VycmVudCwgbmV3U2Nyb2xsKSkge1xuICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbEp1bXBSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSBzY3JvbGxWaWV3cG9ydChzdGF0ZS52aWV3cG9ydCwgbmV3U2Nyb2xsKTtcbiAgICBpZiAoaXNTbmFwcGluZyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybiByZWZyZXNoU25hcCh7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICB2aWV3cG9ydFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB2aWV3cG9ydFxuICAgIH0pO1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ1VQREFURV9WSUVXUE9SVF9NQVhfU0NST0xMJykge1xuICAgIGlmICghaXNNb3ZlbWVudEFsbG93ZWQoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IG1heFNjcm9sbCA9IGFjdGlvbi5wYXlsb2FkLm1heFNjcm9sbDtcbiAgICBpZiAoaXNFcXVhbCQxKG1heFNjcm9sbCwgc3RhdGUudmlld3BvcnQuc2Nyb2xsLm1heCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aE1heFNjcm9sbCA9IHtcbiAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgc2Nyb2xsOiB7XG4gICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LnNjcm9sbCxcbiAgICAgICAgbWF4OiBtYXhTY3JvbGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpZXdwb3J0OiB3aXRoTWF4U2Nyb2xsXG4gICAgfTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdNT1ZFX1VQJyB8fCBhY3Rpb24udHlwZSA9PT0gJ01PVkVfRE9XTicgfHwgYWN0aW9uLnR5cGUgPT09ICdNT1ZFX0xFRlQnIHx8IGFjdGlvbi50eXBlID09PSAnTU9WRV9SSUdIVCcpIHtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGAke2FjdGlvbi50eXBlfSByZWNlaXZlZCB3aGlsZSBub3QgaW4gRFJBR0dJTkcgcGhhc2VgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1vdmVJbkRpcmVjdGlvbih7XG4gICAgICBzdGF0ZSxcbiAgICAgIHR5cGU6IGFjdGlvbi50eXBlXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGltcGFjdDogcmVzdWx0LmltcGFjdCxcbiAgICAgIGNsaWVudFNlbGVjdGlvbjogcmVzdWx0LmNsaWVudFNlbGVjdGlvbixcbiAgICAgIHNjcm9sbEp1bXBSZXF1ZXN0OiByZXN1bHQuc2Nyb2xsSnVtcFJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdEUk9QX1BFTkRJTkcnKSB7XG4gICAgY29uc3QgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBtb3ZlIGludG8gdGhlIERST1BfUEVORElORyBwaGFzZSBmcm9tIHRoZSBDT0xMRUNUSU5HIHBoYXNlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGhhc2U6ICdEUk9QX1BFTkRJTkcnLFxuICAgICAgaXNXYWl0aW5nOiB0cnVlLFxuICAgICAgcmVhc29uXG4gICAgfTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbi50eXBlID09PSAnRFJPUF9BTklNQVRFJykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXRcbiAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGFuaW1hdGUgZHJvcCBmcm9tIHBoYXNlICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwaGFzZTogJ0RST1BfQU5JTUFUSU5HJyxcbiAgICAgIGNvbXBsZXRlZCxcbiAgICAgIGRyb3BEdXJhdGlvbixcbiAgICAgIG5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiBzdGF0ZS5kaW1lbnNpb25zXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gJ0RST1BfQ09NUExFVEUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tcGxldGVkXG4gICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogJ0lETEUnLFxuICAgICAgY29tcGxldGVkLFxuICAgICAgc2hvdWxkRmx1c2g6IGZhbHNlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59O1xuXG5mdW5jdGlvbiBndWFyZChhY3Rpb24sIHByZWRpY2F0ZSkge1xuICByZXR1cm4gYWN0aW9uIGluc3RhbmNlb2YgT2JqZWN0ICYmICd0eXBlJyBpbiBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IHByZWRpY2F0ZTtcbn1cbmNvbnN0IGJlZm9yZUluaXRpYWxDYXB0dXJlID0gYXJncyA9PiAoe1xuICB0eXBlOiAnQkVGT1JFX0lOSVRJQUxfQ0FQVFVSRScsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbGlmdCQxID0gYXJncyA9PiAoe1xuICB0eXBlOiAnTElGVCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgaW5pdGlhbFB1Ymxpc2ggPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdJTklUSUFMX1BVQkxJU0gnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHB1Ymxpc2hXaGlsZURyYWdnaW5nID0gYXJncyA9PiAoe1xuICB0eXBlOiAnUFVCTElTSF9XSElMRV9EUkFHR0lORycsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgY29sbGVjdGlvblN0YXJ0aW5nID0gKCkgPT4gKHtcbiAgdHlwZTogJ0NPTExFQ1RJT05fU1RBUlRJTkcnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZVNjcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ1VQREFURV9EUk9QUEFCTEVfU0NST0xMJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0VOQUJMRUQnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfRFJPUFBBQkxFX0lTX0NPTUJJTkVfRU5BQkxFRCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZSA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ01PVkUnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IG1vdmVCeVdpbmRvd1Njcm9sbCA9IGFyZ3MgPT4gKHtcbiAgdHlwZTogJ01PVkVfQllfV0lORE9XX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdVUERBVEVfVklFV1BPUlRfTUFYX1NDUk9MTCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgbW92ZVVwID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfVVAnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVEb3duID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfRE9XTicsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgbW92ZVJpZ2h0ID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfUklHSFQnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IG1vdmVMZWZ0ID0gKCkgPT4gKHtcbiAgdHlwZTogJ01PVkVfTEVGVCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuY29uc3QgZmx1c2ggPSAoKSA9PiAoe1xuICB0eXBlOiAnRkxVU0gnLFxuICBwYXlsb2FkOiBudWxsXG59KTtcbmNvbnN0IGFuaW1hdGVEcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUF9BTklNQVRFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBjb21wbGV0ZURyb3AgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX0NPTVBMRVRFJyxcbiAgcGF5bG9hZDogYXJnc1xufSk7XG5jb25zdCBkcm9wID0gYXJncyA9PiAoe1xuICB0eXBlOiAnRFJPUCcsXG4gIHBheWxvYWQ6IGFyZ3Ncbn0pO1xuY29uc3QgZHJvcFBlbmRpbmcgPSBhcmdzID0+ICh7XG4gIHR5cGU6ICdEUk9QX1BFTkRJTkcnLFxuICBwYXlsb2FkOiBhcmdzXG59KTtcbmNvbnN0IGRyb3BBbmltYXRpb25GaW5pc2hlZCA9ICgpID0+ICh7XG4gIHR5cGU6ICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcsXG4gIHBheWxvYWQ6IG51bGxcbn0pO1xuXG5mdW5jdGlvbiBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pIHtcbiAgaWYgKGluc2lkZURlc3RpbmF0aW9uLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGluZGV4ZXMgPSBpbnNpZGVEZXN0aW5hdGlvbi5tYXAoZCA9PiBkLmRlc2NyaXB0b3IuaW5kZXgpO1xuICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGluZGV4ZXNbaV07XG4gICAgY29uc3QgcHJldmlvdXMgPSBpbmRleGVzW2kgLSAxXTtcbiAgICBpZiAoY3VycmVudCAhPT0gcHJldmlvdXMgKyAxKSB7XG4gICAgICBlcnJvcnNbY3VycmVudF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGVycm9ycykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGluZGV4ZXMubWFwKGluZGV4ID0+IHtcbiAgICBjb25zdCBoYXNFcnJvciA9IEJvb2xlYW4oZXJyb3JzW2luZGV4XSk7XG4gICAgcmV0dXJuIGhhc0Vycm9yID8gYFvwn5SlJHtpbmRleH1dYCA6IGAke2luZGV4fWA7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIERldGVjdGVkIG5vbi1jb25zZWN1dGl2ZSA8RHJhZ2dhYmxlIC8+IGluZGV4ZXMuXG5cbiAgICAoVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBidWdzKVxuXG4gICAgJHtmb3JtYXR0ZWR9XG4gIGApIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb25zKGNyaXRpY2FsLCBkaW1lbnNpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgaW5zaWRlRGVzdGluYXRpb24gPSBnZXREcmFnZ2FibGVzSW5zaWRlRHJvcHBhYmxlKGNyaXRpY2FsLmRyb3BwYWJsZS5pZCwgZGltZW5zaW9ucy5kcmFnZ2FibGVzKTtcbiAgICBjaGVja0luZGV4ZXMoaW5zaWRlRGVzdGluYXRpb24pO1xuICB9XG59XG5cbnZhciBsaWZ0ID0gbWFyc2hhbCA9PiAoe1xuICBnZXRTdGF0ZSxcbiAgZGlzcGF0Y2hcbn0pID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdMSUZUJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjbGllbnRTZWxlY3Rpb24sXG4gICAgbW92ZW1lbnRNb2RlXG4gIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgY29uc3QgaW5pdGlhbCA9IGdldFN0YXRlKCk7XG4gIGlmIChpbml0aWFsLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgZGlzcGF0Y2goY29tcGxldGVEcm9wKHtcbiAgICAgIGNvbXBsZXRlZDogaW5pdGlhbC5jb21wbGV0ZWRcbiAgICB9KSk7XG4gIH1cbiAgIShnZXRTdGF0ZSgpLnBoYXNlID09PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZSB0byBzdGFydCBhIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBkaXNwYXRjaChmbHVzaCgpKTtcbiAgZGlzcGF0Y2goYmVmb3JlSW5pdGlhbENhcHR1cmUoe1xuICAgIGRyYWdnYWJsZUlkOiBpZCxcbiAgICBtb3ZlbWVudE1vZGVcbiAgfSkpO1xuICBjb25zdCBzY3JvbGxPcHRpb25zID0ge1xuICAgIHNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseTogbW92ZW1lbnRNb2RlID09PSAnU05BUCdcbiAgfTtcbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogaWQsXG4gICAgc2Nyb2xsT3B0aW9uc1xuICB9O1xuICBjb25zdCB7XG4gICAgY3JpdGljYWwsXG4gICAgZGltZW5zaW9ucyxcbiAgICB2aWV3cG9ydFxuICB9ID0gbWFyc2hhbC5zdGFydFB1Ymxpc2hpbmcocmVxdWVzdCk7XG4gIHZhbGlkYXRlRGltZW5zaW9ucyhjcml0aWNhbCwgZGltZW5zaW9ucyk7XG4gIGRpc3BhdGNoKGluaXRpYWxQdWJsaXNoKHtcbiAgICBjcml0aWNhbCxcbiAgICBkaW1lbnNpb25zLFxuICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICBtb3ZlbWVudE1vZGUsXG4gICAgdmlld3BvcnRcbiAgfSkpO1xufTtcblxudmFyIHN0eWxlID0gbWFyc2hhbCA9PiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgIG1hcnNoYWwuZHJhZ2dpbmcoKTtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICBtYXJzaGFsLmRyb3BwaW5nKGFjdGlvbi5wYXlsb2FkLmNvbXBsZXRlZC5yZXN1bHQucmVhc29uKTtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykpIHtcbiAgICBtYXJzaGFsLnJlc3RpbmcoKTtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG59O1xuXG5jb25zdCBjdXJ2ZXMgPSB7XG4gIG91dE9mVGhlV2F5OiAnY3ViaWMtYmV6aWVyKDAuMiwgMCwgMCwgMSknLFxuICBkcm9wOiAnY3ViaWMtYmV6aWVyKC4yLDEsLjEsMSknXG59O1xuY29uc3QgY29tYmluZSA9IHtcbiAgb3BhY2l0eToge1xuICAgIGRyb3A6IDAsXG4gICAgY29tYmluaW5nOiAwLjdcbiAgfSxcbiAgc2NhbGU6IHtcbiAgICBkcm9wOiAwLjc1XG4gIH1cbn07XG5jb25zdCB0aW1pbmdzID0ge1xuICBvdXRPZlRoZVdheTogMC4yLFxuICBtaW5Ecm9wVGltZTogMC4zMyxcbiAgbWF4RHJvcFRpbWU6IDAuNTVcbn07XG5jb25zdCBvdXRPZlRoZVdheVRpbWluZyA9IGAke3RpbWluZ3Mub3V0T2ZUaGVXYXl9cyAke2N1cnZlcy5vdXRPZlRoZVdheX1gO1xuY29uc3QgdHJhbnNpdGlvbnMgPSB7XG4gIGZsdWlkOiBgb3BhY2l0eSAke291dE9mVGhlV2F5VGltaW5nfWAsXG4gIHNuYXA6IGB0cmFuc2Zvcm0gJHtvdXRPZlRoZVdheVRpbWluZ30sIG9wYWNpdHkgJHtvdXRPZlRoZVdheVRpbWluZ31gLFxuICBkcm9wOiBkdXJhdGlvbiA9PiB7XG4gICAgY29uc3QgdGltaW5nID0gYCR7ZHVyYXRpb259cyAke2N1cnZlcy5kcm9wfWA7XG4gICAgcmV0dXJuIGB0cmFuc2Zvcm0gJHt0aW1pbmd9LCBvcGFjaXR5ICR7dGltaW5nfWA7XG4gIH0sXG4gIG91dE9mVGhlV2F5OiBgdHJhbnNmb3JtICR7b3V0T2ZUaGVXYXlUaW1pbmd9YCxcbiAgcGxhY2Vob2xkZXI6IGBoZWlnaHQgJHtvdXRPZlRoZVdheVRpbWluZ30sIHdpZHRoICR7b3V0T2ZUaGVXYXlUaW1pbmd9LCBtYXJnaW4gJHtvdXRPZlRoZVdheVRpbWluZ31gXG59O1xuY29uc3QgbW92ZVRvID0gb2Zmc2V0ID0+IGlzRXF1YWwkMShvZmZzZXQsIG9yaWdpbikgPyB1bmRlZmluZWQgOiBgdHJhbnNsYXRlKCR7b2Zmc2V0Lnh9cHgsICR7b2Zmc2V0Lnl9cHgpYDtcbmNvbnN0IHRyYW5zZm9ybXMgPSB7XG4gIG1vdmVUbyxcbiAgZHJvcDogKG9mZnNldCwgaXNDb21iaW5pbmcpID0+IHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBtb3ZlVG8ob2Zmc2V0KTtcbiAgICBpZiAoIXRyYW5zbGF0ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFpc0NvbWJpbmluZykge1xuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RyYW5zbGF0ZX0gc2NhbGUoJHtjb21iaW5lLnNjYWxlLmRyb3B9KWA7XG4gIH1cbn07XG5cbmNvbnN0IHtcbiAgbWluRHJvcFRpbWUsXG4gIG1heERyb3BUaW1lXG59ID0gdGltaW5ncztcbmNvbnN0IGRyb3BUaW1lUmFuZ2UgPSBtYXhEcm9wVGltZSAtIG1pbkRyb3BUaW1lO1xuY29uc3QgbWF4RHJvcFRpbWVBdERpc3RhbmNlID0gMTUwMDtcbmNvbnN0IGNhbmNlbERyb3BNb2RpZmllciA9IDAuNjtcbnZhciBnZXREcm9wRHVyYXRpb24gPSAoe1xuICBjdXJyZW50LFxuICBkZXN0aW5hdGlvbixcbiAgcmVhc29uXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlJDEgPSBkaXN0YW5jZShjdXJyZW50LCBkZXN0aW5hdGlvbik7XG4gIGlmIChkaXN0YW5jZSQxIDw9IDApIHtcbiAgICByZXR1cm4gbWluRHJvcFRpbWU7XG4gIH1cbiAgaWYgKGRpc3RhbmNlJDEgPj0gbWF4RHJvcFRpbWVBdERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIG1heERyb3BUaW1lO1xuICB9XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBkaXN0YW5jZSQxIC8gbWF4RHJvcFRpbWVBdERpc3RhbmNlO1xuICBjb25zdCBkdXJhdGlvbiA9IG1pbkRyb3BUaW1lICsgZHJvcFRpbWVSYW5nZSAqIHBlcmNlbnRhZ2U7XG4gIGNvbnN0IHdpdGhEdXJhdGlvbiA9IHJlYXNvbiA9PT0gJ0NBTkNFTCcgPyBkdXJhdGlvbiAqIGNhbmNlbERyb3BNb2RpZmllciA6IGR1cmF0aW9uO1xuICByZXR1cm4gTnVtYmVyKHdpdGhEdXJhdGlvbi50b0ZpeGVkKDIpKTtcbn07XG5cbnZhciBnZXROZXdIb21lQ2xpZW50T2Zmc2V0ID0gKHtcbiAgaW1wYWN0LFxuICBkcmFnZ2FibGUsXG4gIGRpbWVuc2lvbnMsXG4gIHZpZXdwb3J0LFxuICBhZnRlckNyaXRpY2FsXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGVzLFxuICAgIGRyb3BwYWJsZXNcbiAgfSA9IGRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyb3BwYWJsZUlkID0gd2hhdElzRHJhZ2dlZE92ZXIoaW1wYWN0KTtcbiAgY29uc3QgZGVzdGluYXRpb24gPSBkcm9wcGFibGVJZCA/IGRyb3BwYWJsZXNbZHJvcHBhYmxlSWRdIDogbnVsbDtcbiAgY29uc3QgaG9tZSA9IGRyb3BwYWJsZXNbZHJhZ2dhYmxlLmRlc2NyaXB0b3IuZHJvcHBhYmxlSWRdO1xuICBjb25zdCBuZXdDbGllbnRDZW50ZXIgPSBnZXRDbGllbnRCb3JkZXJCb3hDZW50ZXIoe1xuICAgIGltcGFjdCxcbiAgICBkcmFnZ2FibGUsXG4gICAgZHJhZ2dhYmxlcyxcbiAgICBhZnRlckNyaXRpY2FsLFxuICAgIGRyb3BwYWJsZTogZGVzdGluYXRpb24gfHwgaG9tZSxcbiAgICB2aWV3cG9ydFxuICB9KTtcbiAgY29uc3Qgb2Zmc2V0ID0gc3VidHJhY3QobmV3Q2xpZW50Q2VudGVyLCBkcmFnZ2FibGUuY2xpZW50LmJvcmRlckJveC5jZW50ZXIpO1xuICByZXR1cm4gb2Zmc2V0O1xufTtcblxudmFyIGdldERyb3BJbXBhY3QgPSAoe1xuICBkcmFnZ2FibGVzLFxuICByZWFzb24sXG4gIGxhc3RJbXBhY3QsXG4gIGhvbWUsXG4gIHZpZXdwb3J0LFxuICBvbkxpZnRJbXBhY3Rcbn0pID0+IHtcbiAgaWYgKCFsYXN0SW1wYWN0LmF0IHx8IHJlYXNvbiAhPT0gJ0RST1AnKSB7XG4gICAgY29uc3QgcmVjb21wdXRlZEhvbWVJbXBhY3QgPSByZWNvbXB1dGUoe1xuICAgICAgZHJhZ2dhYmxlcyxcbiAgICAgIGltcGFjdDogb25MaWZ0SW1wYWN0LFxuICAgICAgZGVzdGluYXRpb246IGhvbWUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IHJlY29tcHV0ZWRIb21lSW1wYWN0LFxuICAgICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGlmIChsYXN0SW1wYWN0LmF0LnR5cGUgPT09ICdSRU9SREVSJykge1xuICAgIHJldHVybiB7XG4gICAgICBpbXBhY3Q6IGxhc3RJbXBhY3QsXG4gICAgICBkaWREcm9wSW5zaWRlRHJvcHBhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuICBjb25zdCB3aXRob3V0TW92ZW1lbnQgPSB7XG4gICAgLi4ubGFzdEltcGFjdCxcbiAgICBkaXNwbGFjZWQ6IGVtcHR5R3JvdXBzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaW1wYWN0OiB3aXRob3V0TW92ZW1lbnQsXG4gICAgZGlkRHJvcEluc2lkZURyb3BwYWJsZTogdHJ1ZVxuICB9O1xufTtcblxuY29uc3QgZHJvcE1pZGRsZXdhcmUgPSAoe1xuICBnZXRTdGF0ZSxcbiAgZGlzcGF0Y2hcbn0pID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdEUk9QJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgcmVhc29uID0gYWN0aW9uLnBheWxvYWQucmVhc29uO1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdDT0xMRUNUSU5HJykge1xuICAgIGRpc3BhdGNoKGRyb3BQZW5kaW5nKHtcbiAgICAgIHJlYXNvblxuICAgIH0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaXNXYWl0aW5nRm9yRHJvcCA9IHN0YXRlLnBoYXNlID09PSAnRFJPUF9QRU5ESU5HJyAmJiBzdGF0ZS5pc1dhaXRpbmc7XG4gICEhaXNXYWl0aW5nRm9yRHJvcCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRFJPUCBhY3Rpb24gb2NjdXJyZWQgd2hpbGUgRFJPUF9QRU5ESU5HIGFuZCBzdGlsbCB3YWl0aW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgIShzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGRyb3AgaW4gcGhhc2U6ICR7c3RhdGUucGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgY3JpdGljYWwgPSBzdGF0ZS5jcml0aWNhbDtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHN0YXRlLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGRyYWdnYWJsZSA9IGRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tzdGF0ZS5jcml0aWNhbC5kcmFnZ2FibGUuaWRdO1xuICBjb25zdCB7XG4gICAgaW1wYWN0LFxuICAgIGRpZERyb3BJbnNpZGVEcm9wcGFibGVcbiAgfSA9IGdldERyb3BJbXBhY3Qoe1xuICAgIHJlYXNvbixcbiAgICBsYXN0SW1wYWN0OiBzdGF0ZS5pbXBhY3QsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICBvbkxpZnRJbXBhY3Q6IHN0YXRlLm9uTGlmdEltcGFjdCxcbiAgICBob21lOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbc3RhdGUuY3JpdGljYWwuZHJvcHBhYmxlLmlkXSxcbiAgICB2aWV3cG9ydDogc3RhdGUudmlld3BvcnQsXG4gICAgZHJhZ2dhYmxlczogc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzXG4gIH0pO1xuICBjb25zdCBkZXN0aW5hdGlvbiA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpIDogbnVsbDtcbiAgY29uc3QgY29tYmluZSA9IGRpZERyb3BJbnNpZGVEcm9wcGFibGUgPyB0cnlHZXRDb21iaW5lKGltcGFjdCkgOiBudWxsO1xuICBjb25zdCBzb3VyY2UgPSB7XG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleCxcbiAgICBkcm9wcGFibGVJZDogY3JpdGljYWwuZHJvcHBhYmxlLmlkXG4gIH07XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkcmFnZ2FibGVJZDogZHJhZ2dhYmxlLmRlc2NyaXB0b3IuaWQsXG4gICAgdHlwZTogZHJhZ2dhYmxlLmRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2UsXG4gICAgcmVhc29uLFxuICAgIG1vZGU6IHN0YXRlLm1vdmVtZW50TW9kZSxcbiAgICBkZXN0aW5hdGlvbixcbiAgICBjb21iaW5lXG4gIH07XG4gIGNvbnN0IG5ld0hvbWVDbGllbnRPZmZzZXQgPSBnZXROZXdIb21lQ2xpZW50T2Zmc2V0KHtcbiAgICBpbXBhY3QsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGRpbWVuc2lvbnMsXG4gICAgdmlld3BvcnQ6IHN0YXRlLnZpZXdwb3J0LFxuICAgIGFmdGVyQ3JpdGljYWw6IHN0YXRlLmFmdGVyQ3JpdGljYWxcbiAgfSk7XG4gIGNvbnN0IGNvbXBsZXRlZCA9IHtcbiAgICBjcml0aWNhbDogc3RhdGUuY3JpdGljYWwsXG4gICAgYWZ0ZXJDcml0aWNhbDogc3RhdGUuYWZ0ZXJDcml0aWNhbCxcbiAgICByZXN1bHQsXG4gICAgaW1wYWN0XG4gIH07XG4gIGNvbnN0IGlzQW5pbWF0aW9uUmVxdWlyZWQgPSAhaXNFcXVhbCQxKHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldCwgbmV3SG9tZUNsaWVudE9mZnNldCkgfHwgQm9vbGVhbihyZXN1bHQuY29tYmluZSk7XG4gIGlmICghaXNBbmltYXRpb25SZXF1aXJlZCkge1xuICAgIGRpc3BhdGNoKGNvbXBsZXRlRHJvcCh7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRyb3BEdXJhdGlvbiA9IGdldERyb3BEdXJhdGlvbih7XG4gICAgY3VycmVudDogc3RhdGUuY3VycmVudC5jbGllbnQub2Zmc2V0LFxuICAgIGRlc3RpbmF0aW9uOiBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIHJlYXNvblxuICB9KTtcbiAgY29uc3QgYXJncyA9IHtcbiAgICBuZXdIb21lQ2xpZW50T2Zmc2V0LFxuICAgIGRyb3BEdXJhdGlvbixcbiAgICBjb21wbGV0ZWRcbiAgfTtcbiAgZGlzcGF0Y2goYW5pbWF0ZURyb3AoYXJncykpO1xufTtcblxudmFyIGdldFdpbmRvd1Njcm9sbCA9ICgpID0+ICh7XG4gIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG59KTtcblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmluZGluZyh1cGRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudE5hbWU6ICdzY3JvbGwnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0sXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHdpbmRvdyAmJiBldmVudC50YXJnZXQgIT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxMaXN0ZW5lcih7XG4gIG9uV2luZG93U2Nyb2xsXG59KSB7XG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpIHtcbiAgICBvbldpbmRvd1Njcm9sbChnZXRXaW5kb3dTY3JvbGwoKSk7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVkID0gcmFmU2NoZCh1cGRhdGVTY3JvbGwpO1xuICBjb25zdCBiaW5kaW5nID0gZ2V0V2luZG93U2Nyb2xsQmluZGluZyhzY2hlZHVsZWQpO1xuICBsZXQgdW5iaW5kID0gbm9vcCQyO1xuICBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdW5iaW5kICE9PSBub29wJDI7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgISFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IHNjcm9sbCBsaXN0ZW5lciB3aGVuIGFscmVhZHkgYWN0aXZlJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICFpc0FjdGl2ZSgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0b3Agc2Nyb2xsIGxpc3RlbmVyIHdoZW4gbm90IGFjdGl2ZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgc2NoZWR1bGVkLmNhbmNlbCgpO1xuICAgIHVuYmluZCgpO1xuICAgIHVuYmluZCA9IG5vb3AkMjtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgaXNBY3RpdmVcbiAgfTtcbn1cblxuY29uc3Qgc2hvdWxkU3RvcCQxID0gYWN0aW9uID0+IGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVEUnKSB8fCBndWFyZChhY3Rpb24sICdGTFVTSCcpO1xuY29uc3Qgc2Nyb2xsTGlzdGVuZXIgPSBzdG9yZSA9PiB7XG4gIGNvbnN0IGxpc3RlbmVyID0gZ2V0U2Nyb2xsTGlzdGVuZXIoe1xuICAgIG9uV2luZG93U2Nyb2xsOiBuZXdTY3JvbGwgPT4ge1xuICAgICAgc3RvcmUuZGlzcGF0Y2gobW92ZUJ5V2luZG93U2Nyb2xsKHtcbiAgICAgICAgbmV3U2Nyb2xsXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoIWxpc3RlbmVyLmlzQWN0aXZlKCkgJiYgZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICAgIGxpc3RlbmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5pc0FjdGl2ZSgpICYmIHNob3VsZFN0b3AkMShhY3Rpb24pKSB7XG4gICAgICBsaXN0ZW5lci5zdG9wKCk7XG4gICAgfVxuICAgIG5leHQoYWN0aW9uKTtcbiAgfTtcbn07XG5cbnZhciBnZXRFeHBpcmluZ0Fubm91bmNlID0gYW5ub3VuY2UgPT4ge1xuICBsZXQgd2FzQ2FsbGVkID0gZmFsc2U7XG4gIGxldCBpc0V4cGlyZWQgPSBmYWxzZTtcbiAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaXNFeHBpcmVkID0gdHJ1ZTtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IG1lc3NhZ2UgPT4ge1xuICAgIGlmICh3YXNDYWxsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ0Fubm91bmNlbWVudCBhbHJlYWR5IG1hZGUuIE5vdCBtYWtpbmcgYSBzZWNvbmQgYW5ub3VuY2VtZW50JykgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBBbm5vdW5jZW1lbnRzIGNhbm5vdCBiZSBtYWRlIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICBEZWZhdWx0IG1lc3NhZ2UgaGFzIGFscmVhZHkgYmVlbiBhbm5vdW5jZWQuXG4gICAgICBgKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FzQ2FsbGVkID0gdHJ1ZTtcbiAgICBhbm5vdW5jZShtZXNzYWdlKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfTtcbiAgcmVzdWx0Lndhc0NhbGxlZCA9ICgpID0+IHdhc0NhbGxlZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBnZXRBc3luY01hcnNoYWwgPSAoKSA9PiB7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgZXhlY3V0ZSA9IHRpbWVySWQgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLnRpbWVySWQgPT09IHRpbWVySWQpO1xuICAgICEoaW5kZXggIT09IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHRpbWVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBbZW50cnldID0gZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gIH07XG4gIGNvbnN0IGFkZCA9IGZuID0+IHtcbiAgICBjb25zdCB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiBleGVjdXRlKHRpbWVySWQpKTtcbiAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgIHRpbWVySWQsXG4gICAgICBjYWxsYmFjazogZm5cbiAgICB9O1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hhbGxvdyA9IFsuLi5lbnRyaWVzXTtcbiAgICBlbnRyaWVzLmxlbmd0aCA9IDA7XG4gICAgc2hhbGxvdy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChlbnRyeS50aW1lcklkKTtcbiAgICAgIGVudHJ5LmNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkLFxuICAgIGZsdXNoXG4gIH07XG59O1xuXG5jb25zdCBhcmVMb2NhdGlvbnNFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJvcHBhYmxlSWQgJiYgZmlyc3QuaW5kZXggPT09IHNlY29uZC5pbmRleDtcbn07XG5jb25zdCBpc0NvbWJpbmVFcXVhbCA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gIGlmIChmaXJzdCA9PSBudWxsICYmIHNlY29uZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGZpcnN0ID09IG51bGwgfHwgc2Vjb25kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpcnN0LmRyYWdnYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlSWQgJiYgZmlyc3QuZHJvcHBhYmxlSWQgPT09IHNlY29uZC5kcm9wcGFibGVJZDtcbn07XG5jb25zdCBpc0NyaXRpY2FsRXF1YWwgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGlzRHJhZ2dhYmxlRXF1YWwgPSBmaXJzdC5kcmFnZ2FibGUuaWQgPT09IHNlY29uZC5kcmFnZ2FibGUuaWQgJiYgZmlyc3QuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkID09PSBzZWNvbmQuZHJhZ2dhYmxlLmRyb3BwYWJsZUlkICYmIGZpcnN0LmRyYWdnYWJsZS50eXBlID09PSBzZWNvbmQuZHJhZ2dhYmxlLnR5cGUgJiYgZmlyc3QuZHJhZ2dhYmxlLmluZGV4ID09PSBzZWNvbmQuZHJhZ2dhYmxlLmluZGV4O1xuICBjb25zdCBpc0Ryb3BwYWJsZUVxdWFsID0gZmlyc3QuZHJvcHBhYmxlLmlkID09PSBzZWNvbmQuZHJvcHBhYmxlLmlkICYmIGZpcnN0LmRyb3BwYWJsZS50eXBlID09PSBzZWNvbmQuZHJvcHBhYmxlLnR5cGU7XG4gIHJldHVybiBpc0RyYWdnYWJsZUVxdWFsICYmIGlzRHJvcHBhYmxlRXF1YWw7XG59O1xuXG5jb25zdCB3aXRoVGltaW5ncyA9IChrZXksIGZuKSA9PiB7XG4gIHN0YXJ0KCk7XG4gIGZuKCk7XG4gIGZpbmlzaCgpO1xufTtcbmNvbnN0IGdldERyYWdTdGFydCA9IChjcml0aWNhbCwgbW9kZSkgPT4gKHtcbiAgZHJhZ2dhYmxlSWQ6IGNyaXRpY2FsLmRyYWdnYWJsZS5pZCxcbiAgdHlwZTogY3JpdGljYWwuZHJvcHBhYmxlLnR5cGUsXG4gIHNvdXJjZToge1xuICAgIGRyb3BwYWJsZUlkOiBjcml0aWNhbC5kcm9wcGFibGUuaWQsXG4gICAgaW5kZXg6IGNyaXRpY2FsLmRyYWdnYWJsZS5pbmRleFxuICB9LFxuICBtb2RlXG59KTtcbmZ1bmN0aW9uIGV4ZWN1dGUocmVzcG9uZGVyLCBkYXRhLCBhbm5vdW5jZSwgZ2V0RGVmYXVsdE1lc3NhZ2UpIHtcbiAgaWYgKCFyZXNwb25kZXIpIHtcbiAgICBhbm5vdW5jZShnZXREZWZhdWx0TWVzc2FnZShkYXRhKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpbGxFeHBpcmUgPSBnZXRFeHBpcmluZ0Fubm91bmNlKGFubm91bmNlKTtcbiAgY29uc3QgcHJvdmlkZWQgPSB7XG4gICAgYW5ub3VuY2U6IHdpbGxFeHBpcmVcbiAgfTtcbiAgcmVzcG9uZGVyKGRhdGEsIHByb3ZpZGVkKTtcbiAgaWYgKCF3aWxsRXhwaXJlLndhc0NhbGxlZCgpKSB7XG4gICAgYW5ub3VuY2UoZ2V0RGVmYXVsdE1lc3NhZ2UoZGF0YSkpO1xuICB9XG59XG52YXIgZ2V0UHVibGlzaGVyID0gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IGFzeW5jTWFyc2hhbCA9IGdldEFzeW5jTWFyc2hhbCgpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCBiZWZvcmVDYXB0dXJlID0gKGRyYWdnYWJsZUlkLCBtb2RlKSA9PiB7XG4gICAgISFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uQmVmb3JlQ2FwdHVyZSBhcyBhIGRyYWcgc3RhcnQgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIHdpdGhUaW1pbmdzKCdvbkJlZm9yZUNhcHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZUNhcHR1cmU7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlID0ge1xuICAgICAgICAgIGRyYWdnYWJsZUlkLFxuICAgICAgICAgIG1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgZm4oYmVmb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgYmVmb3JlU3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICB3aXRoVGltaW5ncygnb25CZWZvcmVEcmFnU3RhcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IGdldFJlc3BvbmRlcnMoKS5vbkJlZm9yZURyYWdTdGFydDtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihnZXREcmFnU3RhcnQoY3JpdGljYWwsIG1vZGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc3RhcnQgPSAoY3JpdGljYWwsIG1vZGUpID0+IHtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25CZWZvcmVEcmFnU3RhcnQgYXMgYSBkcmFnIHN0YXJ0IGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkYXRhID0gZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBtb2RlKTtcbiAgICBkcmFnZ2luZyA9IHtcbiAgICAgIG1vZGUsXG4gICAgICBsYXN0Q3JpdGljYWw6IGNyaXRpY2FsLFxuICAgICAgbGFzdExvY2F0aW9uOiBkYXRhLnNvdXJjZSxcbiAgICAgIGxhc3RDb21iaW5lOiBudWxsXG4gICAgfTtcbiAgICBhc3luY01hcnNoYWwuYWRkKCgpID0+IHtcbiAgICAgIHdpdGhUaW1pbmdzKCdvbkRyYWdTdGFydCcsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1N0YXJ0LCBkYXRhLCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ1N0YXJ0KSk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZSA9IChjcml0aWNhbCwgaW1wYWN0KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0cnlHZXREZXN0aW5hdGlvbihpbXBhY3QpO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpcmUgb25EcmFnTW92ZSB3aGVuIG9uRHJhZ1N0YXJ0IGhhcyBub3QgYmVlbiBjYWxsZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGhhc0NyaXRpY2FsQ2hhbmdlZCA9ICFpc0NyaXRpY2FsRXF1YWwoY3JpdGljYWwsIGRyYWdnaW5nLmxhc3RDcml0aWNhbCk7XG4gICAgaWYgKGhhc0NyaXRpY2FsQ2hhbmdlZCkge1xuICAgICAgZHJhZ2dpbmcubGFzdENyaXRpY2FsID0gY3JpdGljYWw7XG4gICAgfVxuICAgIGNvbnN0IGhhc0xvY2F0aW9uQ2hhbmdlZCA9ICFhcmVMb2NhdGlvbnNFcXVhbChkcmFnZ2luZy5sYXN0TG9jYXRpb24sIGxvY2F0aW9uKTtcbiAgICBpZiAoaGFzTG9jYXRpb25DaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgaGFzR3JvdXBpbmdDaGFuZ2VkID0gIWlzQ29tYmluZUVxdWFsKGRyYWdnaW5nLmxhc3RDb21iaW5lLCBjb21iaW5lKTtcbiAgICBpZiAoaGFzR3JvdXBpbmdDaGFuZ2VkKSB7XG4gICAgICBkcmFnZ2luZy5sYXN0Q29tYmluZSA9IGNvbWJpbmU7XG4gICAgfVxuICAgIGlmICghaGFzQ3JpdGljYWxDaGFuZ2VkICYmICFoYXNMb2NhdGlvbkNoYW5nZWQgJiYgIWhhc0dyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgLi4uZ2V0RHJhZ1N0YXJ0KGNyaXRpY2FsLCBkcmFnZ2luZy5tb2RlKSxcbiAgICAgIGNvbWJpbmUsXG4gICAgICBkZXN0aW5hdGlvbjogbG9jYXRpb25cbiAgICB9O1xuICAgIGFzeW5jTWFyc2hhbC5hZGQoKCkgPT4ge1xuICAgICAgd2l0aFRpbWluZ3MoJ29uRHJhZ1VwZGF0ZScsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ1VwZGF0ZSwgZGF0YSwgYW5ub3VuY2UsIHByZXNldC5vbkRyYWdVcGRhdGUpKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgZmx1c2ggcmVzcG9uZGVycyB3aGlsZSBkcmFnZ2luZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgYXN5bmNNYXJzaGFsLmZsdXNoKCk7XG4gIH07XG4gIGNvbnN0IGRyb3AgPSByZXN1bHQgPT4ge1xuICAgICFkcmFnZ2luZyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBmaXJlIG9uRHJhZ0VuZCB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIG9uRHJhZ1N0YXJ0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBkcmFnZ2luZyA9IG51bGw7XG4gICAgd2l0aFRpbWluZ3MoJ29uRHJhZ0VuZCcsICgpID0+IGV4ZWN1dGUoZ2V0UmVzcG9uZGVycygpLm9uRHJhZ0VuZCwgcmVzdWx0LCBhbm5vdW5jZSwgcHJlc2V0Lm9uRHJhZ0VuZCkpO1xuICB9O1xuICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIC4uLmdldERyYWdTdGFydChkcmFnZ2luZy5sYXN0Q3JpdGljYWwsIGRyYWdnaW5nLm1vZGUpLFxuICAgICAgY29tYmluZTogbnVsbCxcbiAgICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgcmVhc29uOiAnQ0FOQ0VMJ1xuICAgIH07XG4gICAgZHJvcChyZXN1bHQpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGJlZm9yZUNhcHR1cmUsXG4gICAgYmVmb3JlU3RhcnQsXG4gICAgc3RhcnQsXG4gICAgdXBkYXRlLFxuICAgIGZsdXNoLFxuICAgIGRyb3AsXG4gICAgYWJvcnRcbiAgfTtcbn07XG5cbnZhciByZXNwb25kZXJzID0gKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSA9PiB7XG4gIGNvbnN0IHB1Ymxpc2hlciA9IGdldFB1Ymxpc2hlcihnZXRSZXNwb25kZXJzLCBhbm5vdW5jZSk7XG4gIHJldHVybiBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0JFRk9SRV9JTklUSUFMX0NBUFRVUkUnKSkge1xuICAgICAgcHVibGlzaGVyLmJlZm9yZUNhcHR1cmUoYWN0aW9uLnBheWxvYWQuZHJhZ2dhYmxlSWQsIGFjdGlvbi5wYXlsb2FkLm1vdmVtZW50TW9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChndWFyZChhY3Rpb24sICdJTklUSUFMX1BVQkxJU0gnKSkge1xuICAgICAgY29uc3QgY3JpdGljYWwgPSBhY3Rpb24ucGF5bG9hZC5jcml0aWNhbDtcbiAgICAgIHB1Ymxpc2hlci5iZWZvcmVTdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIHB1Ymxpc2hlci5zdGFydChjcml0aWNhbCwgYWN0aW9uLnBheWxvYWQubW92ZW1lbnRNb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0RST1BfQ09NUExFVEUnKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYWN0aW9uLnBheWxvYWQuY29tcGxldGVkLnJlc3VsdDtcbiAgICAgIHB1Ymxpc2hlci5mbHVzaCgpO1xuICAgICAgbmV4dChhY3Rpb24pO1xuICAgICAgcHVibGlzaGVyLmRyb3AocmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmIChndWFyZChhY3Rpb24sICdGTFVTSCcpKSB7XG4gICAgICBwdWJsaXNoZXIuYWJvcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcHVibGlzaGVyLnVwZGF0ZShzdGF0ZS5jcml0aWNhbCwgc3RhdGUuaW1wYWN0KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSA9IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKCFndWFyZChhY3Rpb24sICdEUk9QX0FOSU1BVElPTl9GSU5JU0hFRCcpKSB7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICEoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmlzaCBhIGRyb3AgYW5pbWF0aW5nIHdoZW4gbm8gZHJvcCBpcyBvY2N1cnJpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICBzdG9yZS5kaXNwYXRjaChjb21wbGV0ZURyb3Aoe1xuICAgIGNvbXBsZXRlZDogc3RhdGUuY29tcGxldGVkXG4gIH0pKTtcbn07XG5cbmNvbnN0IGRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZSA9IHN0b3JlID0+IHtcbiAgbGV0IHVuYmluZCA9IG51bGw7XG4gIGxldCBmcmFtZUlkID0gbnVsbDtcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh1bmJpbmQpIHtcbiAgICAgIHVuYmluZCgpO1xuICAgICAgdW5iaW5kID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSB8fCBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRJT05fRklOSVNIRUQnKSkge1xuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZm46IGZ1bmN0aW9uIGZsdXNoRHJvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgICAgICBzdG9yZS5kaXNwYXRjaChkcm9wQW5pbWF0aW9uRmluaXNoZWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgZnJhbWVJZCA9IG51bGw7XG4gICAgICB1bmJpbmQgPSBiaW5kRXZlbnRzKHdpbmRvdywgW2JpbmRpbmddKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbnZhciBkaW1lbnNpb25NYXJzaGFsU3RvcHBlciA9IG1hcnNoYWwgPT4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4ge1xuICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpIHx8IGd1YXJkKGFjdGlvbiwgJ0ZMVVNIJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykpIHtcbiAgICBtYXJzaGFsLnN0b3BQdWJsaXNoaW5nKCk7XG4gIH1cbiAgbmV4dChhY3Rpb24pO1xufTtcblxudmFyIGZvY3VzID0gbWFyc2hhbCA9PiB7XG4gIGxldCBpc1dhdGNoaW5nID0gZmFsc2U7XG4gIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgaWYgKGd1YXJkKGFjdGlvbiwgJ0lOSVRJQUxfUFVCTElTSCcpKSB7XG4gICAgICBpc1dhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIG1hcnNoYWwudHJ5UmVjb3JkRm9jdXMoYWN0aW9uLnBheWxvYWQuY3JpdGljYWwuZHJhZ2dhYmxlLmlkKTtcbiAgICAgIG5leHQoYWN0aW9uKTtcbiAgICAgIG1hcnNoYWwudHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIGlmICghaXNXYXRjaGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKSkge1xuICAgICAgaXNXYXRjaGluZyA9IGZhbHNlO1xuICAgICAgbWFyc2hhbC50cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQoYWN0aW9uLCAnRFJPUF9DT01QTEVURScpKSB7XG4gICAgICBpc1dhdGNoaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCByZXN1bHQgPSBhY3Rpb24ucGF5bG9hZC5jb21wbGV0ZWQucmVzdWx0O1xuICAgICAgaWYgKHJlc3VsdC5jb21iaW5lKSB7XG4gICAgICAgIG1hcnNoYWwudHJ5U2hpZnRSZWNvcmQocmVzdWx0LmRyYWdnYWJsZUlkLCByZXN1bHQuY29tYmluZS5kcmFnZ2FibGVJZCk7XG4gICAgICB9XG4gICAgICBtYXJzaGFsLnRyeVJlc3RvcmVGb2N1c1JlY29yZGVkKCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3Qgc2hvdWxkU3RvcCA9IGFjdGlvbiA9PiBndWFyZChhY3Rpb24sICdEUk9QX0NPTVBMRVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRFJPUF9BTklNQVRFJykgfHwgZ3VhcmQoYWN0aW9uLCAnRkxVU0gnKTtcbnZhciBhdXRvU2Nyb2xsID0gYXV0b1Njcm9sbGVyID0+IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKHNob3VsZFN0b3AoYWN0aW9uKSkge1xuICAgIGF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgbmV4dChhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ3VhcmQoYWN0aW9uLCAnSU5JVElBTF9QVUJMSVNIJykpIHtcbiAgICBuZXh0KGFjdGlvbik7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICEoc3RhdGUucGhhc2UgPT09ICdEUkFHR0lORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcGhhc2UgdG8gYmUgRFJBR0dJTkcgYWZ0ZXIgSU5JVElBTF9QVUJMSVNIJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBhdXRvU2Nyb2xsZXIuc3RhcnQoc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBuZXh0KGFjdGlvbik7XG4gIGF1dG9TY3JvbGxlci5zY3JvbGwoc3RvcmUuZ2V0U3RhdGUoKSk7XG59O1xuXG5jb25zdCBwZW5kaW5nRHJvcCA9IHN0b3JlID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgbmV4dChhY3Rpb24pO1xuICBpZiAoIWd1YXJkKGFjdGlvbiwgJ1BVQkxJU0hfV0hJTEVfRFJBR0dJTkcnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwb3N0QWN0aW9uU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBpZiAocG9zdEFjdGlvblN0YXRlLnBoYXNlICE9PSAnRFJPUF9QRU5ESU5HJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocG9zdEFjdGlvblN0YXRlLmlzV2FpdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9yZS5kaXNwYXRjaChkcm9wKHtcbiAgICByZWFzb246IHBvc3RBY3Rpb25TdGF0ZS5yZWFzb25cbiAgfSkpO1xufTtcblxuY29uc3QgY29tcG9zZUVuaGFuY2VycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18oe1xuICBuYW1lOiAnQGhlbGxvLXBhbmdlYS9kbmQnXG59KSA6IGNvbXBvc2U7XG52YXIgY3JlYXRlU3RvcmUgPSAoe1xuICBkaW1lbnNpb25NYXJzaGFsLFxuICBmb2N1c01hcnNoYWwsXG4gIHN0eWxlTWFyc2hhbCxcbiAgZ2V0UmVzcG9uZGVycyxcbiAgYW5ub3VuY2UsXG4gIGF1dG9TY3JvbGxlclxufSkgPT4gY3JlYXRlU3RvcmUkMShyZWR1Y2VyLCBjb21wb3NlRW5oYW5jZXJzKGFwcGx5TWlkZGxld2FyZShzdHlsZShzdHlsZU1hcnNoYWwpLCBkaW1lbnNpb25NYXJzaGFsU3RvcHBlcihkaW1lbnNpb25NYXJzaGFsKSwgbGlmdChkaW1lbnNpb25NYXJzaGFsKSwgZHJvcE1pZGRsZXdhcmUsIGRyb3BBbmltYXRpb25GaW5pc2hNaWRkbGV3YXJlLCBkcm9wQW5pbWF0aW9uRmx1c2hPblNjcm9sbE1pZGRsZXdhcmUsIHBlbmRpbmdEcm9wLCBhdXRvU2Nyb2xsKGF1dG9TY3JvbGxlciksIHNjcm9sbExpc3RlbmVyLCBmb2N1cyhmb2N1c01hcnNoYWwpLCByZXNwb25kZXJzKGdldFJlc3BvbmRlcnMsIGFubm91bmNlKSkpKTtcblxuY29uc3QgY2xlYW4kMSA9ICgpID0+ICh7XG4gIGFkZGl0aW9uczoge30sXG4gIHJlbW92YWxzOiB7fSxcbiAgbW9kaWZpZWQ6IHt9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVB1Ymxpc2hlcih7XG4gIHJlZ2lzdHJ5LFxuICBjYWxsYmFja3Ncbn0pIHtcbiAgbGV0IHN0YWdpbmcgPSBjbGVhbiQxKCk7XG4gIGxldCBmcmFtZUlkID0gbnVsbDtcbiAgY29uc3QgY29sbGVjdCA9ICgpID0+IHtcbiAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MuY29sbGVjdGlvblN0YXJ0aW5nKCk7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBmcmFtZUlkID0gbnVsbDtcbiAgICAgIHN0YXJ0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFkZGl0aW9ucyxcbiAgICAgICAgcmVtb3ZhbHMsXG4gICAgICAgIG1vZGlmaWVkXG4gICAgICB9ID0gc3RhZ2luZztcbiAgICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoYWRkaXRpb25zKS5tYXAoaWQgPT4gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQoaWQpLmdldERpbWVuc2lvbihvcmlnaW4pKS5zb3J0KChhLCBiKSA9PiBhLmRlc2NyaXB0b3IuaW5kZXggLSBiLmRlc2NyaXB0b3IuaW5kZXgpO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKS5tYXAoaWQgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGlkKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gZW50cnkuY2FsbGJhY2tzLmdldFNjcm9sbFdoaWxlRHJhZ2dpbmcoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkcm9wcGFibGVJZDogaWQsXG4gICAgICAgICAgc2Nyb2xsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYWRkaXRpb25zOiBhZGRlZCxcbiAgICAgICAgcmVtb3ZhbHM6IE9iamVjdC5rZXlzKHJlbW92YWxzKSxcbiAgICAgICAgbW9kaWZpZWQ6IHVwZGF0ZWRcbiAgICAgIH07XG4gICAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICAgICAgZmluaXNoKCk7XG4gICAgICBjYWxsYmFja3MucHVibGlzaChyZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBhZGQgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbnRyeS5kZXNjcmlwdG9yLmlkO1xuICAgIHN0YWdpbmcuYWRkaXRpb25zW2lkXSA9IGVudHJ5O1xuICAgIHN0YWdpbmcubW9kaWZpZWRbZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZF0gPSB0cnVlO1xuICAgIGlmIChzdGFnaW5nLnJlbW92YWxzW2lkXSkge1xuICAgICAgZGVsZXRlIHN0YWdpbmcucmVtb3ZhbHNbaWRdO1xuICAgIH1cbiAgICBjb2xsZWN0KCk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZW50cnkuZGVzY3JpcHRvcjtcbiAgICBzdGFnaW5nLnJlbW92YWxzW2Rlc2NyaXB0b3IuaWRdID0gdHJ1ZTtcbiAgICBzdGFnaW5nLm1vZGlmaWVkW2Rlc2NyaXB0b3IuZHJvcHBhYmxlSWRdID0gdHJ1ZTtcbiAgICBpZiAoc3RhZ2luZy5hZGRpdGlvbnNbZGVzY3JpcHRvci5pZF0pIHtcbiAgICAgIGRlbGV0ZSBzdGFnaW5nLmFkZGl0aW9uc1tkZXNjcmlwdG9yLmlkXTtcbiAgICB9XG4gICAgY29sbGVjdCgpO1xuICB9O1xuICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgIGlmICghZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICBmcmFtZUlkID0gbnVsbDtcbiAgICBzdGFnaW5nID0gY2xlYW4kMSgpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICByZW1vdmUsXG4gICAgc3RvcFxuICB9O1xufVxuXG52YXIgZ2V0TWF4U2Nyb2xsID0gKHtcbiAgc2Nyb2xsSGVpZ2h0LFxuICBzY3JvbGxXaWR0aCxcbiAgaGVpZ2h0LFxuICB3aWR0aFxufSkgPT4ge1xuICBjb25zdCBtYXhTY3JvbGwgPSBzdWJ0cmFjdCh7XG4gICAgeDogc2Nyb2xsV2lkdGgsXG4gICAgeTogc2Nyb2xsSGVpZ2h0XG4gIH0sIHtcbiAgICB4OiB3aWR0aCxcbiAgICB5OiBoZWlnaHRcbiAgfSk7XG4gIGNvbnN0IGFkanVzdGVkTWF4U2Nyb2xsID0ge1xuICAgIHg6IE1hdGgubWF4KDAsIG1heFNjcm9sbC54KSxcbiAgICB5OiBNYXRoLm1heCgwLCBtYXhTY3JvbGwueSlcbiAgfTtcbiAgcmV0dXJuIGFkanVzdGVkTWF4U2Nyb2xsO1xufTtcblxudmFyIGdldERvY3VtZW50RWxlbWVudCA9ICgpID0+IHtcbiAgY29uc3QgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhZG9jID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRvYztcbn07XG5cbnZhciBnZXRNYXhXaW5kb3dTY3JvbGwgPSAoKSA9PiB7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgIHNjcm9sbEhlaWdodDogZG9jLnNjcm9sbEhlaWdodCxcbiAgICBzY3JvbGxXaWR0aDogZG9jLnNjcm9sbFdpZHRoLFxuICAgIHdpZHRoOiBkb2MuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBkb2MuY2xpZW50SGVpZ2h0XG4gIH0pO1xuICByZXR1cm4gbWF4U2Nyb2xsO1xufTtcblxudmFyIGdldFZpZXdwb3J0ID0gKCkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoKTtcbiAgY29uc3QgbWF4U2Nyb2xsID0gZ2V0TWF4V2luZG93U2Nyb2xsKCk7XG4gIGNvbnN0IHRvcCA9IHNjcm9sbC55O1xuICBjb25zdCBsZWZ0ID0gc2Nyb2xsLng7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50RWxlbWVudCgpO1xuICBjb25zdCB3aWR0aCA9IGRvYy5jbGllbnRXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZG9jLmNsaWVudEhlaWdodDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gIGNvbnN0IGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgY29uc3QgZnJhbWUgPSBnZXRSZWN0KHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b21cbiAgfSk7XG4gIGNvbnN0IHZpZXdwb3J0ID0ge1xuICAgIGZyYW1lLFxuICAgIHNjcm9sbDoge1xuICAgICAgaW5pdGlhbDogc2Nyb2xsLFxuICAgICAgY3VycmVudDogc2Nyb2xsLFxuICAgICAgbWF4OiBtYXhTY3JvbGwsXG4gICAgICBkaWZmOiB7XG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgICAgIGRpc3BsYWNlbWVudDogb3JpZ2luXG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gdmlld3BvcnQ7XG59O1xuXG52YXIgZ2V0SW5pdGlhbFB1Ymxpc2ggPSAoe1xuICBjcml0aWNhbCxcbiAgc2Nyb2xsT3B0aW9ucyxcbiAgcmVnaXN0cnlcbn0pID0+IHtcbiAgc3RhcnQoKTtcbiAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGwgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgY29uc3QgaG9tZSA9IGNyaXRpY2FsLmRyb3BwYWJsZTtcbiAgY29uc3QgZHJvcHBhYmxlcyA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRBbGxCeVR5cGUoaG9tZS50eXBlKS5tYXAoZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsKHdpbmRvd1Njcm9sbCwgc2Nyb2xsT3B0aW9ucykpO1xuICBjb25zdCBkcmFnZ2FibGVzID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEFsbEJ5VHlwZShjcml0aWNhbC5kcmFnZ2FibGUudHlwZSkubWFwKGVudHJ5ID0+IGVudHJ5LmdldERpbWVuc2lvbih3aW5kb3dTY3JvbGwpKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHtcbiAgICBkcmFnZ2FibGVzOiB0b0RyYWdnYWJsZU1hcChkcmFnZ2FibGVzKSxcbiAgICBkcm9wcGFibGVzOiB0b0Ryb3BwYWJsZU1hcChkcm9wcGFibGVzKVxuICB9O1xuICBmaW5pc2goKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGRpbWVuc2lvbnMsXG4gICAgY3JpdGljYWwsXG4gICAgdmlld3BvcnRcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBlbnRyeSkge1xuICBpZiAoZW50cnkuZGVzY3JpcHRvci5pZCA9PT0gZHJhZ2dpbmcuaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVudHJ5LmRlc2NyaXB0b3IudHlwZSAhPT0gZHJhZ2dpbmcudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBob21lID0gcmVnaXN0cnkuZHJvcHBhYmxlLmdldEJ5SWQoZW50cnkuZGVzY3JpcHRvci5kcm9wcGFibGVJZCk7XG4gIGlmIChob21lLmRlc2NyaXB0b3IubW9kZSAhPT0gJ3ZpcnR1YWwnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gYWRkIG9yIHJlbW92ZSBhIERyYWdnYWJsZSBbaWQ6ICR7ZW50cnkuZGVzY3JpcHRvci5pZH1dXG4gICAgICB3aGlsZSBhIGRyYWcgaXMgb2NjdXJyaW5nLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciB2aXJ0dWFsIGxpc3RzLlxuXG4gICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvcGF0dGVybnMvdmlydHVhbC1saXN0cy5tZFxuICAgIGApIDogdm9pZCAwO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBjcmVhdGVEaW1lbnNpb25NYXJzaGFsID0gKHJlZ2lzdHJ5LCBjYWxsYmFja3MpID0+IHtcbiAgbGV0IGNvbGxlY3Rpb24gPSBudWxsO1xuICBjb25zdCBwdWJsaXNoZXIgPSBjcmVhdGVQdWJsaXNoZXIoe1xuICAgIGNhbGxiYWNrczoge1xuICAgICAgcHVibGlzaDogY2FsbGJhY2tzLnB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgICAgY29sbGVjdGlvblN0YXJ0aW5nOiBjYWxsYmFja3MuY29sbGVjdGlvblN0YXJ0aW5nXG4gICAgfSxcbiAgICByZWdpc3RyeVxuICB9KTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkID0gKGlkLCBpc0VuYWJsZWQpID0+IHtcbiAgICAhcmVnaXN0cnkuZHJvcHBhYmxlLmV4aXN0cyhpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgdXBkYXRlIGlzIGVuYWJsZWQgZmxhZyBvZiBEcm9wcGFibGUgJHtpZH0gYXMgaXQgaXMgbm90IHJlZ2lzdGVyZWRgKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNFbmFibGVkKHtcbiAgICAgIGlkLFxuICAgICAgaXNFbmFibGVkXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQgPSAoaWQsIGlzQ29tYmluZUVuYWJsZWQpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSBpc0NvbWJpbmVFbmFibGVkIGZsYWcgb2YgRHJvcHBhYmxlICR7aWR9IGFzIGl0IGlzIG5vdCByZWdpc3RlcmVkYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjYWxsYmFja3MudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCh7XG4gICAgICBpZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWRcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlRHJvcHBhYmxlU2Nyb2xsID0gKGlkLCBuZXdTY3JvbGwpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIXJlZ2lzdHJ5LmRyb3BwYWJsZS5leGlzdHMoaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IHVwZGF0ZSB0aGUgc2Nyb2xsIG9uIERyb3BwYWJsZSAke2lkfSBhcyBpdCBpcyBub3QgcmVnaXN0ZXJlZGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2FsbGJhY2tzLnVwZGF0ZURyb3BwYWJsZVNjcm9sbCh7XG4gICAgICBpZCxcbiAgICAgIG5ld1Njcm9sbFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzY3JvbGxEcm9wcGFibGUgPSAoaWQsIGNoYW5nZSkgPT4ge1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RyeS5kcm9wcGFibGUuZ2V0QnlJZChpZCkuY2FsbGJhY2tzLnNjcm9sbChjaGFuZ2UpO1xuICB9O1xuICBjb25zdCBzdG9wUHVibGlzaGluZyA9ICgpID0+IHtcbiAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHVibGlzaGVyLnN0b3AoKTtcbiAgICBjb25zdCBob21lID0gY29sbGVjdGlvbi5jcml0aWNhbC5kcm9wcGFibGU7XG4gICAgcmVnaXN0cnkuZHJvcHBhYmxlLmdldEFsbEJ5VHlwZShob21lLnR5cGUpLmZvckVhY2goZW50cnkgPT4gZW50cnkuY2FsbGJhY2tzLmRyYWdTdG9wcGVkKCkpO1xuICAgIGNvbGxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICBjb2xsZWN0aW9uID0gbnVsbDtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlciA9IGV2ZW50ID0+IHtcbiAgICAhY29sbGVjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBvbmx5IGJlIHN1YnNjcmliZWQgd2hlbiBhIGNvbGxlY3Rpb24gaXMgb2NjdXJyaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcmFnZ2luZyA9IGNvbGxlY3Rpb24uY3JpdGljYWwuZHJhZ2dhYmxlO1xuICAgIGlmIChldmVudC50eXBlID09PSAnQURESVRJT04nKSB7XG4gICAgICBpZiAoc2hvdWxkUHVibGlzaFVwZGF0ZShyZWdpc3RyeSwgZHJhZ2dpbmcsIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICBwdWJsaXNoZXIuYWRkKGV2ZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdSRU1PVkFMJykge1xuICAgICAgaWYgKHNob3VsZFB1Ymxpc2hVcGRhdGUocmVnaXN0cnksIGRyYWdnaW5nLCBldmVudC52YWx1ZSkpIHtcbiAgICAgICAgcHVibGlzaGVyLnJlbW92ZShldmVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGFydFB1Ymxpc2hpbmcgPSByZXF1ZXN0ID0+IHtcbiAgICAhIWNvbGxlY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RhcnQgY2FwdHVyaW5nIGNyaXRpY2FsIGRpbWVuc2lvbnMgYXMgdGhlcmUgaXMgYWxyZWFkeSBhIGNvbGxlY3Rpb24nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGVudHJ5ID0gcmVnaXN0cnkuZHJhZ2dhYmxlLmdldEJ5SWQocmVxdWVzdC5kcmFnZ2FibGVJZCk7XG4gICAgY29uc3QgaG9tZSA9IHJlZ2lzdHJ5LmRyb3BwYWJsZS5nZXRCeUlkKGVudHJ5LmRlc2NyaXB0b3IuZHJvcHBhYmxlSWQpO1xuICAgIGNvbnN0IGNyaXRpY2FsID0ge1xuICAgICAgZHJhZ2dhYmxlOiBlbnRyeS5kZXNjcmlwdG9yLFxuICAgICAgZHJvcHBhYmxlOiBob21lLmRlc2NyaXB0b3JcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0cnkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIGNvbGxlY3Rpb24gPSB7XG4gICAgICBjcml0aWNhbCxcbiAgICAgIHVuc3Vic2NyaWJlXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0SW5pdGlhbFB1Ymxpc2goe1xuICAgICAgY3JpdGljYWwsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHNjcm9sbE9wdGlvbnM6IHJlcXVlc3Quc2Nyb2xsT3B0aW9uc1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBtYXJzaGFsID0ge1xuICAgIHVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0NvbWJpbmVFbmFibGVkLFxuICAgIHNjcm9sbERyb3BwYWJsZSxcbiAgICB1cGRhdGVEcm9wcGFibGVTY3JvbGwsXG4gICAgc3RhcnRQdWJsaXNoaW5nLFxuICAgIHN0b3BQdWJsaXNoaW5nXG4gIH07XG4gIHJldHVybiBtYXJzaGFsO1xufTtcblxudmFyIGNhblN0YXJ0RHJhZyA9IChzdGF0ZSwgaWQpID0+IHtcbiAgaWYgKHN0YXRlLnBoYXNlID09PSAnSURMRScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc3RhdGUucGhhc2UgIT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0YXRlLmNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQgPT09IGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdGF0ZS5jb21wbGV0ZWQucmVzdWx0LnJlYXNvbiA9PT0gJ0RST1AnO1xufTtcblxudmFyIHNjcm9sbFdpbmRvdyA9IGNoYW5nZSA9PiB7XG4gIHdpbmRvdy5zY3JvbGxCeShjaGFuZ2UueCwgY2hhbmdlLnkpO1xufTtcblxuY29uc3QgZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZXMgPSBtZW1vaXplT25lKGRyb3BwYWJsZXMgPT4gdG9Ecm9wcGFibGVMaXN0KGRyb3BwYWJsZXMpLmZpbHRlcihkcm9wcGFibGUgPT4ge1xuICBpZiAoIWRyb3BwYWJsZS5pc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFkcm9wcGFibGUuZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KSk7XG5jb25zdCBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlciA9ICh0YXJnZXQsIGRyb3BwYWJsZXMpID0+IHtcbiAgY29uc3QgbWF5YmUgPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlcyhkcm9wcGFibGVzKS5maW5kKGRyb3BwYWJsZSA9PiB7XG4gICAgIWRyb3BwYWJsZS5mcmFtZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgcmVzdWx0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gaXNQb3NpdGlvbkluRnJhbWUoZHJvcHBhYmxlLmZyYW1lLnBhZ2VNYXJnaW5Cb3gpKHRhcmdldCk7XG4gIH0pIHx8IG51bGw7XG4gIHJldHVybiBtYXliZTtcbn07XG52YXIgZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUgPSAoe1xuICBjZW50ZXIsXG4gIGRlc3RpbmF0aW9uLFxuICBkcm9wcGFibGVzXG59KSA9PiB7XG4gIGlmIChkZXN0aW5hdGlvbikge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGRyb3BwYWJsZXNbZGVzdGluYXRpb25dO1xuICAgIGlmICghZGltZW5zaW9uLmZyYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgfVxuICBjb25zdCBkaW1lbnNpb24gPSBnZXRTY3JvbGxhYmxlRHJvcHBhYmxlT3ZlcihjZW50ZXIsIGRyb3BwYWJsZXMpO1xuICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuY29uc3QgZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMgPSB7XG4gIHN0YXJ0RnJvbVBlcmNlbnRhZ2U6IDAuMjUsXG4gIG1heFNjcm9sbEF0UGVyY2VudGFnZTogMC4wNSxcbiAgbWF4UGl4ZWxTY3JvbGw6IDI4LFxuICBlYXNlOiBwZXJjZW50YWdlID0+IHBlcmNlbnRhZ2UgKiogMixcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICBzdG9wRGFtcGVuaW5nQXQ6IDEyMDAsXG4gICAgYWNjZWxlcmF0ZUF0OiAzNjBcbiAgfSxcbiAgZGlzYWJsZWQ6IGZhbHNlXG59O1xuXG52YXIgZ2V0RGlzdGFuY2VUaHJlc2hvbGRzID0gKGNvbnRhaW5lciwgYXhpcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9ICgpID0+IGRlZmF1bHRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IHN0YXJ0U2Nyb2xsaW5nRnJvbSA9IGNvbnRhaW5lcltheGlzLnNpemVdICogYXV0b1Njcm9sbGVyT3B0aW9ucy5zdGFydEZyb21QZXJjZW50YWdlO1xuICBjb25zdCBtYXhTY3JvbGxWYWx1ZUF0ID0gY29udGFpbmVyW2F4aXMuc2l6ZV0gKiBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFNjcm9sbEF0UGVyY2VudGFnZTtcbiAgY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBzdGFydFNjcm9sbGluZ0Zyb20sXG4gICAgbWF4U2Nyb2xsVmFsdWVBdFxuICB9O1xuICByZXR1cm4gdGhyZXNob2xkcztcbn07XG5cbnZhciBnZXRQZXJjZW50YWdlID0gKHtcbiAgc3RhcnRPZlJhbmdlLFxuICBlbmRPZlJhbmdlLFxuICBjdXJyZW50XG59KSA9PiB7XG4gIGNvbnN0IHJhbmdlID0gZW5kT2ZSYW5nZSAtIHN0YXJ0T2ZSYW5nZTtcbiAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBEZXRlY3RlZCBkaXN0YW5jZSByYW5nZSBvZiAwIGluIHRoZSBmbHVpZCBhdXRvIHNjcm9sbGVyXG4gICAgICBUaGlzIGlzIHVuZXhwZWN0ZWQgYW5kIHdvdWxkIGNhdXNlIGEgZGl2aWRlIGJ5IDAgaXNzdWUuXG4gICAgICBOb3QgYWxsb3dpbmcgYW4gYXV0byBzY3JvbGxcbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBjdXJyZW50SW5SYW5nZSA9IGN1cnJlbnQgLSBzdGFydE9mUmFuZ2U7XG4gIGNvbnN0IHBlcmNlbnRhZ2UgPSBjdXJyZW50SW5SYW5nZSAvIHJhbmdlO1xuICByZXR1cm4gcGVyY2VudGFnZTtcbn07XG5cbnZhciBtaW5TY3JvbGwgPSAxO1xuXG52YXIgZ2V0VmFsdWVGcm9tRGlzdGFuY2UgPSAoZGlzdGFuY2VUb0VkZ2UsIHRocmVzaG9sZHMsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMgPSAoKSA9PiBkZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucykgPT4ge1xuICBjb25zdCBhdXRvU2Nyb2xsZXJPcHRpb25zID0gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpO1xuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChkaXN0YW5jZVRvRWRnZSA8PSB0aHJlc2hvbGRzLm1heFNjcm9sbFZhbHVlQXQpIHtcbiAgICByZXR1cm4gYXV0b1Njcm9sbGVyT3B0aW9ucy5tYXhQaXhlbFNjcm9sbDtcbiAgfVxuICBpZiAoZGlzdGFuY2VUb0VkZ2UgPT09IHRocmVzaG9sZHMuc3RhcnRTY3JvbGxpbmdGcm9tKSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBwZXJjZW50YWdlRnJvbU1heFNjcm9sbFZhbHVlQXQgPSBnZXRQZXJjZW50YWdlKHtcbiAgICBzdGFydE9mUmFuZ2U6IHRocmVzaG9sZHMubWF4U2Nyb2xsVmFsdWVBdCxcbiAgICBlbmRPZlJhbmdlOiB0aHJlc2hvbGRzLnN0YXJ0U2Nyb2xsaW5nRnJvbSxcbiAgICBjdXJyZW50OiBkaXN0YW5jZVRvRWRnZVxuICB9KTtcbiAgY29uc3QgcGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20gPSAxIC0gcGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0O1xuICBjb25zdCBzY3JvbGwgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLm1heFBpeGVsU2Nyb2xsICogYXV0b1Njcm9sbGVyT3B0aW9ucy5lYXNlKHBlcmNlbnRhZ2VGcm9tU3RhcnRTY3JvbGxpbmdGcm9tKTtcbiAgcmV0dXJuIE1hdGguY2VpbChzY3JvbGwpO1xufTtcblxudmFyIGRhbXBlblZhbHVlQnlUaW1lID0gKHByb3Bvc2VkU2Nyb2xsLCBkcmFnU3RhcnRUaW1lLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKSA9PiB7XG4gIGNvbnN0IGF1dG9TY3JvbGxlck9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IGFjY2VsZXJhdGVBdCA9IGF1dG9TY3JvbGxlck9wdGlvbnMuZHVyYXRpb25EYW1wZW5pbmcuYWNjZWxlcmF0ZUF0O1xuICBjb25zdCBzdG9wQXQgPSBhdXRvU2Nyb2xsZXJPcHRpb25zLmR1cmF0aW9uRGFtcGVuaW5nLnN0b3BEYW1wZW5pbmdBdDtcbiAgY29uc3Qgc3RhcnRPZlJhbmdlID0gZHJhZ1N0YXJ0VGltZTtcbiAgY29uc3QgZW5kT2ZSYW5nZSA9IHN0b3BBdDtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcnVuVGltZSA9IG5vdyAtIHN0YXJ0T2ZSYW5nZTtcbiAgaWYgKHJ1blRpbWUgPj0gc3RvcEF0KSB7XG4gICAgcmV0dXJuIHByb3Bvc2VkU2Nyb2xsO1xuICB9XG4gIGlmIChydW5UaW1lIDwgYWNjZWxlcmF0ZUF0KSB7XG4gICAgcmV0dXJuIG1pblNjcm9sbDtcbiAgfVxuICBjb25zdCBiZXR3ZWVuQWNjZWxlcmF0ZUF0QW5kU3RvcEF0UGVyY2VudGFnZSA9IGdldFBlcmNlbnRhZ2Uoe1xuICAgIHN0YXJ0T2ZSYW5nZTogYWNjZWxlcmF0ZUF0LFxuICAgIGVuZE9mUmFuZ2UsXG4gICAgY3VycmVudDogcnVuVGltZVxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsID0gcHJvcG9zZWRTY3JvbGwgKiBhdXRvU2Nyb2xsZXJPcHRpb25zLmVhc2UoYmV0d2VlbkFjY2VsZXJhdGVBdEFuZFN0b3BBdFBlcmNlbnRhZ2UpO1xuICByZXR1cm4gTWF0aC5jZWlsKHNjcm9sbCk7XG59O1xuXG52YXIgZ2V0VmFsdWUgPSAoe1xuICBkaXN0YW5jZVRvRWRnZSxcbiAgdGhyZXNob2xkcyxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRWYWx1ZUZyb21EaXN0YW5jZShkaXN0YW5jZVRvRWRnZSwgdGhyZXNob2xkcywgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyk7XG4gIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIXNob3VsZFVzZVRpbWVEYW1wZW5pbmcpIHtcbiAgICByZXR1cm4gc2Nyb2xsO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChkYW1wZW5WYWx1ZUJ5VGltZShzY3JvbGwsIGRyYWdTdGFydFRpbWUsIGdldEF1dG9TY3JvbGxlck9wdGlvbnMpLCBtaW5TY3JvbGwpO1xufTtcblxudmFyIGdldFNjcm9sbE9uQXhpcyA9ICh7XG4gIGNvbnRhaW5lcixcbiAgZGlzdGFuY2VUb0VkZ2VzLFxuICBkcmFnU3RhcnRUaW1lLFxuICBheGlzLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IHRocmVzaG9sZHMgPSBnZXREaXN0YW5jZVRocmVzaG9sZHMoY29udGFpbmVyLCBheGlzLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKTtcbiAgY29uc3QgaXNDbG9zZXJUb0VuZCA9IGRpc3RhbmNlVG9FZGdlc1theGlzLmVuZF0gPCBkaXN0YW5jZVRvRWRnZXNbYXhpcy5zdGFydF07XG4gIGlmIChpc0Nsb3NlclRvRW5kKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKHtcbiAgICAgIGRpc3RhbmNlVG9FZGdlOiBkaXN0YW5jZVRvRWRnZXNbYXhpcy5lbmRdLFxuICAgICAgdGhyZXNob2xkcyxcbiAgICAgIGRyYWdTdGFydFRpbWUsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiAtMSAqIGdldFZhbHVlKHtcbiAgICBkaXN0YW5jZVRvRWRnZTogZGlzdGFuY2VUb0VkZ2VzW2F4aXMuc3RhcnRdLFxuICAgIHRocmVzaG9sZHMsXG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG59O1xuXG52YXIgYWRqdXN0Rm9yU2l6ZUxpbWl0cyA9ICh7XG4gIGNvbnRhaW5lcixcbiAgc3ViamVjdCxcbiAgcHJvcG9zZWRTY3JvbGxcbn0pID0+IHtcbiAgY29uc3QgaXNUb29CaWdWZXJ0aWNhbGx5ID0gc3ViamVjdC5oZWlnaHQgPiBjb250YWluZXIuaGVpZ2h0O1xuICBjb25zdCBpc1Rvb0JpZ0hvcml6b250YWxseSA9IHN1YmplY3Qud2lkdGggPiBjb250YWluZXIud2lkdGg7XG4gIGlmICghaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgIWlzVG9vQmlnVmVydGljYWxseSkge1xuICAgIHJldHVybiBwcm9wb3NlZFNjcm9sbDtcbiAgfVxuICBpZiAoaXNUb29CaWdIb3Jpem9udGFsbHkgJiYgaXNUb29CaWdWZXJ0aWNhbGx5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBpc1Rvb0JpZ0hvcml6b250YWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC54LFxuICAgIHk6IGlzVG9vQmlnVmVydGljYWxseSA/IDAgOiBwcm9wb3NlZFNjcm9sbC55XG4gIH07XG59O1xuXG5jb25zdCBjbGVhbiA9IGFwcGx5KHZhbHVlID0+IHZhbHVlID09PSAwID8gMCA6IHZhbHVlKTtcbnZhciBnZXRTY3JvbGwkMSA9ICh7XG4gIGRyYWdTdGFydFRpbWUsXG4gIGNvbnRhaW5lcixcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGRpc3RhbmNlVG9FZGdlcyA9IHtcbiAgICB0b3A6IGNlbnRlci55IC0gY29udGFpbmVyLnRvcCxcbiAgICByaWdodDogY29udGFpbmVyLnJpZ2h0IC0gY2VudGVyLngsXG4gICAgYm90dG9tOiBjb250YWluZXIuYm90dG9tIC0gY2VudGVyLnksXG4gICAgbGVmdDogY2VudGVyLnggLSBjb250YWluZXIubGVmdFxuICB9O1xuICBjb25zdCB5ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogdmVydGljYWwsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBjb25zdCB4ID0gZ2V0U2Nyb2xsT25BeGlzKHtcbiAgICBjb250YWluZXIsXG4gICAgZGlzdGFuY2VUb0VkZ2VzLFxuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgYXhpczogaG9yaXpvbnRhbCxcbiAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IHJlcXVpcmVkID0gY2xlYW4oe1xuICAgIHgsXG4gICAgeVxuICB9KTtcbiAgaWYgKGlzRXF1YWwkMShyZXF1aXJlZCwgb3JpZ2luKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxpbWl0ZWQgPSBhZGp1c3RGb3JTaXplTGltaXRzKHtcbiAgICBjb250YWluZXIsXG4gICAgc3ViamVjdCxcbiAgICBwcm9wb3NlZFNjcm9sbDogcmVxdWlyZWRcbiAgfSk7XG4gIGlmICghbGltaXRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpc0VxdWFsJDEobGltaXRlZCwgb3JpZ2luKSA/IG51bGwgOiBsaW1pdGVkO1xufTtcblxuY29uc3Qgc21hbGxlc3RTaWduZWQgPSBhcHBseSh2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59KTtcbmNvbnN0IGdldE92ZXJsYXAgPSAoKCkgPT4ge1xuICBjb25zdCBnZXRSZW1haW5kZXIgPSAodGFyZ2V0LCBtYXgpID0+IHtcbiAgICBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCA+IG1heCkge1xuICAgICAgcmV0dXJuIHRhcmdldCAtIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIHJldHVybiAoe1xuICAgIGN1cnJlbnQsXG4gICAgbWF4LFxuICAgIGNoYW5nZVxuICB9KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0U2Nyb2xsID0gYWRkKGN1cnJlbnQsIGNoYW5nZSk7XG4gICAgY29uc3Qgb3ZlcmxhcCA9IHtcbiAgICAgIHg6IGdldFJlbWFpbmRlcih0YXJnZXRTY3JvbGwueCwgbWF4LngpLFxuICAgICAgeTogZ2V0UmVtYWluZGVyKHRhcmdldFNjcm9sbC55LCBtYXgueSlcbiAgICB9O1xuICAgIGlmIChpc0VxdWFsJDEob3ZlcmxhcCwgb3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvdmVybGFwO1xuICB9O1xufSkoKTtcbmNvbnN0IGNhblBhcnRpYWxseVNjcm9sbCA9ICh7XG4gIG1heDogcmF3TWF4LFxuICBjdXJyZW50LFxuICBjaGFuZ2Vcbn0pID0+IHtcbiAgY29uc3QgbWF4ID0ge1xuICAgIHg6IE1hdGgubWF4KGN1cnJlbnQueCwgcmF3TWF4LngpLFxuICAgIHk6IE1hdGgubWF4KGN1cnJlbnQueSwgcmF3TWF4LnkpXG4gIH07XG4gIGNvbnN0IHNtYWxsZXN0Q2hhbmdlID0gc21hbGxlc3RTaWduZWQoY2hhbmdlKTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGdldE92ZXJsYXAoe1xuICAgIG1heCxcbiAgICBjdXJyZW50LFxuICAgIGNoYW5nZTogc21hbGxlc3RDaGFuZ2VcbiAgfSk7XG4gIGlmICghb3ZlcmxhcCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzbWFsbGVzdENoYW5nZS54ICE9PSAwICYmIG92ZXJsYXAueCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzbWFsbGVzdENoYW5nZS55ICE9PSAwICYmIG92ZXJsYXAueSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBjYW5TY3JvbGxXaW5kb3cgPSAodmlld3BvcnQsIGNoYW5nZSkgPT4gY2FuUGFydGlhbGx5U2Nyb2xsKHtcbiAgY3VycmVudDogdmlld3BvcnQuc2Nyb2xsLmN1cnJlbnQsXG4gIG1heDogdmlld3BvcnQuc2Nyb2xsLm1heCxcbiAgY2hhbmdlXG59KTtcbmNvbnN0IGdldFdpbmRvd092ZXJsYXAgPSAodmlld3BvcnQsIGNoYW5nZSkgPT4ge1xuICBpZiAoIWNhblNjcm9sbFdpbmRvdyh2aWV3cG9ydCwgY2hhbmdlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1heCA9IHZpZXdwb3J0LnNjcm9sbC5tYXg7XG4gIGNvbnN0IGN1cnJlbnQgPSB2aWV3cG9ydC5zY3JvbGwuY3VycmVudDtcbiAgcmV0dXJuIGdldE92ZXJsYXAoe1xuICAgIGN1cnJlbnQsXG4gICAgbWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5jb25zdCBjYW5TY3JvbGxEcm9wcGFibGUgPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgY29uc3QgZnJhbWUgPSBkcm9wcGFibGUuZnJhbWU7XG4gIGlmICghZnJhbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNhblBhcnRpYWxseVNjcm9sbCh7XG4gICAgY3VycmVudDogZnJhbWUuc2Nyb2xsLmN1cnJlbnQsXG4gICAgbWF4OiBmcmFtZS5zY3JvbGwubWF4LFxuICAgIGNoYW5nZVxuICB9KTtcbn07XG5jb25zdCBnZXREcm9wcGFibGVPdmVybGFwID0gKGRyb3BwYWJsZSwgY2hhbmdlKSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBjaGFuZ2UpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGdldE92ZXJsYXAoe1xuICAgIGN1cnJlbnQ6IGZyYW1lLnNjcm9sbC5jdXJyZW50LFxuICAgIG1heDogZnJhbWUuc2Nyb2xsLm1heCxcbiAgICBjaGFuZ2VcbiAgfSk7XG59O1xuXG52YXIgZ2V0V2luZG93U2Nyb2xsQ2hhbmdlID0gKHtcbiAgdmlld3BvcnQsXG4gIHN1YmplY3QsXG4gIGNlbnRlcixcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBzY3JvbGwgPSBnZXRTY3JvbGwkMSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBjb250YWluZXI6IHZpZXdwb3J0LmZyYW1lLFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIHNjcm9sbCkgPyBzY3JvbGwgOiBudWxsO1xufTtcblxudmFyIGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSA9ICh7XG4gIGRyb3BwYWJsZSxcbiAgc3ViamVjdCxcbiAgY2VudGVyLFxuICBkcmFnU3RhcnRUaW1lLFxuICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gZHJvcHBhYmxlLmZyYW1lO1xuICBpZiAoIWZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsID0gZ2V0U2Nyb2xsJDEoe1xuICAgIGRyYWdTdGFydFRpbWUsXG4gICAgY29udGFpbmVyOiBmcmFtZS5wYWdlTWFyZ2luQm94LFxuICAgIHN1YmplY3QsXG4gICAgY2VudGVyLFxuICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgcmV0dXJuIHNjcm9sbCAmJiBjYW5TY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLCBzY3JvbGwpID8gc2Nyb2xsIDogbnVsbDtcbn07XG5cbnZhciBzY3JvbGwgPSAoe1xuICBzdGF0ZSxcbiAgZHJhZ1N0YXJ0VGltZSxcbiAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgc2Nyb2xsV2luZG93LFxuICBzY3JvbGxEcm9wcGFibGUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgY2VudGVyID0gc3RhdGUuY3VycmVudC5wYWdlLmJvcmRlckJveENlbnRlcjtcbiAgY29uc3QgZHJhZ2dhYmxlID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW3N0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZF07XG4gIGNvbnN0IHN1YmplY3QgPSBkcmFnZ2FibGUucGFnZS5tYXJnaW5Cb3g7XG4gIGlmIChzdGF0ZS5pc1dpbmRvd1Njcm9sbEFsbG93ZWQpIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IGNoYW5nZSA9IGdldFdpbmRvd1Njcm9sbENoYW5nZSh7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBzdWJqZWN0LFxuICAgICAgY2VudGVyLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICAgIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICBzY3JvbGxXaW5kb3coY2hhbmdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZHJvcHBhYmxlID0gZ2V0QmVzdFNjcm9sbGFibGVEcm9wcGFibGUoe1xuICAgIGNlbnRlcixcbiAgICBkZXN0aW5hdGlvbjogd2hhdElzRHJhZ2dlZE92ZXIoc3RhdGUuaW1wYWN0KSxcbiAgICBkcm9wcGFibGVzOiBzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNcbiAgfSk7XG4gIGlmICghZHJvcHBhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoYW5nZSA9IGdldERyb3BwYWJsZVNjcm9sbENoYW5nZSh7XG4gICAgZHJhZ1N0YXJ0VGltZSxcbiAgICBkcm9wcGFibGUsXG4gICAgc3ViamVjdCxcbiAgICBjZW50ZXIsXG4gICAgc2hvdWxkVXNlVGltZURhbXBlbmluZyxcbiAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH0pO1xuICBpZiAoY2hhbmdlKSB7XG4gICAgc2Nyb2xsRHJvcHBhYmxlKGRyb3BwYWJsZS5kZXNjcmlwdG9yLmlkLCBjaGFuZ2UpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlRmx1aWRTY3JvbGxlciA9ICh7XG4gIHNjcm9sbFdpbmRvdyxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zID0gKCkgPT4gZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3Qgc2NoZWR1bGVXaW5kb3dTY3JvbGwgPSByYWZTY2hkKHNjcm9sbFdpbmRvdyk7XG4gIGNvbnN0IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsID0gcmFmU2NoZChzY3JvbGxEcm9wcGFibGUpO1xuICBsZXQgZHJhZ2dpbmcgPSBudWxsO1xuICBjb25zdCB0cnlTY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZsdWlkIHNjcm9sbCBpZiBub3QgZHJhZ2dpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBkcmFnU3RhcnRUaW1lXG4gICAgfSA9IGRyYWdnaW5nO1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogc2NoZWR1bGVXaW5kb3dTY3JvbGwsXG4gICAgICBzY3JvbGxEcm9wcGFibGU6IHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLFxuICAgICAgZHJhZ1N0YXJ0VGltZSxcbiAgICAgIHNob3VsZFVzZVRpbWVEYW1wZW5pbmcsXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN0YXJ0JDEgPSBzdGF0ZSA9PiB7XG4gICAgc3RhcnQoKTtcbiAgICAhIWRyYWdnaW5nID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHN0YXJ0IGF1dG8gc2Nyb2xsaW5nIHdoZW4gYWxyZWFkeSBzdGFydGVkJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBkcmFnU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FzU2Nyb2xsTmVlZGVkID0gZmFsc2U7XG4gICAgY29uc3QgZmFrZVNjcm9sbENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgd2FzU2Nyb2xsTmVlZGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHNjcm9sbCh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGRyYWdTdGFydFRpbWU6IDAsXG4gICAgICBzaG91bGRVc2VUaW1lRGFtcGVuaW5nOiBmYWxzZSxcbiAgICAgIHNjcm9sbFdpbmRvdzogZmFrZVNjcm9sbENhbGxiYWNrLFxuICAgICAgc2Nyb2xsRHJvcHBhYmxlOiBmYWtlU2Nyb2xsQ2FsbGJhY2ssXG4gICAgICBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXG4gICAgfSk7XG4gICAgZHJhZ2dpbmcgPSB7XG4gICAgICBkcmFnU3RhcnRUaW1lLFxuICAgICAgc2hvdWxkVXNlVGltZURhbXBlbmluZzogd2FzU2Nyb2xsTmVlZGVkXG4gICAgfTtcbiAgICBmaW5pc2goKTtcbiAgICBpZiAod2FzU2Nyb2xsTmVlZGVkKSB7XG4gICAgICB0cnlTY3JvbGwoc3RhdGUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RvcCA9ICgpID0+IHtcbiAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlV2luZG93U2Nyb2xsLmNhbmNlbCgpO1xuICAgIHNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsLmNhbmNlbCgpO1xuICAgIGRyYWdnaW5nID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQkMSxcbiAgICBzdG9wLFxuICAgIHNjcm9sbDogdHJ5U2Nyb2xsXG4gIH07XG59O1xuXG52YXIgY3JlYXRlSnVtcFNjcm9sbGVyID0gKHtcbiAgbW92ZSxcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3dcbn0pID0+IHtcbiAgY29uc3QgbW92ZUJ5T2Zmc2V0ID0gKHN0YXRlLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSBhZGQoc3RhdGUuY3VycmVudC5jbGllbnQuc2VsZWN0aW9uLCBvZmZzZXQpO1xuICAgIG1vdmUoe1xuICAgICAgY2xpZW50XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4gPSAoZHJvcHBhYmxlLCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWNhblNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXREcm9wcGFibGVPdmVybGFwKGRyb3BwYWJsZSwgY2hhbmdlKTtcbiAgICBpZiAoIW92ZXJsYXApIHtcbiAgICAgIHNjcm9sbERyb3BwYWJsZShkcm9wcGFibGUuZGVzY3JpcHRvci5pZCwgY2hhbmdlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsID0gc3VidHJhY3QoY2hhbmdlLCBvdmVybGFwKTtcbiAgICBzY3JvbGxEcm9wcGFibGUoZHJvcHBhYmxlLmRlc2NyaXB0b3IuaWQsIHdoYXRUaGVEcm9wcGFibGVDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZURyb3BwYWJsZUNhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3Qgc2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiA9IChpc1dpbmRvd1Njcm9sbEFsbG93ZWQsIHZpZXdwb3J0LCBjaGFuZ2UpID0+IHtcbiAgICBpZiAoIWlzV2luZG93U2Nyb2xsQWxsb3dlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgaWYgKCFjYW5TY3JvbGxXaW5kb3codmlld3BvcnQsIGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXRXaW5kb3dPdmVybGFwKHZpZXdwb3J0LCBjaGFuZ2UpO1xuICAgIGlmICghb3ZlcmxhcCkge1xuICAgICAgc2Nyb2xsV2luZG93KGNoYW5nZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCA9IHN1YnRyYWN0KGNoYW5nZSwgb3ZlcmxhcCk7XG4gICAgc2Nyb2xsV2luZG93KHdoYXRUaGVXaW5kb3dDYW5TY3JvbGwpO1xuICAgIGNvbnN0IHJlbWFpbmRlciA9IHN1YnRyYWN0KGNoYW5nZSwgd2hhdFRoZVdpbmRvd0NhblNjcm9sbCk7XG4gICAgcmV0dXJuIHJlbWFpbmRlcjtcbiAgfTtcbiAgY29uc3QganVtcFNjcm9sbGVyID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzdGF0ZS5zY3JvbGxKdW1wUmVxdWVzdDtcbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICFkZXN0aW5hdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwZXJmb3JtIGEganVtcCBzY3JvbGwgd2hlbiB0aGVyZSBpcyBubyBkZXN0aW5hdGlvbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZHJvcHBhYmxlUmVtYWluZGVyID0gc2Nyb2xsRHJvcHBhYmxlQXNNdWNoQXNJdENhbihzdGF0ZS5kaW1lbnNpb25zLmRyb3BwYWJsZXNbZGVzdGluYXRpb25dLCByZXF1ZXN0KTtcbiAgICBpZiAoIWRyb3BwYWJsZVJlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3cG9ydCA9IHN0YXRlLnZpZXdwb3J0O1xuICAgIGNvbnN0IHdpbmRvd1JlbWFpbmRlciA9IHNjcm9sbFdpbmRvd0FzTXVjaEFzSXRDYW4oc3RhdGUuaXNXaW5kb3dTY3JvbGxBbGxvd2VkLCB2aWV3cG9ydCwgZHJvcHBhYmxlUmVtYWluZGVyKTtcbiAgICBpZiAoIXdpbmRvd1JlbWFpbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb3ZlQnlPZmZzZXQoc3RhdGUsIHdpbmRvd1JlbWFpbmRlcik7XG4gIH07XG4gIHJldHVybiBqdW1wU2Nyb2xsZXI7XG59O1xuXG52YXIgY3JlYXRlQXV0b1Njcm9sbGVyID0gKHtcbiAgc2Nyb2xsRHJvcHBhYmxlLFxuICBzY3JvbGxXaW5kb3csXG4gIG1vdmUsXG4gIGdldEF1dG9TY3JvbGxlck9wdGlvbnNcbn0pID0+IHtcbiAgY29uc3QgZmx1aWRTY3JvbGxlciA9IGNyZWF0ZUZsdWlkU2Nyb2xsZXIoe1xuICAgIHNjcm9sbFdpbmRvdyxcbiAgICBzY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9uc1xuICB9KTtcbiAgY29uc3QganVtcFNjcm9sbCA9IGNyZWF0ZUp1bXBTY3JvbGxlcih7XG4gICAgbW92ZSxcbiAgICBzY3JvbGxXaW5kb3csXG4gICAgc2Nyb2xsRHJvcHBhYmxlXG4gIH0pO1xuICBjb25zdCBzY3JvbGwgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYXV0b1Njcm9sbGVyT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgICBpZiAoYXV0b1Njcm9sbGVyT3B0aW9ucy5kaXNhYmxlZCB8fCBzdGF0ZS5waGFzZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubW92ZW1lbnRNb2RlID09PSAnRkxVSUQnKSB7XG4gICAgICBmbHVpZFNjcm9sbGVyLnNjcm9sbChzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3RhdGUuc2Nyb2xsSnVtcFJlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAganVtcFNjcm9sbChzdGF0ZSk7XG4gIH07XG4gIGNvbnN0IHNjcm9sbGVyID0ge1xuICAgIHNjcm9sbCxcbiAgICBzdGFydDogZmx1aWRTY3JvbGxlci5zdGFydCxcbiAgICBzdG9wOiBmbHVpZFNjcm9sbGVyLnN0b3BcbiAgfTtcbiAgcmV0dXJuIHNjcm9sbGVyO1xufTtcblxuY29uc3QgcHJlZml4ID0gJ2RhdGEtcmZkJztcbmNvbnN0IGRyYWdIYW5kbGUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gYCR7cHJlZml4fS1kcmFnLWhhbmRsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBkcmFnZ2FibGVJZDogYCR7YmFzZX0tZHJhZ2dhYmxlLWlkYCxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgXG4gIH07XG59KSgpO1xuY29uc3QgZHJhZ2dhYmxlID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9IGAke3ByZWZpeH0tZHJhZ2dhYmxlYDtcbiAgcmV0dXJuIHtcbiAgICBiYXNlLFxuICAgIGNvbnRleHRJZDogYCR7YmFzZX0tY29udGV4dC1pZGAsXG4gICAgaWQ6IGAke2Jhc2V9LWlkYFxuICB9O1xufSkoKTtcbmNvbnN0IGRyb3BwYWJsZSA9ICgoKSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBgJHtwcmVmaXh9LWRyb3BwYWJsZWA7XG4gIHJldHVybiB7XG4gICAgYmFzZSxcbiAgICBjb250ZXh0SWQ6IGAke2Jhc2V9LWNvbnRleHQtaWRgLFxuICAgIGlkOiBgJHtiYXNlfS1pZGBcbiAgfTtcbn0pKCk7XG5jb25zdCBzY3JvbGxDb250YWluZXIgPSB7XG4gIGNvbnRleHRJZDogYCR7cHJlZml4fS1zY3JvbGwtY29udGFpbmVyLWNvbnRleHQtaWRgXG59O1xuXG5jb25zdCBtYWtlR2V0U2VsZWN0b3IgPSBjb250ZXh0ID0+IGF0dHJpYnV0ZSA9PiBgWyR7YXR0cmlidXRlfT1cIiR7Y29udGV4dH1cIl1gO1xuY29uc3QgZ2V0U3R5bGVzID0gKHJ1bGVzLCBwcm9wZXJ0eSkgPT4gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHJ1bGUuc3R5bGVzW3Byb3BlcnR5XTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gYCR7cnVsZS5zZWxlY3Rvcn0geyAke3ZhbHVlfSB9YDtcbn0pLmpvaW4oJyAnKTtcbmNvbnN0IG5vUG9pbnRlckV2ZW50cyA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsnO1xudmFyIGdldFN0eWxlcyQxID0gY29udGV4dElkID0+IHtcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBtYWtlR2V0U2VsZWN0b3IoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZSQxID0gKCgpID0+IHtcbiAgICBjb25zdCBncmFiQ3Vyc29yID0gYFxuICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XG4gICAgICBjdXJzb3I6IGdyYWI7XG4gICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IGdldFNlbGVjdG9yKGRyYWdIYW5kbGUuY29udGV4dElkKSxcbiAgICAgIHN0eWxlczoge1xuICAgICAgICBhbHdheXM6IGBcbiAgICAgICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApO1xuICAgICAgICAgIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAgICAgICBgLFxuICAgICAgICByZXN0aW5nOiBncmFiQ3Vyc29yLFxuICAgICAgICBkcmFnZ2luZzogbm9Qb2ludGVyRXZlbnRzLFxuICAgICAgICBkcm9wQW5pbWF0aW5nOiBncmFiQ3Vyc29yXG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgZHJhZ2dhYmxlJDEgPSAoKCkgPT4ge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBgXG4gICAgICB0cmFuc2l0aW9uOiAke3RyYW5zaXRpb25zLm91dE9mVGhlV2F5fTtcbiAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJhZ2dhYmxlLmNvbnRleHRJZCksXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgZHJhZ2dpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIGRyb3BBbmltYXRpbmc6IHRyYW5zaXRpb24sXG4gICAgICAgIHVzZXJDYW5jZWw6IHRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuICBjb25zdCBkcm9wcGFibGUkMSA9IHtcbiAgICBzZWxlY3RvcjogZ2V0U2VsZWN0b3IoZHJvcHBhYmxlLmNvbnRleHRJZCksXG4gICAgc3R5bGVzOiB7XG4gICAgICBhbHdheXM6IGBvdmVyZmxvdy1hbmNob3I6IG5vbmU7YFxuICAgIH1cbiAgfTtcbiAgY29uc3QgYm9keSA9IHtcbiAgICBzZWxlY3RvcjogJ2JvZHknLFxuICAgIHN0eWxlczoge1xuICAgICAgZHJhZ2dpbmc6IGBcbiAgICAgICAgY3Vyc29yOiBncmFiYmluZztcbiAgICAgICAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBvdmVyZmxvdy1hbmNob3I6IG5vbmU7XG4gICAgICBgXG4gICAgfVxuICB9O1xuICBjb25zdCBydWxlcyA9IFtkcmFnZ2FibGUkMSwgZHJhZ0hhbmRsZSQxLCBkcm9wcGFibGUkMSwgYm9keV07XG4gIHJldHVybiB7XG4gICAgYWx3YXlzOiBnZXRTdHlsZXMocnVsZXMsICdhbHdheXMnKSxcbiAgICByZXN0aW5nOiBnZXRTdHlsZXMocnVsZXMsICdyZXN0aW5nJyksXG4gICAgZHJhZ2dpbmc6IGdldFN0eWxlcyhydWxlcywgJ2RyYWdnaW5nJyksXG4gICAgZHJvcEFuaW1hdGluZzogZ2V0U3R5bGVzKHJ1bGVzLCAnZHJvcEFuaW1hdGluZycpLFxuICAgIHVzZXJDYW5jZWw6IGdldFN0eWxlcyhydWxlcywgJ3VzZXJDYW5jZWwnKVxuICB9O1xufTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmNvbnN0IGdldEhlYWQgPSAoKSA9PiB7XG4gIGNvbnN0IGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICFoZWFkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGZpbmQgdGhlIGhlYWQgdG8gYXBwZW5kIGEgc3R5bGUgdG8nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gaGVhZDtcbn07XG5jb25zdCBjcmVhdGVTdHlsZUVsID0gbm9uY2UgPT4ge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cbiAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHJldHVybiBlbDtcbn07XG5mdW5jdGlvbiB1c2VTdHlsZU1hcnNoYWwoY29udGV4dElkLCBub25jZSkge1xuICBjb25zdCBzdHlsZXMgPSB1c2VNZW1vKCgpID0+IGdldFN0eWxlcyQxKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgYWx3YXlzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkeW5hbWljUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXREeW5hbWljU3R5bGUgPSB1c2VDYWxsYmFjayhtZW1vaXplT25lKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGR5bmFtaWNSZWYuY3VycmVudDtcbiAgICAhZWwgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2V0IGR5bmFtaWMgc3R5bGUgZWxlbWVudCBpZiBpdCBpcyBub3Qgc2V0JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBlbC50ZXh0Q29udGVudCA9IHByb3Bvc2VkO1xuICB9KSwgW10pO1xuICBjb25zdCBzZXRBbHdheXNTdHlsZSA9IHVzZUNhbGxiYWNrKHByb3Bvc2VkID0+IHtcbiAgICBjb25zdCBlbCA9IGFsd2F5c1JlZi5jdXJyZW50O1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBzZXQgZHluYW1pYyBzdHlsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBzZXQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGVsLnRleHRDb250ZW50ID0gcHJvcG9zZWQ7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgISghYWx3YXlzUmVmLmN1cnJlbnQgJiYgIWR5bmFtaWNSZWYuY3VycmVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdzdHlsZSBlbGVtZW50cyBhbHJlYWR5IG1vdW50ZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGFsd2F5cyA9IGNyZWF0ZVN0eWxlRWwobm9uY2UpO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBjcmVhdGVTdHlsZUVsKG5vbmNlKTtcbiAgICBhbHdheXNSZWYuY3VycmVudCA9IGFsd2F5cztcbiAgICBkeW5hbWljUmVmLmN1cnJlbnQgPSBkeW5hbWljO1xuICAgIGFsd2F5cy5zZXRBdHRyaWJ1dGUoYCR7cHJlZml4fS1hbHdheXNgLCBjb250ZXh0SWQpO1xuICAgIGR5bmFtaWMuc2V0QXR0cmlidXRlKGAke3ByZWZpeH0tZHluYW1pY2AsIGNvbnRleHRJZCk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGFsd2F5cyk7XG4gICAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGR5bmFtaWMpO1xuICAgIHNldEFsd2F5c1N0eWxlKHN0eWxlcy5hbHdheXMpO1xuICAgIHNldER5bmFtaWNTdHlsZShzdHlsZXMucmVzdGluZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJlbW92ZSA9IHJlZiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgIWN1cnJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgdW5tb3VudCByZWYgYXMgaXQgaXMgbm90IHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICAgIGdldEhlYWQoKS5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHJlbW92ZShhbHdheXNSZWYpO1xuICAgICAgcmVtb3ZlKGR5bmFtaWNSZWYpO1xuICAgIH07XG4gIH0sIFtub25jZSwgc2V0QWx3YXlzU3R5bGUsIHNldER5bmFtaWNTdHlsZSwgc3R5bGVzLmFsd2F5cywgc3R5bGVzLnJlc3RpbmcsIGNvbnRleHRJZF0pO1xuICBjb25zdCBkcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHNldER5bmFtaWNTdHlsZShzdHlsZXMuZHJhZ2dpbmcpLCBbc2V0RHluYW1pY1N0eWxlLCBzdHlsZXMuZHJhZ2dpbmddKTtcbiAgY29uc3QgZHJvcHBpbmcgPSB1c2VDYWxsYmFjayhyZWFzb24gPT4ge1xuICAgIGlmIChyZWFzb24gPT09ICdEUk9QJykge1xuICAgICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5kcm9wQW5pbWF0aW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy51c2VyQ2FuY2VsKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLmRyb3BBbmltYXRpbmcsIHN0eWxlcy51c2VyQ2FuY2VsXSk7XG4gIGNvbnN0IHJlc3RpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFkeW5hbWljUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RHluYW1pY1N0eWxlKHN0eWxlcy5yZXN0aW5nKTtcbiAgfSwgW3NldER5bmFtaWNTdHlsZSwgc3R5bGVzLnJlc3RpbmddKTtcbiAgY29uc3QgbWFyc2hhbCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcmFnZ2luZyxcbiAgICBkcm9wcGluZyxcbiAgICByZXN0aW5nXG4gIH0pLCBbZHJhZ2dpbmcsIGRyb3BwaW5nLCByZXN0aW5nXSk7XG4gIHJldHVybiBtYXJzaGFsO1xufVxuXG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKHBhcmVudE5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG52YXIgZ2V0V2luZG93RnJvbUVsID0gZWwgPT4ge1xuICBpZiAoZWwgJiYgZWwub3duZXJEb2N1bWVudCAmJiBlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB7XG4gICAgcmV0dXJuIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdztcbn07XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGVsIGluc3RhbmNlb2YgZ2V0V2luZG93RnJvbUVsKGVsKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdIYW5kbGUoY29udGV4dElkLCBkcmFnZ2FibGVJZCkge1xuICBjb25zdCBzZWxlY3RvciA9IGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xuICBjb25zdCBwb3NzaWJsZSA9IHF1ZXJ5U2VsZWN0b3JBbGwoZG9jdW1lbnQsIHNlbGVjdG9yKTtcbiAgaWYgKCFwb3NzaWJsZS5sZW5ndGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBhbnkgZHJhZyBoYW5kbGVzIGluIHRoZSBjb250ZXh0IFwiJHtjb250ZXh0SWR9XCJgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBoYW5kbGUgPSBwb3NzaWJsZS5maW5kKGVsID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKGRyYWdIYW5kbGUuZHJhZ2dhYmxlSWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghaGFuZGxlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZyBoYW5kbGUgd2l0aCBpZCBcIiR7ZHJhZ2dhYmxlSWR9XCIgYXMgbm8gaGFuZGxlIHdpdGggYSBtYXRjaGluZyBpZCB3YXMgZm91bmRgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoaGFuZGxlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ2RyYWcgaGFuZGxlIG5lZWRzIHRvIGJlIGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5mdW5jdGlvbiB1c2VGb2N1c01hcnNoYWwoY29udGV4dElkKSB7XG4gIGNvbnN0IGVudHJpZXNSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCByZWNvcmRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJlc3RvcmVGb2N1c0ZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCByZWdpc3RlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHJlZ2lzdGVyKGlkLCBmb2N1cykge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgaWQsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgZW50cmllc1JlZi5jdXJyZW50W2lkXSA9IGVudHJ5O1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGVudHJpZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBlbnRyaWVzW2lkXTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBlbnRyeSkge1xuICAgICAgICBkZWxldGUgZW50cmllc1tpZF07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCB0cnlHaXZlRm9jdXMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB0cnlHaXZlRm9jdXModHJ5R2l2ZUZvY3VzVG8pIHtcbiAgICBjb25zdCBoYW5kbGUgPSBmaW5kRHJhZ0hhbmRsZShjb250ZXh0SWQsIHRyeUdpdmVGb2N1c1RvKTtcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgaGFuZGxlLmZvY3VzKCk7XG4gICAgfVxuICB9LCBbY29udGV4dElkXSk7XG4gIGNvbnN0IHRyeVNoaWZ0UmVjb3JkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5U2hpZnRSZWNvcmQocHJldmlvdXMsIHJlZGlyZWN0VG8pIHtcbiAgICBpZiAocmVjb3JkUmVmLmN1cnJlbnQgPT09IHByZXZpb3VzKSB7XG4gICAgICByZWNvcmRSZWYuY3VycmVudCA9IHJlZGlyZWN0VG87XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQoKSB7XG4gICAgaWYgKHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN0b3JlRm9jdXNGcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3JkUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIHRyeUdpdmVGb2N1cyhyZWNvcmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbdHJ5R2l2ZUZvY3VzXSk7XG4gIGNvbnN0IHRyeVJlY29yZEZvY3VzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVjb3JkRm9jdXMoaWQpIHtcbiAgICByZWNvcmRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgY29uc3QgZm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmb2N1c2VkLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKSAhPT0gaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVjb3JkUmVmLmN1cnJlbnQgPSBpZDtcbiAgfSwgW10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyRnJhbWVPblVubW91bnQoKSB7XG4gICAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgZnJhbWVJZCA9IHJlc3RvcmVGb2N1c0ZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoZnJhbWVJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IG1hcnNoYWwgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcmVnaXN0ZXIsXG4gICAgdHJ5UmVjb3JkRm9jdXMsXG4gICAgdHJ5UmVzdG9yZUZvY3VzUmVjb3JkZWQsXG4gICAgdHJ5U2hpZnRSZWNvcmRcbiAgfSksIFtyZWdpc3RlciwgdHJ5UmVjb3JkRm9jdXMsIHRyeVJlc3RvcmVGb2N1c1JlY29yZGVkLCB0cnlTaGlmdFJlY29yZF0pO1xuICByZXR1cm4gbWFyc2hhbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7XG4gICAgZHJhZ2dhYmxlczoge30sXG4gICAgZHJvcHBhYmxlczoge31cbiAgfTtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGNiKSB7XG4gICAgc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKGNiKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goY2IgPT4gY2IoZXZlbnQpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZW50cmllcy5kcmFnZ2FibGVzW2lkXSB8fCBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGdldERyYWdnYWJsZUJ5SWQoaWQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmREcmFnZ2FibGVCeUlkKGlkKTtcbiAgICAhZW50cnkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3QgZmluZCBkcmFnZ2FibGUgZW50cnkgd2l0aCBpZCBbJHtpZH1dYCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbiAgY29uc3QgZHJhZ2dhYmxlQVBJID0ge1xuICAgIHJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICAgIG5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdBRERJVElPTicsXG4gICAgICAgIHZhbHVlOiBlbnRyeVxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IChlbnRyeSwgbGFzdCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGVudHJpZXMuZHJhZ2dhYmxlc1tsYXN0LmRlc2NyaXB0b3IuaWRdO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LnVuaXF1ZUlkICE9PSBlbnRyeS51bmlxdWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZW50cmllcy5kcmFnZ2FibGVzW2xhc3QuZGVzY3JpcHRvci5pZF07XG4gICAgICBlbnRyaWVzLmRyYWdnYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF0gPSBlbnRyeTtcbiAgICB9LFxuICAgIHVucmVnaXN0ZXI6IGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZW50cnkuZGVzY3JpcHRvci5pZDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBmaW5kRHJhZ2dhYmxlQnlJZChkcmFnZ2FibGVJZCk7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyYWdnYWJsZXNbZHJhZ2dhYmxlSWRdO1xuICAgICAgaWYgKGVudHJpZXMuZHJvcHBhYmxlc1tlbnRyeS5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkXSkge1xuICAgICAgICBub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICdSRU1PVkFMJyxcbiAgICAgICAgICB2YWx1ZTogZW50cnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcmFnZ2FibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJhZ2dhYmxlQnlJZCxcbiAgICBleGlzdHM6IGlkID0+IEJvb2xlYW4oZmluZERyYWdnYWJsZUJ5SWQoaWQpKSxcbiAgICBnZXRBbGxCeVR5cGU6IHR5cGUgPT4gT2JqZWN0LnZhbHVlcyhlbnRyaWVzLmRyYWdnYWJsZXMpLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGUpXG4gIH07XG4gIGZ1bmN0aW9uIGZpbmREcm9wcGFibGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGVudHJpZXMuZHJvcHBhYmxlc1tpZF0gfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXREcm9wcGFibGVCeUlkKGlkKSB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kRHJvcHBhYmxlQnlJZChpZCk7XG4gICAgIWVudHJ5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgQ2Fubm90IGZpbmQgZHJvcHBhYmxlIGVudHJ5IHdpdGggaWQgWyR7aWR9XWApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGNvbnN0IGRyb3BwYWJsZUFQSSA9IHtcbiAgICByZWdpc3RlcjogZW50cnkgPT4ge1xuICAgICAgZW50cmllcy5kcm9wcGFibGVzW2VudHJ5LmRlc2NyaXB0b3IuaWRdID0gZW50cnk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyOiBlbnRyeSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gZmluZERyb3BwYWJsZUJ5SWQoZW50cnkuZGVzY3JpcHRvci5pZCk7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVudHJ5LnVuaXF1ZUlkICE9PSBjdXJyZW50LnVuaXF1ZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBlbnRyaWVzLmRyb3BwYWJsZXNbZW50cnkuZGVzY3JpcHRvci5pZF07XG4gICAgfSxcbiAgICBnZXRCeUlkOiBnZXREcm9wcGFibGVCeUlkLFxuICAgIGZpbmRCeUlkOiBmaW5kRHJvcHBhYmxlQnlJZCxcbiAgICBleGlzdHM6IGlkID0+IEJvb2xlYW4oZmluZERyb3BwYWJsZUJ5SWQoaWQpKSxcbiAgICBnZXRBbGxCeVR5cGU6IHR5cGUgPT4gT2JqZWN0LnZhbHVlcyhlbnRyaWVzLmRyb3BwYWJsZXMpLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5kZXNjcmlwdG9yLnR5cGUgPT09IHR5cGUpXG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIGVudHJpZXMuZHJhZ2dhYmxlcyA9IHt9O1xuICAgIGVudHJpZXMuZHJvcHBhYmxlcyA9IHt9O1xuICAgIHN1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZUFQSSxcbiAgICBkcm9wcGFibGU6IGRyb3BwYWJsZUFQSSxcbiAgICBzdWJzY3JpYmUsXG4gICAgY2xlYW5cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlUmVnaXN0cnkoKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gdXNlTWVtbyhjcmVhdGVSZWdpc3RyeSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgcmVnaXN0cnkuY2xlYW4oKTtcbiAgICB9O1xuICB9LCBbcmVnaXN0cnldKTtcbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxuXG52YXIgU3RvcmVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxudmFyIGdldEJvZHlFbGVtZW50ID0gKCkgPT4ge1xuICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgIWJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgZmluZCBkb2N1bWVudC5ib2R5JykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGJvZHk7XG59O1xuXG5jb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAnMXB4JyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIGJvcmRlcjogJzAnLFxuICBwYWRkaW5nOiAnMCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAnY2xpcC1wYXRoJzogJ2luc2V0KDEwMCUpJ1xufTtcblxuY29uc3QgZ2V0SWQgPSBjb250ZXh0SWQgPT4gYHJmZC1hbm5vdW5jZW1lbnQtJHtjb250ZXh0SWR9YDtcbmZ1bmN0aW9uIHVzZUFubm91bmNlcihjb250ZXh0SWQpIHtcbiAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGdldElkKGNvbnRleHRJZCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZWYuY3VycmVudCA9IGVsO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XG4gICAgX2V4dGVuZHMoZWwuc3R5bGUsIHZpc3VhbGx5SGlkZGVuKTtcbiAgICBnZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09PSByZWYuY3VycmVudCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lkXSk7XG4gIGNvbnN0IGFubm91bmNlID0gdXNlQ2FsbGJhY2sobWVzc2FnZSA9PiB7XG4gICAgY29uc3QgZWwgPSByZWYuY3VycmVudDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBBIHNjcmVlbiByZWFkZXIgbWVzc2FnZSB3YXMgdHJ5aW5nIHRvIGJlIGFubm91bmNlZCBidXQgaXQgd2FzIHVuYWJsZSB0byBkbyBzby5cbiAgICAgIFRoaXMgY2FuIG9jY3VyIGlmIHlvdSB1bm1vdW50IHlvdXIgPERyYWdEcm9wQ29udGV4dCAvPiBpbiB5b3VyIG9uRHJhZ0VuZC5cbiAgICAgIENvbnNpZGVyIGNhbGxpbmcgcHJvdmlkZWQuYW5ub3VuY2UoKSBiZWZvcmUgdGhlIHVubW91bnQgc28gdGhhdCB0aGUgaW5zdHJ1Y3Rpb24gd2lsbFxuICAgICAgbm90IGJlIGxvc3QgZm9yIHVzZXJzIHJlbHlpbmcgb24gYSBzY3JlZW4gcmVhZGVyLlxuXG4gICAgICBNZXNzYWdlIG5vdCBwYXNzZWQgdG8gc2NyZWVuIHJlYWRlcjpcblxuICAgICAgXCIke21lc3NhZ2V9XCJcbiAgICBgKSA6IHZvaWQgMDtcbiAgfSwgW10pO1xuICByZXR1cm4gYW5ub3VuY2U7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICBzZXBhcmF0b3I6ICc6Oidcbn07XG5mdW5jdGlvbiB1c2VVbmlxdWVJZChwcmVmaXgsIG9wdGlvbnMgPSBkZWZhdWx0cykge1xuICBjb25zdCBpZCA9IFJlYWN0LnVzZUlkKCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGAke3ByZWZpeH0ke29wdGlvbnMuc2VwYXJhdG9yfSR7aWR9YCwgW29wdGlvbnMuc2VwYXJhdG9yLCBwcmVmaXgsIGlkXSk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJZCh7XG4gIGNvbnRleHRJZCxcbiAgdW5pcXVlSWRcbn0pIHtcbiAgcmV0dXJuIGByZmQtaGlkZGVuLXRleHQtJHtjb250ZXh0SWR9LSR7dW5pcXVlSWR9YDtcbn1cbmZ1bmN0aW9uIHVzZUhpZGRlblRleHRFbGVtZW50KHtcbiAgY29udGV4dElkLFxuICB0ZXh0XG59KSB7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2hpZGRlbi10ZXh0Jywge1xuICAgIHNlcGFyYXRvcjogJy0nXG4gIH0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8oKCkgPT4gZ2V0RWxlbWVudElkKHtcbiAgICBjb250ZXh0SWQsXG4gICAgdW5pcXVlSWRcbiAgfSksIFt1bmlxdWVJZCwgY29udGV4dElkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBtb3VudCgpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLmlkID0gaWQ7XG4gICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgIGlmIChib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaWQsIHRleHRdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgQXBwQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbnZhciBwZWVyRGVwZW5kZW5jaWVzID0ge1xuXHRyZWFjdDogXCJeMTguMC4wIHx8IF4xOS4wLjBcIn07XG5cbmNvbnN0IHNlbXZlciA9IC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvO1xuY29uc3QgZ2V0VmVyc2lvbiA9IHZhbHVlID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gc2VtdmVyLmV4ZWModmFsdWUpO1xuICAhKHJlc3VsdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYFVuYWJsZSB0byBwYXJzZSBSZWFjdCB2ZXJzaW9uICR7dmFsdWV9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgY29uc3QgbWFqb3IgPSBOdW1iZXIocmVzdWx0WzFdKTtcbiAgY29uc3QgbWlub3IgPSBOdW1iZXIocmVzdWx0WzJdKTtcbiAgY29uc3QgcGF0Y2ggPSBOdW1iZXIocmVzdWx0WzNdKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcixcbiAgICBtaW5vcixcbiAgICBwYXRjaCxcbiAgICByYXc6IHZhbHVlXG4gIH07XG59O1xuY29uc3QgaXNTYXRpc2ZpZWQgPSAoZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuICBpZiAoYWN0dWFsLm1ham9yID4gZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYWN0dWFsLm1ham9yIDwgZXhwZWN0ZWQubWFqb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFjdHVhbC5taW5vciA+IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFjdHVhbC5taW5vciA8IGV4cGVjdGVkLm1pbm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBhY3R1YWwucGF0Y2ggPj0gZXhwZWN0ZWQucGF0Y2g7XG59O1xudmFyIGNoZWNrUmVhY3RWZXJzaW9uID0gKHBlZXJEZXBWYWx1ZSwgYWN0dWFsVmFsdWUpID0+IHtcbiAgY29uc3QgcGVlckRlcCA9IGdldFZlcnNpb24ocGVlckRlcFZhbHVlKTtcbiAgY29uc3QgYWN0dWFsID0gZ2V0VmVyc2lvbihhY3R1YWxWYWx1ZSk7XG4gIGlmIChpc1NhdGlzZmllZChwZWVyRGVwLCBhY3R1YWwpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgIFJlYWN0IHZlcnNpb246IFske2FjdHVhbC5yYXd9XVxuICAgIGRvZXMgbm90IHNhdGlzZnkgZXhwZWN0ZWQgcGVlciBkZXBlbmRlbmN5IHZlcnNpb246IFske3BlZXJEZXAucmF3fV1cblxuICAgIFRoaXMgY2FuIHJlc3VsdCBpbiBydW4gdGltZSBidWdzLCBhbmQgZXZlbiBmYXRhbCBjcmFzaGVzXG4gIGApIDogdm9pZCAwO1xufTtcblxuY29uc3Qgc3VmZml4ID0gYFxuICBXZSBleHBlY3QgYSBodG1sNSBkb2N0eXBlOiA8IWRvY3R5cGUgaHRtbD5cbiAgVGhpcyBpcyB0byBlbnN1cmUgY29uc2lzdGVudCBicm93c2VyIGxheW91dCBhbmQgbWVhc3VyZW1lbnRcblxuICBNb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvZG9jdHlwZS5tZFxuYDtcbnZhciBjaGVja0RvY3R5cGUgPSBkb2MgPT4ge1xuICBjb25zdCBkb2N0eXBlID0gZG9jLmRvY3R5cGU7XG4gIGlmICghZG9jdHlwZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgTm8gPCFkb2N0eXBlIGh0bWw+IGZvdW5kLlxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRvY3R5cGUubmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICAgIFVuZXhwZWN0ZWQgPCFkb2N0eXBlPiBmb3VuZDogKCR7ZG9jdHlwZS5uYW1lfSlcblxuICAgICAgJHtzdWZmaXh9XG4gICAgYCkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKGRvY3R5cGUucHVibGljSWQgIT09ICcnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICBVbmV4cGVjdGVkIDwhZG9jdHlwZT4gcHVibGljSWQgZm91bmQ6ICgke2RvY3R5cGUucHVibGljSWR9KVxuICAgICAgQSBodG1sNSBkb2N0eXBlIGRvZXMgbm90IGhhdmUgYSBwdWJsaWNJZFxuXG4gICAgICAke3N1ZmZpeH1cbiAgICBgKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXNlRGV2KHVzZUhvb2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1c2VIb29rKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlRGV2U2V0dXBXYXJuaW5nKGZuLCBpbnB1dHMpIHtcbiAgdXNlRGV2KCgpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoYFxuICAgICAgICAgIEEgc2V0dXAgcHJvYmxlbSB3YXMgZW5jb3VudGVyZWQuXG5cbiAgICAgICAgICA+ICR7ZS5tZXNzYWdlfVxuICAgICAgICBgKTtcbiAgICAgIH1cbiAgICB9LCBpbnB1dHMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhcnR1cFZhbGlkYXRpb24oKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgY2hlY2tSZWFjdFZlcnNpb24ocGVlckRlcGVuZGVuY2llcy5yZWFjdCwgUmVhY3QudmVyc2lvbik7XG4gICAgY2hlY2tEb2N0eXBlKGRvY3VtZW50KTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyhjdXJyZW50KSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihjdXJyZW50KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBsb2NrID0gbnVsbDtcbiAgZnVuY3Rpb24gaXNDbGFpbWVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWN0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsb2NrO1xuICB9XG4gIGZ1bmN0aW9uIGNsYWltKGFiYW5kb24pIHtcbiAgICAhIWxvY2sgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2xhaW0gbG9jayBhcyBpdCBpcyBhbHJlYWR5IGNsYWltZWQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG5ld0xvY2sgPSB7XG4gICAgICBhYmFuZG9uXG4gICAgfTtcbiAgICBsb2NrID0gbmV3TG9jaztcbiAgICByZXR1cm4gbmV3TG9jaztcbiAgfVxuICBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgICFsb2NrID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHJlbGVhc2UgbG9jayB3aGVuIHRoZXJlIGlzIG5vIGxvY2snKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGxvY2sgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUFiYW5kb24oKSB7XG4gICAgaWYgKGxvY2spIHtcbiAgICAgIGxvY2suYWJhbmRvbigpO1xuICAgICAgcmVsZWFzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzQ2xhaW1lZCxcbiAgICBpc0FjdGl2ZSxcbiAgICBjbGFpbSxcbiAgICByZWxlYXNlLFxuICAgIHRyeUFiYW5kb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNEcmFnZ2luZyhzdGF0ZSkge1xuICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyB8fCBzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbn1cblxuY29uc3QgdGFiID0gOTtcbmNvbnN0IGVudGVyID0gMTM7XG5jb25zdCBlc2NhcGUgPSAyNztcbmNvbnN0IHNwYWNlID0gMzI7XG5jb25zdCBwYWdlVXAgPSAzMztcbmNvbnN0IHBhZ2VEb3duID0gMzQ7XG5jb25zdCBlbmQgPSAzNTtcbmNvbnN0IGhvbWUgPSAzNjtcbmNvbnN0IGFycm93TGVmdCA9IDM3O1xuY29uc3QgYXJyb3dVcCA9IDM4O1xuY29uc3QgYXJyb3dSaWdodCA9IDM5O1xuY29uc3QgYXJyb3dEb3duID0gNDA7XG5cbmNvbnN0IHByZXZlbnRlZEtleXMgPSB7XG4gIFtlbnRlcl06IHRydWUsXG4gIFt0YWJdOiB0cnVlXG59O1xudmFyIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyA9IGV2ZW50ID0+IHtcbiAgaWYgKHByZXZlbnRlZEtleXNbZXZlbnQua2V5Q29kZV0pIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG5jb25zdCBzdXBwb3J0ZWRFdmVudE5hbWUgPSAoKCkgPT4ge1xuICBjb25zdCBiYXNlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbYmFzZSwgYG1zJHtiYXNlfWAsIGB3ZWJraXQke2Jhc2V9YCwgYG1veiR7YmFzZX1gLCBgbyR7YmFzZX1gXTtcbiAgY29uc3Qgc3VwcG9ydGVkID0gY2FuZGlkYXRlcy5maW5kKGV2ZW50TmFtZSA9PiBgb24ke2V2ZW50TmFtZX1gIGluIGRvY3VtZW50KTtcbiAgcmV0dXJuIHN1cHBvcnRlZCB8fCBiYXNlO1xufSkoKTtcblxuY29uc3QgcHJpbWFyeUJ1dHRvbiA9IDA7XG5jb25zdCBzbG9wcHlDbGlja1RocmVzaG9sZCA9IDU7XG5mdW5jdGlvbiBpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQob3JpZ2luYWwsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGN1cnJlbnQueCAtIG9yaWdpbmFsLngpID49IHNsb3BweUNsaWNrVGhyZXNob2xkIHx8IE1hdGguYWJzKGN1cnJlbnQueSAtIG9yaWdpbmFsLnkpID49IHNsb3BweUNsaWNrVGhyZXNob2xkO1xufVxuY29uc3QgaWRsZSQxID0ge1xuICB0eXBlOiAnSURMRSdcbn07XG5mdW5jdGlvbiBnZXRDYXB0dXJlQmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGNvbXBsZXRlZCxcbiAgZ2V0UGhhc2UsXG4gIHNldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ21vdXNlbW92ZScsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYnV0dG9uLFxuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBpZiAoYnV0dG9uICE9PSBwcmltYXJ5QnV0dG9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGhhc2UuYWN0aW9ucy5tb3ZlKHBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgIShwaGFzZS50eXBlID09PSAnUEVORElORycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGJlIElETEUnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgY29uc3QgcGVuZGluZyA9IHBoYXNlLnBvaW50O1xuICAgICAgaWYgKCFpc1Nsb3BweUNsaWNrVGhyZXNob2xkRXhjZWVkZWQocGVuZGluZywgcG9pbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocG9pbnQpO1xuICAgICAgc2V0UGhhc2Uoe1xuICAgICAgICB0eXBlOiAnRFJBR0dJTkcnLFxuICAgICAgICBhY3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBwaGFzZS5hY3Rpb25zLmRyb3Aoe1xuICAgICAgICBzaG91bGRCbG9ja05leHRDbGljazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZWRvd24nLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBpZiAoZ2V0UGhhc2UoKS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBjYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJldmVudFN0YW5kYXJkS2V5RXZlbnRzKGV2ZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3Njcm9sbCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSxcbiAgICBmbjogKCkgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZSgpO1xuICAgICAgIShwaGFzZS50eXBlICE9PSAnSURMRScpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBwaGFzZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICBpZiAocGhhc2UuYWN0aW9ucy5zaG91bGRSZXNwZWN0Rm9yY2VQcmVzcygpKSB7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogc3VwcG9ydGVkRXZlbnROYW1lLFxuICAgIGZuOiBjYW5jZWxcbiAgfV07XG59XG5mdW5jdGlvbiB1c2VNb3VzZVNlbnNvcihhcGkpIHtcbiAgY29uc3QgcGhhc2VSZWYgPSB1c2VSZWYoaWRsZSQxKTtcbiAgY29uc3QgdW5iaW5kRXZlbnRzUmVmID0gdXNlUmVmKG5vb3AkMik7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IHByaW1hcnlCdXR0b24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBzdGFydFBlbmRpbmdEcmFnKGFjdGlvbnMsIHBvaW50KTtcbiAgICB9XG4gIH0pLCBbYXBpXSk7XG4gIGNvbnN0IHByZXZlbnRGb3JjZVByZXNzQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICd3ZWJraXRtb3VzZWZvcmNld2lsbGJlZ2luJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcGkuZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUoaWQpO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYXBpLmNhbkdldExvY2soaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbcHJldmVudEZvcmNlUHJlc3NCaW5kaW5nLCBzdGFydENhcHR1cmVCaW5kaW5nXSwgb3B0aW9ucyk7XG4gIH0sIFtwcmV2ZW50Rm9yY2VQcmVzc0JpbmRpbmcsIHN0YXJ0Q2FwdHVyZUJpbmRpbmddKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnSURMRScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IGlkbGUkMTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbiAgY29uc3QgY2FuY2VsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHBoYXNlID0gcGhhc2VSZWYuY3VycmVudDtcbiAgICBzdG9wKCk7XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdEUkFHR0lORycpIHtcbiAgICAgIHBoYXNlLmFjdGlvbnMuY2FuY2VsKHtcbiAgICAgICAgc2hvdWxkQmxvY2tOZXh0Q2xpY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmFib3J0KCk7XG4gICAgfVxuICB9LCBbc3RvcF0pO1xuICBjb25zdCBiaW5kQ2FwdHVyaW5nRXZlbnRzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gYmluZENhcHR1cmluZ0V2ZW50cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IGdldENhcHR1cmVCaW5kaW5ncyh7XG4gICAgICBjYW5jZWwsXG4gICAgICBjb21wbGV0ZWQ6IHN0b3AsXG4gICAgICBnZXRQaGFzZTogKCkgPT4gcGhhc2VSZWYuY3VycmVudCxcbiAgICAgIHNldFBoYXNlOiBwaGFzZSA9PiB7XG4gICAgICAgIHBoYXNlUmVmLmN1cnJlbnQgPSBwaGFzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBiaW5kaW5ncywgb3B0aW9ucyk7XG4gIH0sIFtjYW5jZWwsIHN0b3BdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKHBoYXNlUmVmLmN1cnJlbnQudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHtcbiAgICAgIHR5cGU6ICdQRU5ESU5HJyxcbiAgICAgIHBvaW50LFxuICAgICAgYWN0aW9uc1xuICAgIH07XG4gICAgYmluZENhcHR1cmluZ0V2ZW50cygpO1xuICB9LCBbYmluZENhcHR1cmluZ0V2ZW50c10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cbmNvbnN0IHNjcm9sbEp1bXBLZXlzID0ge1xuICBbcGFnZURvd25dOiB0cnVlLFxuICBbcGFnZVVwXTogdHJ1ZSxcbiAgW2hvbWVdOiB0cnVlLFxuICBbZW5kXTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCkge1xuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgc3RvcCgpO1xuICAgIGFjdGlvbnMuY2FuY2VsKCk7XG4gIH1cbiAgZnVuY3Rpb24gZHJvcCgpIHtcbiAgICBzdG9wKCk7XG4gICAgYWN0aW9ucy5kcm9wKCk7XG4gIH1cbiAgcmV0dXJuIFt7XG4gICAgZXZlbnROYW1lOiAna2V5ZG93bicsXG4gICAgZm46IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBlc2NhcGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBzcGFjZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkcm9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBhcnJvd0Rvd24pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWN0aW9ucy5tb3ZlRG93bigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dVcCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVVcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dSaWdodCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhY3Rpb25zLm1vdmVSaWdodCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gYXJyb3dMZWZ0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGFjdGlvbnMubW92ZUxlZnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbEp1bXBLZXlzW2V2ZW50LmtleUNvZGVdKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRTdGFuZGFyZEtleUV2ZW50cyhldmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAnbW91c2Vkb3duJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdtb3VzZXVwJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdjbGljaycsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGNhbmNlbFxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAncmVzaXplJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICd3aGVlbCcsXG4gICAgZm46IGNhbmNlbCxcbiAgICBvcHRpb25zOiB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkU2Vuc29yKGFwaSkge1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQxKTtcbiAgY29uc3Qgc3RhcnRDYXB0dXJlQmluZGluZyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPT0gc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZURyYWcgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFwcmVEcmFnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBsZXQgaXNDYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYWN0aW9ucyA9IHByZURyYWcuc25hcExpZnQoKTtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAhaXNDYXB0dXJpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBjYXB0dXJpbmcgYSBrZXlib2FyZCBkcmFnIHdoZW4gbm90IGNhcHR1cmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgICAgIGlzQ2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICAgIH1cbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50ID0gYmluZEV2ZW50cyh3aW5kb3csIGdldERyYWdnaW5nQmluZGluZ3MoYWN0aW9ucywgc3RvcCksIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIFthcGldKTtcbiAgY29uc3QgbGlzdGVuRm9yQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeVN0YXJ0Q2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgfTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmVdKTtcbn1cblxuY29uc3QgaWRsZSA9IHtcbiAgdHlwZTogJ0lETEUnXG59O1xuY29uc3QgdGltZUZvckxvbmdQcmVzcyA9IDEyMDtcbmNvbnN0IGZvcmNlUHJlc3NUaHJlc2hvbGQgPSAwLjE1O1xuZnVuY3Rpb24gZ2V0V2luZG93QmluZGluZ3Moe1xuICBjYW5jZWwsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ29yaWVudGF0aW9uY2hhbmdlJyxcbiAgICBmbjogY2FuY2VsXG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdyZXNpemUnLFxuICAgIGZuOiBjYW5jZWxcbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ2NvbnRleHRtZW51JyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6ICdrZXlkb3duJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IGVzY2FwZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiBzdXBwb3J0ZWRFdmVudE5hbWUsXG4gICAgZm46IGNhbmNlbFxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldEhhbmRsZUJpbmRpbmdzKHtcbiAgY2FuY2VsLFxuICBjb21wbGV0ZWQsXG4gIGdldFBoYXNlXG59KSB7XG4gIHJldHVybiBbe1xuICAgIGV2ZW50TmFtZTogJ3RvdWNobW92ZScsXG4gICAgb3B0aW9uczoge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9LFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGhhc2UuaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYLFxuICAgICAgICBjbGllbnRZXG4gICAgICB9ID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHBvaW50ID0ge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMubW92ZShwb2ludCk7XG4gICAgfVxuICB9LCB7XG4gICAgZXZlbnROYW1lOiAndG91Y2hlbmQnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHBoYXNlLmFjdGlvbnMuZHJvcCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoY2FuY2VsJyxcbiAgICBmbjogZXZlbnQgPT4ge1xuICAgICAgaWYgKGdldFBoYXNlKCkudHlwZSAhPT0gJ0RSQUdHSU5HJykge1xuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGV2ZW50TmFtZTogJ3RvdWNoZm9yY2VjaGFuZ2UnLFxuICAgIGZuOiBldmVudCA9PiB7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICAhKHBoYXNlLnR5cGUgIT09ICdJRExFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgaWYgKCF0b3VjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0ZvcmNlUHJlc3MgPSB0b3VjaC5mb3JjZSA+PSBmb3JjZVByZXNzVGhyZXNob2xkO1xuICAgICAgaWYgKCFpc0ZvcmNlUHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmVzcGVjdCA9IHBoYXNlLmFjdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKTtcbiAgICAgIGlmIChwaGFzZS50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc3BlY3QpIHtcbiAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVzcGVjdCkge1xuICAgICAgICBpZiAocGhhc2UuaGFzTW92ZWQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBldmVudE5hbWU6IHN1cHBvcnRlZEV2ZW50TmFtZSxcbiAgICBmbjogY2FuY2VsXG4gIH1dO1xufVxuZnVuY3Rpb24gdXNlVG91Y2hTZW5zb3IoYXBpKSB7XG4gIGNvbnN0IHBoYXNlUmVmID0gdXNlUmVmKGlkbGUpO1xuICBjb25zdCB1bmJpbmRFdmVudHNSZWYgPSB1c2VSZWYobm9vcCQyKTtcbiAgY29uc3QgZ2V0UGhhc2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBnZXRQaGFzZSgpIHtcbiAgICByZXR1cm4gcGhhc2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBzZXRQaGFzZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHNldFBoYXNlKHBoYXNlKSB7XG4gICAgcGhhc2VSZWYuY3VycmVudCA9IHBoYXNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IHN0YXJ0Q2FwdHVyZUJpbmRpbmcgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgZXZlbnROYW1lOiAndG91Y2hzdGFydCcsXG4gICAgZm46IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dhYmxlSWQgPSBhcGkuZmluZENsb3Nlc3REcmFnZ2FibGVJZChldmVudCk7XG4gICAgICBpZiAoIWRyYWdnYWJsZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBhcGkudHJ5R2V0TG9jayhkcmFnZ2FibGVJZCwgc3RvcCwge1xuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IHRvdWNoO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH07XG4gICAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgICAgc3RhcnRQZW5kaW5nRHJhZyhhY3Rpb25zLCBwb2ludCk7XG4gICAgfVxuICB9KSwgW2FwaV0pO1xuICBjb25zdCBsaXN0ZW5Gb3JDYXB0dXJlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gbGlzdGVuRm9yQ2FwdHVyZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCA9IGJpbmRFdmVudHMod2luZG93LCBbc3RhcnRDYXB0dXJlQmluZGluZ10sIG9wdGlvbnMpO1xuICB9LCBbc3RhcnRDYXB0dXJlQmluZGluZ10pO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwaGFzZVJlZi5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC50eXBlID09PSAnUEVORElORycpIHtcbiAgICAgIGNsZWFyVGltZW91dChjdXJyZW50LmxvbmdQcmVzc1RpbWVySWQpO1xuICAgIH1cbiAgICBzZXRQaGFzZShpZGxlKTtcbiAgICB1bmJpbmRFdmVudHNSZWYuY3VycmVudCgpO1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgfSwgW2xpc3RlbkZvckNhcHR1cmUsIHNldFBoYXNlXSk7XG4gIGNvbnN0IGNhbmNlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBwaGFzZSA9IHBoYXNlUmVmLmN1cnJlbnQ7XG4gICAgc3RvcCgpO1xuICAgIGlmIChwaGFzZS50eXBlID09PSAnRFJBR0dJTkcnKSB7XG4gICAgICBwaGFzZS5hY3Rpb25zLmNhbmNlbCh7XG4gICAgICAgIHNob3VsZEJsb2NrTmV4dENsaWNrOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykge1xuICAgICAgcGhhc2UuYWN0aW9ucy5hYm9ydCgpO1xuICAgIH1cbiAgfSwgW3N0b3BdKTtcbiAgY29uc3QgYmluZENhcHR1cmluZ0V2ZW50cyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIGJpbmRDYXB0dXJpbmdFdmVudHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbXBsZXRlZDogc3RvcCxcbiAgICAgIGdldFBoYXNlXG4gICAgfTtcbiAgICBjb25zdCB1bmJpbmRUYXJnZXQgPSBiaW5kRXZlbnRzKHdpbmRvdywgZ2V0SGFuZGxlQmluZGluZ3MoYXJncyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuYmluZFdpbmRvdyA9IGJpbmRFdmVudHMod2luZG93LCBnZXRXaW5kb3dCaW5kaW5ncyhhcmdzKSwgb3B0aW9ucyk7XG4gICAgdW5iaW5kRXZlbnRzUmVmLmN1cnJlbnQgPSBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB1bmJpbmRUYXJnZXQoKTtcbiAgICAgIHVuYmluZFdpbmRvdygpO1xuICAgIH07XG4gIH0sIFtjYW5jZWwsIGdldFBoYXNlLCBzdG9wXSk7XG4gIGNvbnN0IHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBzdGFydERyYWdnaW5nKCkge1xuICAgIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoKTtcbiAgICAhKHBoYXNlLnR5cGUgPT09ICdQRU5ESU5HJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBDYW5ub3Qgc3RhcnQgZHJhZ2dpbmcgZnJvbSBwaGFzZSAke3BoYXNlLnR5cGV9YCkgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhY3Rpb25zID0gcGhhc2UuYWN0aW9ucy5mbHVpZExpZnQocGhhc2UucG9pbnQpO1xuICAgIHNldFBoYXNlKHtcbiAgICAgIHR5cGU6ICdEUkFHR0lORycsXG4gICAgICBhY3Rpb25zLFxuICAgICAgaGFzTW92ZWQ6IGZhbHNlXG4gICAgfSk7XG4gIH0sIFtnZXRQaGFzZSwgc2V0UGhhc2VdKTtcbiAgY29uc3Qgc3RhcnRQZW5kaW5nRHJhZyA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHN0YXJ0UGVuZGluZ0RyYWcoYWN0aW9ucywgcG9pbnQpIHtcbiAgICAhKGdldFBoYXNlKCkudHlwZSA9PT0gJ0lETEUnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIG1vdmUgZnJvbSBJRExFIHRvIFBFTkRJTkcgZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbG9uZ1ByZXNzVGltZXJJZCA9IHNldFRpbWVvdXQoc3RhcnREcmFnZ2luZywgdGltZUZvckxvbmdQcmVzcyk7XG4gICAgc2V0UGhhc2Uoe1xuICAgICAgdHlwZTogJ1BFTkRJTkcnLFxuICAgICAgcG9pbnQsXG4gICAgICBhY3Rpb25zLFxuICAgICAgbG9uZ1ByZXNzVGltZXJJZFxuICAgIH0pO1xuICAgIGJpbmRDYXB0dXJpbmdFdmVudHMoKTtcbiAgfSwgW2JpbmRDYXB0dXJpbmdFdmVudHMsIGdldFBoYXNlLCBzZXRQaGFzZSwgc3RhcnREcmFnZ2luZ10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIG1vdW50KCkge1xuICAgIGxpc3RlbkZvckNhcHR1cmUoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVuYmluZEV2ZW50c1JlZi5jdXJyZW50KCk7XG4gICAgICBjb25zdCBwaGFzZSA9IGdldFBoYXNlKCk7XG4gICAgICBpZiAocGhhc2UudHlwZSA9PT0gJ1BFTkRJTkcnKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChwaGFzZS5sb25nUHJlc3NUaW1lcklkKTtcbiAgICAgICAgc2V0UGhhc2UoaWRsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2dldFBoYXNlLCBsaXN0ZW5Gb3JDYXB0dXJlLCBzZXRQaGFzZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uIHdlYmtpdEhhY2soKSB7XG4gICAgY29uc3QgdW5iaW5kID0gYmluZEV2ZW50cyh3aW5kb3csIFt7XG4gICAgICBldmVudE5hbWU6ICd0b3VjaG1vdmUnLFxuICAgICAgZm46ICgpID0+IHt9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIHVuYmluZDtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHNlbnNvckhvb2tzKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhzZW5zb3JIb29rcyk7XG4gICAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICAgICEocHJldmlvdXNSZWYuY3VycmVudC5sZW5ndGggPT09IHNlbnNvckhvb2tzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY2hhbmdlIHRoZSBhbW91bnQgb2Ygc2Vuc29yIGhvb2tzIGFmdGVyIG1vdW50aW5nJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgaW50ZXJhY3RpdmVUYWdOYW1lcyA9IFsnaW5wdXQnLCAnYnV0dG9uJywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAndmlkZW8nLCAnYXVkaW8nXTtcbmZ1bmN0aW9uIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50LCBjdXJyZW50KSB7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaGFzQW5JbnRlcmFjdGl2ZVRhZyA9IGludGVyYWN0aXZlVGFnTmFtZXMuaW5jbHVkZXMoY3VycmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICBpZiAoaGFzQW5JbnRlcmFjdGl2ZVRhZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKTtcbiAgaWYgKGF0dHJpYnV0ZSA9PT0gJ3RydWUnIHx8IGF0dHJpYnV0ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY3VycmVudCA9PT0gcGFyZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0FuSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudCwgY3VycmVudC5wYXJlbnRFbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRJbkludGVyYWN0aXZlRWxlbWVudChkcmFnZ2FibGUsIGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0h0bWxFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzQW5JbnRlcmFjdGl2ZUVsZW1lbnQoZHJhZ2dhYmxlLCB0YXJnZXQpO1xufVxuXG52YXIgZ2V0Qm9yZGVyQm94Q2VudGVyUG9zaXRpb24gPSBlbCA9PiBnZXRSZWN0KGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS5jZW50ZXI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChlbCkge1xuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBnZXRXaW5kb3dGcm9tRWwoZWwpLkVsZW1lbnQ7XG59XG5cbmNvbnN0IHN1cHBvcnRlZE1hdGNoZXNOYW1lID0gKCgpID0+IHtcbiAgY29uc3QgYmFzZSA9ICdtYXRjaGVzJztcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBjb25zdCBjYW5kaWRhdGVzID0gW2Jhc2UsICdtc01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcbiAgY29uc3QgdmFsdWUgPSBjYW5kaWRhdGVzLmZpbmQobmFtZSA9PiBuYW1lIGluIEVsZW1lbnQucHJvdG90eXBlKTtcbiAgcmV0dXJuIHZhbHVlIHx8IGJhc2U7XG59KSgpO1xuZnVuY3Rpb24gY2xvc2VzdFBvbnlmaWxsKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChlbFtzdXBwb3J0ZWRNYXRjaGVzTmFtZV0oc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UG9ueWZpbGwoZWwucGFyZW50RWxlbWVudCwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQb255ZmlsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rvcihjb250ZXh0SWQpIHtcbiAgcmV0dXJuIGBbJHtkcmFnSGFuZGxlLmNvbnRleHRJZH09XCIke2NvbnRleHRJZH1cIl1gO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3REcmFnSGFuZGxlRnJvbUV2ZW50KGNvbnRleHRJZCwgZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZXZlbnQudGFyZ2V0IG11c3QgYmUgYSBFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3Rvcihjb250ZXh0SWQpO1xuICBjb25zdCBoYW5kbGUgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IpO1xuICBpZiAoIWhhbmRsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNIdG1sRWxlbWVudChoYW5kbGUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnZHJhZyBoYW5kbGUgbXVzdCBiZSBhIEhUTUxFbGVtZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIHRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KSB7XG4gIGNvbnN0IGhhbmRsZSA9IGZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudChjb250ZXh0SWQsIGV2ZW50KTtcbiAgaWYgKCFoYW5kbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFuZGxlLmdldEF0dHJpYnV0ZShkcmFnSGFuZGxlLmRyYWdnYWJsZUlkKTtcbn1cblxuZnVuY3Rpb24gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGRyYWdnYWJsZUlkKSB7XG4gIGNvbnN0IHNlbGVjdG9yID0gYFske2RyYWdnYWJsZS5jb250ZXh0SWR9PVwiJHtjb250ZXh0SWR9XCJdYDtcbiAgY29uc3QgcG9zc2libGUgPSBxdWVyeVNlbGVjdG9yQWxsKGRvY3VtZW50LCBzZWxlY3Rvcik7XG4gIGNvbnN0IGRyYWdnYWJsZSQxID0gcG9zc2libGUuZmluZChlbCA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShkcmFnZ2FibGUuaWQpID09PSBkcmFnZ2FibGVJZDtcbiAgfSk7XG4gIGlmICghZHJhZ2dhYmxlJDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWlzSHRtbEVsZW1lbnQoZHJhZ2dhYmxlJDEpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygnRHJhZ2dhYmxlIGVsZW1lbnQgaXMgbm90IGEgSFRNTEVsZW1lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZHJhZ2dhYmxlJDE7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBpc0FjdGl2ZSh7XG4gIGV4cGVjdGVkLFxuICBwaGFzZSxcbiAgaXNMb2NrQWN0aXZlLFxuICBzaG91bGRXYXJuXG59KSB7XG4gIGlmICghaXNMb2NrQWN0aXZlKCkpIHtcbiAgICBpZiAoc2hvdWxkV2Fybikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgICAgIENhbm5vdCBwZXJmb3JtIGFjdGlvbi5cbiAgICAgICAgVGhlIHNlbnNvciBubyBsb25nZXIgaGFzIGFuIGFjdGlvbiBsb2NrLlxuXG4gICAgICAgIFRpcHM6XG5cbiAgICAgICAgLSBUaHJvdyBhd2F5IHlvdXIgYWN0aW9uIGhhbmRsZXJzIHdoZW4gZm9yY2VTdG9wKCkgaXMgY2FsbGVkXG4gICAgICAgIC0gQ2hlY2sgYWN0aW9ucy5pc0FjdGl2ZSgpIGlmIHlvdSByZWFsbHkgbmVlZCB0b1xuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXhwZWN0ZWQgIT09IHBoYXNlKSB7XG4gICAgaWYgKHNob3VsZFdhcm4pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgICBDYW5ub3QgcGVyZm9ybSBhY3Rpb24uXG4gICAgICAgIFRoZSBhY3Rpb25zIHlvdSB1c2VkIGJlbG9uZyB0byBhbiBvdXRkYXRlZCBwaGFzZVxuXG4gICAgICAgIEN1cnJlbnQgcGhhc2U6ICR7ZXhwZWN0ZWR9XG4gICAgICAgIFlvdSBjYWxsZWQgYW4gYWN0aW9uIGZyb20gb3V0ZGF0ZWQgcGhhc2U6ICR7cGhhc2V9XG5cbiAgICAgICAgVGlwczpcblxuICAgICAgICAtIERvIG5vdCB1c2UgcHJlRHJhZ0FjdGlvbnMgYWN0aW9ucyBhZnRlciBjYWxsaW5nIHByZURyYWdBY3Rpb25zLmxpZnQoKVxuICAgICAgYCkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0KHtcbiAgbG9ja0FQSSxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZFxufSkge1xuICBpZiAobG9ja0FQSS5pc0NsYWltZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbnRyeSA9IHJlZ2lzdHJ5LmRyYWdnYWJsZS5maW5kQnlJZChkcmFnZ2FibGVJZCk7XG4gIGlmICghZW50cnkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBVbmFibGUgdG8gZmluZCBkcmFnZ2FibGUgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbnRyeS5vcHRpb25zLmlzRW5hYmxlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWNhblN0YXJ0RHJhZyhzdG9yZS5nZXRTdGF0ZSgpLCBkcmFnZ2FibGVJZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0cnlTdGFydCh7XG4gIGxvY2tBUEksXG4gIGNvbnRleHRJZCxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBkcmFnZ2FibGVJZCxcbiAgZm9yY2VTZW5zb3JTdG9wLFxuICBzb3VyY2VFdmVudFxufSkge1xuICBjb25zdCBzaG91bGRTdGFydCA9IGNhblN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHN0b3JlLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGRyYWdnYWJsZUlkXG4gIH0pO1xuICBpZiAoIXNob3VsZFN0YXJ0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZ2V0QnlJZChkcmFnZ2FibGVJZCk7XG4gIGNvbnN0IGVsID0gZmluZERyYWdnYWJsZShjb250ZXh0SWQsIGVudHJ5LmRlc2NyaXB0b3IuaWQpO1xuICBpZiAoIWVsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgVW5hYmxlIHRvIGZpbmQgZHJhZ2dhYmxlIGVsZW1lbnQgd2l0aCBpZDogJHtkcmFnZ2FibGVJZH1gKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc291cmNlRXZlbnQgJiYgIWVudHJ5Lm9wdGlvbnMuY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMgJiYgaXNFdmVudEluSW50ZXJhY3RpdmVFbGVtZW50KGVsLCBzb3VyY2VFdmVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb2NrID0gbG9ja0FQSS5jbGFpbShmb3JjZVNlbnNvclN0b3AgfHwgbm9vcCQyKTtcbiAgbGV0IHBoYXNlID0gJ1BSRV9EUkFHJztcbiAgZnVuY3Rpb24gZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MoKSB7XG4gICAgcmV0dXJuIGVudHJ5Lm9wdGlvbnMuc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M7XG4gIH1cbiAgZnVuY3Rpb24gaXNMb2NrQWN0aXZlKCkge1xuICAgIHJldHVybiBsb2NrQVBJLmlzQWN0aXZlKGxvY2spO1xuICB9XG4gIGZ1bmN0aW9uIHRyeURpc3BhdGNoKGV4cGVjdGVkLCBnZXRBY3Rpb24pIHtcbiAgICBpZiAoaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RvcmUuZGlzcGF0Y2goZ2V0QWN0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyA9IHRyeURpc3BhdGNoLmJpbmQobnVsbCwgJ0RSQUdHSU5HJyk7XG4gIGZ1bmN0aW9uIGxpZnQoYXJncykge1xuICAgIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIGxvY2tBUEkucmVsZWFzZSgpO1xuICAgICAgcGhhc2UgPSAnQ09NUExFVEVEJztcbiAgICB9XG4gICAgaWYgKHBoYXNlICE9PSAnUFJFX0RSQUcnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYENhbm5vdCBsaWZ0IGluIHBoYXNlICR7cGhhc2V9YCkgOiBpbnZhcmlhbnQoKSA7XG4gICAgfVxuICAgIHN0b3JlLmRpc3BhdGNoKGxpZnQkMShhcmdzLmxpZnRBY3Rpb25BcmdzKSk7XG4gICAgcGhhc2UgPSAnRFJBR0dJTkcnO1xuICAgIGZ1bmN0aW9uIGZpbmlzaChyZWFzb24sIG9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRCbG9ja05leHRDbGljazogZmFsc2VcbiAgICB9KSB7XG4gICAgICBhcmdzLmNsZWFudXAoKTtcbiAgICAgIGlmIChvcHRpb25zLnNob3VsZEJsb2NrTmV4dENsaWNrKSB7XG4gICAgICAgIGNvbnN0IHVuYmluZCA9IGJpbmRFdmVudHMod2luZG93LCBbe1xuICAgICAgICAgIGV2ZW50TmFtZTogJ2NsaWNrJyxcbiAgICAgICAgICBmbjogcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfV0pO1xuICAgICAgICBzZXRUaW1lb3V0KHVuYmluZCk7XG4gICAgICB9XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGRyb3Aoe1xuICAgICAgICByZWFzb25cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiAoKSA9PiBpc0FjdGl2ZSh7XG4gICAgICAgIGV4cGVjdGVkOiAnRFJBR0dJTkcnLFxuICAgICAgICBwaGFzZSxcbiAgICAgICAgaXNMb2NrQWN0aXZlLFxuICAgICAgICBzaG91bGRXYXJuOiBmYWxzZVxuICAgICAgfSksXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzczogZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgICBkcm9wOiBvcHRpb25zID0+IGZpbmlzaCgnRFJPUCcsIG9wdGlvbnMpLFxuICAgICAgY2FuY2VsOiBvcHRpb25zID0+IGZpbmlzaCgnQ0FOQ0VMJywgb3B0aW9ucyksXG4gICAgICAuLi5hcmdzLmFjdGlvbnNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZsdWlkTGlmdChjbGllbnRTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBtb3ZlJDEgPSByYWZTY2hkKGNsaWVudCA9PiB7XG4gICAgICB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZygoKSA9PiBtb3ZlKHtcbiAgICAgICAgY2xpZW50XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXBpID0gbGlmdCh7XG4gICAgICBsaWZ0QWN0aW9uQXJnczoge1xuICAgICAgICBpZDogZHJhZ2dhYmxlSWQsXG4gICAgICAgIGNsaWVudFNlbGVjdGlvbixcbiAgICAgICAgbW92ZW1lbnRNb2RlOiAnRkxVSUQnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogKCkgPT4gbW92ZSQxLmNhbmNlbCgpLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBtb3ZlOiBtb3ZlJDFcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYXBpLFxuICAgICAgbW92ZTogbW92ZSQxXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzbmFwTGlmdCgpIHtcbiAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgbW92ZVVwOiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlVXApLFxuICAgICAgbW92ZVJpZ2h0OiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlUmlnaHQpLFxuICAgICAgbW92ZURvd246ICgpID0+IHRyeURpc3BhdGNoV2hlbkRyYWdnaW5nKG1vdmVEb3duKSxcbiAgICAgIG1vdmVMZWZ0OiAoKSA9PiB0cnlEaXNwYXRjaFdoZW5EcmFnZ2luZyhtb3ZlTGVmdClcbiAgICB9O1xuICAgIHJldHVybiBsaWZ0KHtcbiAgICAgIGxpZnRBY3Rpb25BcmdzOiB7XG4gICAgICAgIGlkOiBkcmFnZ2FibGVJZCxcbiAgICAgICAgY2xpZW50U2VsZWN0aW9uOiBnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbihlbCksXG4gICAgICAgIG1vdmVtZW50TW9kZTogJ1NOQVAnXG4gICAgICB9LFxuICAgICAgY2xlYW51cDogbm9vcCQyLFxuICAgICAgYWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0UHJlRHJhZygpIHtcbiAgICBjb25zdCBzaG91bGRSZWxlYXNlID0gaXNBY3RpdmUoe1xuICAgICAgZXhwZWN0ZWQ6ICdQUkVfRFJBRycsXG4gICAgICBwaGFzZSxcbiAgICAgIGlzTG9ja0FjdGl2ZSxcbiAgICAgIHNob3VsZFdhcm46IHRydWVcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkUmVsZWFzZSkge1xuICAgICAgbG9ja0FQSS5yZWxlYXNlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHByZURyYWcgPSB7XG4gICAgaXNBY3RpdmU6ICgpID0+IGlzQWN0aXZlKHtcbiAgICAgIGV4cGVjdGVkOiAnUFJFX0RSQUcnLFxuICAgICAgcGhhc2UsXG4gICAgICBpc0xvY2tBY3RpdmUsXG4gICAgICBzaG91bGRXYXJuOiBmYWxzZVxuICAgIH0pLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBnZXRTaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBmbHVpZExpZnQsXG4gICAgc25hcExpZnQsXG4gICAgYWJvcnQ6IGFib3J0UHJlRHJhZ1xuICB9O1xuICByZXR1cm4gcHJlRHJhZztcbn1cbmNvbnN0IGRlZmF1bHRTZW5zb3JzID0gW3VzZU1vdXNlU2Vuc29yLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlVG91Y2hTZW5zb3JdO1xuZnVuY3Rpb24gdXNlU2Vuc29yTWFyc2hhbCh7XG4gIGNvbnRleHRJZCxcbiAgc3RvcmUsXG4gIHJlZ2lzdHJ5LFxuICBjdXN0b21TZW5zb3JzLFxuICBlbmFibGVEZWZhdWx0U2Vuc29yc1xufSkge1xuICBjb25zdCB1c2VTZW5zb3JzID0gWy4uLihlbmFibGVEZWZhdWx0U2Vuc29ycyA/IGRlZmF1bHRTZW5zb3JzIDogW10pLCAuLi4oY3VzdG9tU2Vuc29ycyB8fCBbXSldO1xuICBjb25zdCBsb2NrQVBJID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlKCkpWzBdO1xuICBjb25zdCB0cnlBYmFuZG9uTG9jayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHRyeUFiYW5kb25Mb2NrKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcocHJldmlvdXMpICYmICFpc0RyYWdnaW5nKGN1cnJlbnQpKSB7XG4gICAgICBsb2NrQVBJLnRyeUFiYW5kb24oKTtcbiAgICB9XG4gIH0sIFtsb2NrQVBJXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gbGlzdGVuVG9TdG9yZSgpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgdHJ5QWJhbmRvbkxvY2socHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2xvY2tBUEksIHN0b3JlLCB0cnlBYmFuZG9uTG9ja10pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbG9ja0FQSS50cnlBYmFuZG9uO1xuICB9LCBbbG9ja0FQSS50cnlBYmFuZG9uXSk7XG4gIGNvbnN0IGNhbkdldExvY2sgPSB1c2VDYWxsYmFjayhkcmFnZ2FibGVJZCA9PiB7XG4gICAgcmV0dXJuIGNhblN0YXJ0KHtcbiAgICAgIGxvY2tBUEksXG4gICAgICByZWdpc3RyeSxcbiAgICAgIHN0b3JlLFxuICAgICAgZHJhZ2dhYmxlSWRcbiAgICB9KTtcbiAgfSwgW2xvY2tBUEksIHJlZ2lzdHJ5LCBzdG9yZV0pO1xuICBjb25zdCB0cnlHZXRMb2NrID0gdXNlQ2FsbGJhY2soKGRyYWdnYWJsZUlkLCBmb3JjZVN0b3AsIG9wdGlvbnMpID0+IHRyeVN0YXJ0KHtcbiAgICBsb2NrQVBJLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICBkcmFnZ2FibGVJZCxcbiAgICBmb3JjZVNlbnNvclN0b3A6IGZvcmNlU3RvcCB8fCBudWxsLFxuICAgIHNvdXJjZUV2ZW50OiBvcHRpb25zICYmIG9wdGlvbnMuc291cmNlRXZlbnQgPyBvcHRpb25zLnNvdXJjZUV2ZW50IDogbnVsbFxuICB9KSwgW2NvbnRleHRJZCwgbG9ja0FQSSwgcmVnaXN0cnksIHN0b3JlXSk7XG4gIGNvbnN0IGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQgPSB1c2VDYWxsYmFjayhldmVudCA9PiB0cnlHZXRDbG9zZXN0RHJhZ2dhYmxlSWRGcm9tRXZlbnQoY29udGV4dElkLCBldmVudCksIFtjb250ZXh0SWRdKTtcbiAgY29uc3QgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUgPSB1c2VDYWxsYmFjayhpZCA9PiB7XG4gICAgY29uc3QgZW50cnkgPSByZWdpc3RyeS5kcmFnZ2FibGUuZmluZEJ5SWQoaWQpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5Lm9wdGlvbnMgOiBudWxsO1xuICB9LCBbcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG4gIGNvbnN0IHRyeVJlbGVhc2VMb2NrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdHJ5UmVsZWFzZUxvY2soKSB7XG4gICAgaWYgKCFsb2NrQVBJLmlzQ2xhaW1lZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvY2tBUEkudHJ5QWJhbmRvbigpO1xuICAgIGlmIChzdG9yZS5nZXRTdGF0ZSgpLnBoYXNlICE9PSAnSURMRScpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZsdXNoKCkpO1xuICAgIH1cbiAgfSwgW2xvY2tBUEksIHN0b3JlXSk7XG4gIGNvbnN0IGlzTG9ja0NsYWltZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBsb2NrQVBJLmlzQ2xhaW1lZCgpLCBbbG9ja0FQSV0pO1xuICBjb25zdCBhcGkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuR2V0TG9jayxcbiAgICB0cnlHZXRMb2NrLFxuICAgIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsXG4gICAgZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUsXG4gICAgdHJ5UmVsZWFzZUxvY2ssXG4gICAgaXNMb2NrQ2xhaW1lZFxuICB9KSwgW2NhbkdldExvY2ssIHRyeUdldExvY2ssIGZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQsIGZpbmRPcHRpb25zRm9yRHJhZ2dhYmxlLCB0cnlSZWxlYXNlTG9jaywgaXNMb2NrQ2xhaW1lZF0pO1xuICB1c2VWYWxpZGF0ZVNlbnNvckhvb2tzKHVzZVNlbnNvcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHVzZVNlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB1c2VTZW5zb3JzW2ldKGFwaSk7XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUmVzcG9uZGVycyA9IHByb3BzID0+ICh7XG4gIG9uQmVmb3JlQ2FwdHVyZTogdCA9PiB7XG4gICAgY29uc3Qgb25CZWZvcmVDYXB1cmVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmIChwcm9wcy5vbkJlZm9yZUNhcHR1cmUpIHtcbiAgICAgICAgcHJvcHMub25CZWZvcmVDYXB0dXJlKHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZmx1c2hTeW5jKG9uQmVmb3JlQ2FwdXJlQ2FsbGJhY2spO1xuICB9LFxuICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gIG9uRHJhZ1N0YXJ0OiBwcm9wcy5vbkRyYWdTdGFydCxcbiAgb25EcmFnRW5kOiBwcm9wcy5vbkRyYWdFbmQsXG4gIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlXG59KTtcbmNvbnN0IGNyZWF0ZUF1dG9TY3JvbGxlck9wdGlvbnMgPSBwcm9wcyA9PiAoe1xuICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgLi4ucHJvcHMuYXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgZHVyYXRpb25EYW1wZW5pbmc6IHtcbiAgICAuLi5kZWZhdWx0QXV0b1Njcm9sbGVyT3B0aW9ucy5kdXJhdGlvbkRhbXBlbmluZyxcbiAgICAuLi5wcm9wcy5hdXRvU2Nyb2xsZXJPcHRpb25zXG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0U3RvcmUobGF6eVJlZikge1xuICAhbGF6eVJlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ291bGQgbm90IGZpbmQgc3RvcmUgZnJvbSBsYXp5IHJlZicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBsYXp5UmVmLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBBcHAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3MsXG4gICAgc2Vuc29ycyxcbiAgICBub25jZSxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXp5U3RvcmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHVzZVN0YXJ0dXBWYWxpZGF0aW9uKCk7XG4gIGNvbnN0IGxhc3RQcm9wc1JlZiA9IHVzZVByZXZpb3VzKHByb3BzKTtcbiAgY29uc3QgZ2V0UmVzcG9uZGVycyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUmVzcG9uZGVycyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlQXV0b1Njcm9sbGVyT3B0aW9ucyhsYXN0UHJvcHNSZWYuY3VycmVudCk7XG4gIH0sIFtsYXN0UHJvcHNSZWZdKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VBbm5vdW5jZXIoY29udGV4dElkKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQgPSB1c2VIaWRkZW5UZXh0RWxlbWVudCh7XG4gICAgY29udGV4dElkLFxuICAgIHRleHQ6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc1xuICB9KTtcbiAgY29uc3Qgc3R5bGVNYXJzaGFsID0gdXNlU3R5bGVNYXJzaGFsKGNvbnRleHRJZCwgbm9uY2UpO1xuICBjb25zdCBsYXp5RGlzcGF0Y2ggPSB1c2VDYWxsYmFjayhhY3Rpb24gPT4ge1xuICAgIGdldFN0b3JlKGxhenlTdG9yZVJlZikuZGlzcGF0Y2goYWN0aW9uKTtcbiAgfSwgW10pO1xuICBjb25zdCBtYXJzaGFsQ2FsbGJhY2tzID0gdXNlTWVtbygoKSA9PiBiaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgIHB1Ymxpc2hXaGlsZURyYWdnaW5nLFxuICAgIHVwZGF0ZURyb3BwYWJsZVNjcm9sbCxcbiAgICB1cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQsXG4gICAgdXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZCxcbiAgICBjb2xsZWN0aW9uU3RhcnRpbmdcbiAgfSwgbGF6eURpc3BhdGNoKSwgW2xhenlEaXNwYXRjaF0pO1xuICBjb25zdCByZWdpc3RyeSA9IHVzZVJlZ2lzdHJ5KCk7XG4gIGNvbnN0IGRpbWVuc2lvbk1hcnNoYWwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRGltZW5zaW9uTWFyc2hhbChyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrcyk7XG4gIH0sIFtyZWdpc3RyeSwgbWFyc2hhbENhbGxiYWNrc10pO1xuICBjb25zdCBhdXRvU2Nyb2xsZXIgPSB1c2VNZW1vKCgpID0+IGNyZWF0ZUF1dG9TY3JvbGxlcih7XG4gICAgc2Nyb2xsV2luZG93LFxuICAgIHNjcm9sbERyb3BwYWJsZTogZGltZW5zaW9uTWFyc2hhbC5zY3JvbGxEcm9wcGFibGUsXG4gICAgZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucyxcbiAgICAuLi5iaW5kQWN0aW9uQ3JlYXRvcnMoe1xuICAgICAgbW92ZVxuICAgIH0sIGxhenlEaXNwYXRjaClcbiAgfSksIFtkaW1lbnNpb25NYXJzaGFsLnNjcm9sbERyb3BwYWJsZSwgbGF6eURpc3BhdGNoLCBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zXSk7XG4gIGNvbnN0IGZvY3VzTWFyc2hhbCA9IHVzZUZvY3VzTWFyc2hhbChjb250ZXh0SWQpO1xuICBjb25zdCBzdG9yZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlU3RvcmUoe1xuICAgIGFubm91bmNlLFxuICAgIGF1dG9TY3JvbGxlcixcbiAgICBkaW1lbnNpb25NYXJzaGFsLFxuICAgIGZvY3VzTWFyc2hhbCxcbiAgICBnZXRSZXNwb25kZXJzLFxuICAgIHN0eWxlTWFyc2hhbFxuICB9KSwgW2Fubm91bmNlLCBhdXRvU2Nyb2xsZXIsIGRpbWVuc2lvbk1hcnNoYWwsIGZvY3VzTWFyc2hhbCwgZ2V0UmVzcG9uZGVycywgc3R5bGVNYXJzaGFsXSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGxhenlTdG9yZVJlZi5jdXJyZW50ICYmIGxhenlTdG9yZVJlZi5jdXJyZW50ICE9PSBzdG9yZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZygndW5leHBlY3RlZCBzdG9yZSBjaGFuZ2UnKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgbGF6eVN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZTtcbiAgY29uc3QgdHJ5UmVzZXRTdG9yZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50ID0gZ2V0U3RvcmUobGF6eVN0b3JlUmVmKTtcbiAgICBjb25zdCBzdGF0ZSA9IGN1cnJlbnQuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgIT09ICdJRExFJykge1xuICAgICAgY3VycmVudC5kaXNwYXRjaChmbHVzaCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgaXNEcmFnZ2luZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0b3JlKGxhenlTdG9yZVJlZikuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuaXNEcmFnZ2luZztcbiAgfSwgW10pO1xuICBjb25zdCBhcHBDYWxsYmFja3MgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaXNEcmFnZ2luZyxcbiAgICB0cnlBYm9ydDogdHJ5UmVzZXRTdG9yZVxuICB9KSwgW2lzRHJhZ2dpbmcsIHRyeVJlc2V0U3RvcmVdKTtcbiAgc2V0Q2FsbGJhY2tzKGFwcENhbGxiYWNrcyk7XG4gIGNvbnN0IGdldENhbkxpZnQgPSB1c2VDYWxsYmFjayhpZCA9PiBjYW5TdGFydERyYWcoZ2V0U3RvcmUobGF6eVN0b3JlUmVmKS5nZXRTdGF0ZSgpLCBpZCksIFtdKTtcbiAgY29uc3QgZ2V0SXNNb3ZlbWVudEFsbG93ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiBpc01vdmVtZW50QWxsb3dlZChnZXRTdG9yZShsYXp5U3RvcmVSZWYpLmdldFN0YXRlKCkpLCBbXSk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgbWFyc2hhbDogZGltZW5zaW9uTWFyc2hhbCxcbiAgICBmb2N1czogZm9jdXNNYXJzaGFsLFxuICAgIGNvbnRleHRJZCxcbiAgICBjYW5MaWZ0OiBnZXRDYW5MaWZ0LFxuICAgIGlzTW92ZW1lbnRBbGxvd2VkOiBnZXRJc01vdmVtZW50QWxsb3dlZCxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnNJZCxcbiAgICByZWdpc3RyeVxuICB9KSwgW2NvbnRleHRJZCwgZGltZW5zaW9uTWFyc2hhbCwgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQsIGZvY3VzTWFyc2hhbCwgZ2V0Q2FuTGlmdCwgZ2V0SXNNb3ZlbWVudEFsbG93ZWQsIHJlZ2lzdHJ5XSk7XG4gIHVzZVNlbnNvck1hcnNoYWwoe1xuICAgIGNvbnRleHRJZCxcbiAgICBzdG9yZSxcbiAgICByZWdpc3RyeSxcbiAgICBjdXN0b21TZW5zb3JzOiBzZW5zb3JzIHx8IG51bGwsXG4gICAgZW5hYmxlRGVmYXVsdFNlbnNvcnM6IHByb3BzLmVuYWJsZURlZmF1bHRTZW5zb3JzICE9PSBmYWxzZVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdHJ5UmVzZXRTdG9yZTtcbiAgfSwgW3RyeVJlc2V0U3RvcmVdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcHBDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gICAgc3RvcmU6IHN0b3JlXG4gIH0sIHByb3BzLmNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIHVzZVVuaXF1ZUNvbnRleHRJZCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUlkKCk7XG59XG5cbmZ1bmN0aW9uIERyYWdEcm9wQ29udGV4dChwcm9wcykge1xuICBjb25zdCBjb250ZXh0SWQgPSB1c2VVbmlxdWVDb250ZXh0SWQoKTtcbiAgY29uc3QgZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zID0gcHJvcHMuZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIHx8IHByZXNldC5kcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwsIHNldENhbGxiYWNrcyA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KEFwcCwge1xuICAgIG5vbmNlOiBwcm9wcy5ub25jZSxcbiAgICBjb250ZXh0SWQ6IGNvbnRleHRJZCxcbiAgICBzZXRDYWxsYmFja3M6IHNldENhbGxiYWNrcyxcbiAgICBkcmFnSGFuZGxlVXNhZ2VJbnN0cnVjdGlvbnM6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9ucyxcbiAgICBlbmFibGVEZWZhdWx0U2Vuc29yczogcHJvcHMuZW5hYmxlRGVmYXVsdFNlbnNvcnMsXG4gICAgc2Vuc29yczogcHJvcHMuc2Vuc29ycyxcbiAgICBvbkJlZm9yZUNhcHR1cmU6IHByb3BzLm9uQmVmb3JlQ2FwdHVyZSxcbiAgICBvbkJlZm9yZURyYWdTdGFydDogcHJvcHMub25CZWZvcmVEcmFnU3RhcnQsXG4gICAgb25EcmFnU3RhcnQ6IHByb3BzLm9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZ1VwZGF0ZTogcHJvcHMub25EcmFnVXBkYXRlLFxuICAgIG9uRHJhZ0VuZDogcHJvcHMub25EcmFnRW5kLFxuICAgIGF1dG9TY3JvbGxlck9wdGlvbnM6IHByb3BzLmF1dG9TY3JvbGxlck9wdGlvbnNcbiAgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn1cblxuY29uc3QgekluZGV4T3B0aW9ucyA9IHtcbiAgZHJhZ2dpbmc6IDUwMDAsXG4gIGRyb3BBbmltYXRpbmc6IDQ1MDBcbn07XG5jb25zdCBnZXREcmFnZ2luZ1RyYW5zaXRpb24gPSAoc2hvdWxkQW5pbWF0ZURyYWdNb3ZlbWVudCwgZHJvcHBpbmcpID0+IHtcbiAgaWYgKGRyb3BwaW5nKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLmRyb3AoZHJvcHBpbmcuZHVyYXRpb24pO1xuICB9XG4gIGlmIChzaG91bGRBbmltYXRlRHJhZ01vdmVtZW50KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25zLnNuYXA7XG4gIH1cbiAgcmV0dXJuIHRyYW5zaXRpb25zLmZsdWlkO1xufTtcbmNvbnN0IGdldERyYWdnaW5nT3BhY2l0eSA9IChpc0NvbWJpbmluZywgaXNEcm9wQW5pbWF0aW5nKSA9PiB7XG4gIGlmICghaXNDb21iaW5pbmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBpc0Ryb3BBbmltYXRpbmcgPyBjb21iaW5lLm9wYWNpdHkuZHJvcCA6IGNvbWJpbmUub3BhY2l0eS5jb21iaW5pbmc7XG59O1xuY29uc3QgZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlID0gZHJhZ2dpbmcgPT4ge1xuICBpZiAoZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlICE9IG51bGwpIHtcbiAgICByZXR1cm4gZHJhZ2dpbmcuZm9yY2VTaG91bGRBbmltYXRlO1xuICB9XG4gIHJldHVybiBkcmFnZ2luZy5tb2RlID09PSAnU05BUCc7XG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dpbmdTdHlsZShkcmFnZ2luZykge1xuICBjb25zdCBkaW1lbnNpb24gPSBkcmFnZ2luZy5kaW1lbnNpb247XG4gIGNvbnN0IGJveCA9IGRpbWVuc2lvbi5jbGllbnQ7XG4gIGNvbnN0IHtcbiAgICBvZmZzZXQsXG4gICAgY29tYmluZVdpdGgsXG4gICAgZHJvcHBpbmdcbiAgfSA9IGRyYWdnaW5nO1xuICBjb25zdCBpc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tYmluZVdpdGgpO1xuICBjb25zdCBzaG91bGRBbmltYXRlID0gZ2V0U2hvdWxkRHJhZ2dpbmdBbmltYXRlKGRyYWdnaW5nKTtcbiAgY29uc3QgaXNEcm9wQW5pbWF0aW5nID0gQm9vbGVhbihkcm9wcGluZyk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGlzRHJvcEFuaW1hdGluZyA/IHRyYW5zZm9ybXMuZHJvcChvZmZzZXQsIGlzQ29tYmluaW5nKSA6IHRyYW5zZm9ybXMubW92ZVRvKG9mZnNldCk7XG4gIGNvbnN0IHN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHRvcDogYm94Lm1hcmdpbkJveC50b3AsXG4gICAgbGVmdDogYm94Lm1hcmdpbkJveC5sZWZ0LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBib3guYm9yZGVyQm94LndpZHRoLFxuICAgIGhlaWdodDogYm94LmJvcmRlckJveC5oZWlnaHQsXG4gICAgdHJhbnNpdGlvbjogZ2V0RHJhZ2dpbmdUcmFuc2l0aW9uKHNob3VsZEFuaW1hdGUsIGRyb3BwaW5nKSxcbiAgICB0cmFuc2Zvcm0sXG4gICAgb3BhY2l0eTogZ2V0RHJhZ2dpbmdPcGFjaXR5KGlzQ29tYmluaW5nLCBpc0Ryb3BBbmltYXRpbmcpLFxuICAgIHpJbmRleDogaXNEcm9wQW5pbWF0aW5nID8gekluZGV4T3B0aW9ucy5kcm9wQW5pbWF0aW5nIDogekluZGV4T3B0aW9ucy5kcmFnZ2luZyxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbiAgfTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U3R5bGUoc2Vjb25kYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zLm1vdmVUbyhzZWNvbmRhcnkub2Zmc2V0KSxcbiAgICB0cmFuc2l0aW9uOiBzZWNvbmRhcnkuc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCA/IHVuZGVmaW5lZCA6ICdub25lJ1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUkMShtYXBwZWQpIHtcbiAgcmV0dXJuIG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnID8gZ2V0RHJhZ2dpbmdTdHlsZShtYXBwZWQpIDogZ2V0U2Vjb25kYXJ5U3R5bGUobWFwcGVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9uJDEoZGVzY3JpcHRvciwgZWwsIHdpbmRvd1Njcm9sbCA9IG9yaWdpbikge1xuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNsaWVudCA9IGNhbGN1bGF0ZUJveChib3JkZXJCb3gsIGNvbXB1dGVkU3R5bGVzKTtcbiAgY29uc3QgcGFnZSA9IHdpdGhTY3JvbGwoY2xpZW50LCB3aW5kb3dTY3JvbGwpO1xuICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICBjbGllbnQsXG4gICAgdGFnTmFtZTogZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgIGRpc3BsYXk6IGNvbXB1dGVkU3R5bGVzLmRpc3BsYXlcbiAgfTtcbiAgY29uc3QgZGlzcGxhY2VCeSA9IHtcbiAgICB4OiBjbGllbnQubWFyZ2luQm94LndpZHRoLFxuICAgIHk6IGNsaWVudC5tYXJnaW5Cb3guaGVpZ2h0XG4gIH07XG4gIGNvbnN0IGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRpc3BsYWNlQnksXG4gICAgY2xpZW50LFxuICAgIHBhZ2VcbiAgfTtcbiAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ2dhYmxlUHVibGlzaGVyKGFyZ3MpIHtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VVbmlxdWVJZCgnZHJhZ2dhYmxlJyk7XG4gIGNvbnN0IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIHJlZ2lzdHJ5LFxuICAgIGdldERyYWdnYWJsZVJlZixcbiAgICBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyxcbiAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICBpc0VuYWJsZWRcbiAgfSA9IGFyZ3M7XG4gIGNvbnN0IG9wdGlvbnMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MsXG4gICAgaXNFbmFibGVkXG4gIH0pLCBbY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIGlzRW5hYmxlZCwgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3NdKTtcbiAgY29uc3QgZ2V0RGltZW5zaW9uID0gdXNlQ2FsbGJhY2sod2luZG93U2Nyb2xsID0+IHtcbiAgICBjb25zdCBlbCA9IGdldERyYWdnYWJsZVJlZigpO1xuICAgICFlbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBnZXQgZGltZW5zaW9uIHdoZW4gbm8gcmVmIGlzIHNldCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldERpbWVuc2lvbiQxKGRlc2NyaXB0b3IsIGVsLCB3aW5kb3dTY3JvbGwpO1xuICB9LCBbZGVzY3JpcHRvciwgZ2V0RHJhZ2dhYmxlUmVmXSk7XG4gIGNvbnN0IGVudHJ5ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHVuaXF1ZUlkLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgb3B0aW9ucyxcbiAgICBnZXREaW1lbnNpb25cbiAgfSksIFtkZXNjcmlwdG9yLCBnZXREaW1lbnNpb24sIG9wdGlvbnMsIHVuaXF1ZUlkXSk7XG4gIGNvbnN0IHB1Ymxpc2hlZFJlZiA9IHVzZVJlZihlbnRyeSk7XG4gIGNvbnN0IGlzRmlyc3RQdWJsaXNoUmVmID0gdXNlUmVmKHRydWUpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZWdpc3RyeS5kcmFnZ2FibGUucmVnaXN0ZXIocHVibGlzaGVkUmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiAoKSA9PiByZWdpc3RyeS5kcmFnZ2FibGUudW5yZWdpc3RlcihwdWJsaXNoZWRSZWYuY3VycmVudCk7XG4gIH0sIFtyZWdpc3RyeS5kcmFnZ2FibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQpIHtcbiAgICAgIGlzRmlyc3RQdWJsaXNoUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHB1Ymxpc2hlZFJlZi5jdXJyZW50O1xuICAgIHB1Ymxpc2hlZFJlZi5jdXJyZW50ID0gZW50cnk7XG4gICAgcmVnaXN0cnkuZHJhZ2dhYmxlLnVwZGF0ZShlbnRyeSwgbGFzdCk7XG4gIH0sIFtlbnRyeSwgcmVnaXN0cnkuZHJhZ2dhYmxlXSk7XG59XG5cbnZhciBEcm9wcGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gY2hlY2tJc1ZhbGlkSW5uZXJSZWYoZWwpIHtcbiAgIShlbCAmJiBpc0h0bWxFbGVtZW50KGVsKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBcbiAgICBwcm92aWRlZC5pbm5lclJlZiBoYXMgbm90IGJlZW4gcHJvdmlkZWQgd2l0aCBhIEhUTUxFbGVtZW50LlxuXG4gICAgWW91IGNhbiBmaW5kIGEgZ3VpZGUgb24gdXNpbmcgdGhlIGlubmVyUmVmIGNhbGxiYWNrIGZ1bmN0aW9ucyBhdDpcbiAgICBodHRwczovL2dpdGh1Yi5jb20vaGVsbG8tcGFuZ2VhL2RuZC9ibG9iL21haW4vZG9jcy9ndWlkZXMvdXNpbmctaW5uZXItcmVmLm1kXG4gIGApIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIHVzZVZhbGlkYXRpb24kMShwcm9wcywgY29udGV4dElkLCBnZXRSZWYpIHtcbiAgdXNlRGV2U2V0dXBXYXJuaW5nKCgpID0+IHtcbiAgICBmdW5jdGlvbiBwcmVmaXgoaWQpIHtcbiAgICAgIHJldHVybiBgRHJhZ2dhYmxlW2lkOiAke2lkfV06IGA7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcHJvcHMuZHJhZ2dhYmxlSWQ7XG4gICAgIWlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIHJlcXVpcmVzIGEgZHJhZ2dhYmxlSWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYERyYWdnYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyYWdnYWJsZUlkLlxuICAgICAgUHJvdmlkZWQ6IFt0eXBlOiAke3R5cGVvZiBpZH1dICh2YWx1ZTogJHtpZH0pYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICFOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgYCR7cHJlZml4KGlkKX0gcmVxdWlyZXMgYW4gaW50ZWdlciBpbmRleCBwcm9wYCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGlmIChwcm9wcy5tYXBwZWQudHlwZSA9PT0gJ0RSQUdHSU5HJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjaGVja0lzVmFsaWRJbm5lclJlZihnZXRSZWYoKSk7XG4gICAgaWYgKHByb3BzLmlzRW5hYmxlZCkge1xuICAgICAgIWZpbmREcmFnSGFuZGxlKGNvbnRleHRJZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBgJHtwcmVmaXgoaWQpfSBVbmFibGUgdG8gZmluZCBkcmFnIGhhbmRsZWApIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlQ2xvbmVQcm9wVmFsaWRhdGlvbihpc0Nsb25lKSB7XG4gIHVzZURldigoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZVJlZihpc0Nsb25lKTtcbiAgICB1c2VEZXZTZXR1cFdhcm5pbmcoKCkgPT4ge1xuICAgICAgIShpc0Nsb25lID09PSBpbml0aWFsUmVmLmN1cnJlbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnRHJhZ2dhYmxlIGlzQ2xvbmUgcHJvcCB2YWx1ZSBjaGFuZ2VkIGR1cmluZyBjb21wb25lbnQgbGlmZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB9LCBbaXNDbG9uZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlUmVxdWlyZWRDb250ZXh0KENvbnRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gdXNlQ29udGV4dChDb250ZXh0KTtcbiAgIXJlc3VsdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0NvdWxkIG5vdCBmaW5kIHJlcXVpcmVkIGNvbnRleHQnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50SHRtbDVEbmQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmNvbnN0IERyYWdnYWJsZSA9IHByb3BzID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRSZWYgPSB1c2VDYWxsYmFjaygoZWwgPSBudWxsKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBlbDtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICBjb25zdCB7XG4gICAgY29udGV4dElkLFxuICAgIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgIHJlZ2lzdHJ5XG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0gPSB1c2VSZXF1aXJlZENvbnRleHQoRHJvcHBhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgaWQ6IHByb3BzLmRyYWdnYWJsZUlkLFxuICAgIGluZGV4OiBwcm9wcy5pbmRleCxcbiAgICB0eXBlLFxuICAgIGRyb3BwYWJsZUlkXG4gIH0pLCBbcHJvcHMuZHJhZ2dhYmxlSWQsIHByb3BzLmluZGV4LCB0eXBlLCBkcm9wcGFibGVJZF0pO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZHJhZ2dhYmxlSWQsXG4gICAgaXNFbmFibGVkLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLFxuICAgIGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIGlzQ2xvbmUsXG4gICAgbWFwcGVkLFxuICAgIGRyb3BBbmltYXRpb25GaW5pc2hlZDogZHJvcEFuaW1hdGlvbkZpbmlzaGVkQWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdXNlVmFsaWRhdGlvbiQxKHByb3BzLCBjb250ZXh0SWQsIGdldFJlZik7XG4gIHVzZUNsb25lUHJvcFZhbGlkYXRpb24oaXNDbG9uZSk7XG4gIGlmICghaXNDbG9uZSkge1xuICAgIGNvbnN0IGZvclB1Ymxpc2hlciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICByZWdpc3RyeSxcbiAgICAgIGdldERyYWdnYWJsZVJlZjogZ2V0UmVmLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsXG4gICAgICBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyxcbiAgICAgIGlzRW5hYmxlZFxuICAgIH0pLCBbZGVzY3JpcHRvciwgcmVnaXN0cnksIGdldFJlZiwgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHMsIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzLCBpc0VuYWJsZWRdKTtcbiAgICB1c2VEcmFnZ2FibGVQdWJsaXNoZXIoZm9yUHVibGlzaGVyKTtcbiAgfVxuICBjb25zdCBkcmFnSGFuZGxlUHJvcHMgPSB1c2VNZW1vKCgpID0+IGlzRW5hYmxlZCA/IHtcbiAgICB0YWJJbmRleDogMCxcbiAgICByb2xlOiAnYnV0dG9uJyxcbiAgICAnYXJpYS1kZXNjcmliZWRieSc6IGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLFxuICAgICdkYXRhLXJmZC1kcmFnLWhhbmRsZS1kcmFnZ2FibGUtaWQnOiBkcmFnZ2FibGVJZCxcbiAgICAnZGF0YS1yZmQtZHJhZy1oYW5kbGUtY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgIG9uRHJhZ1N0YXJ0OiBwcmV2ZW50SHRtbDVEbmRcbiAgfSA6IG51bGwsIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVVc2FnZUluc3RydWN0aW9uc0lkLCBkcmFnZ2FibGVJZCwgaXNFbmFibGVkXSk7XG4gIGNvbnN0IG9uTW92ZUVuZCA9IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAobWFwcGVkLnR5cGUgIT09ICdEUkFHR0lORycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFtYXBwZWQuZHJvcHBpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmx1c2hTeW5jKGRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbik7XG4gIH0sIFtkcm9wQW5pbWF0aW9uRmluaXNoZWRBY3Rpb24sIG1hcHBlZF0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUkMShtYXBwZWQpO1xuICAgIGNvbnN0IG9uVHJhbnNpdGlvbkVuZCA9IG1hcHBlZC50eXBlID09PSAnRFJBR0dJTkcnICYmIG1hcHBlZC5kcm9wcGluZyA/IG9uTW92ZUVuZCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBpbm5lclJlZjogc2V0UmVmLFxuICAgICAgZHJhZ2dhYmxlUHJvcHM6IHtcbiAgICAgICAgJ2RhdGEtcmZkLWRyYWdnYWJsZS1jb250ZXh0LWlkJzogY29udGV4dElkLFxuICAgICAgICAnZGF0YS1yZmQtZHJhZ2dhYmxlLWlkJzogZHJhZ2dhYmxlSWQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBvblRyYW5zaXRpb25FbmRcbiAgICAgIH0sXG4gICAgICBkcmFnSGFuZGxlUHJvcHNcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtjb250ZXh0SWQsIGRyYWdIYW5kbGVQcm9wcywgZHJhZ2dhYmxlSWQsIG1hcHBlZCwgb25Nb3ZlRW5kLCBzZXRSZWZdKTtcbiAgY29uc3QgcnVicmljID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGRyYWdnYWJsZUlkOiBkZXNjcmlwdG9yLmlkLFxuICAgIHR5cGU6IGRlc2NyaXB0b3IudHlwZSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIGluZGV4OiBkZXNjcmlwdG9yLmluZGV4LFxuICAgICAgZHJvcHBhYmxlSWQ6IGRlc2NyaXB0b3IuZHJvcHBhYmxlSWRcbiAgICB9XG4gIH0pLCBbZGVzY3JpcHRvci5kcm9wcGFibGVJZCwgZGVzY3JpcHRvci5pZCwgZGVzY3JpcHRvci5pbmRleCwgZGVzY3JpcHRvci50eXBlXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbihwcm92aWRlZCwgbWFwcGVkLnNuYXBzaG90LCBydWJyaWMpKTtcbn07XG5cbnZhciBpc1N0cmljdEVxdWFsID0gKGEsIGIpID0+IGEgPT09IGI7XG5cbnZhciB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQgPSByZXN1bHQgPT4ge1xuICBjb25zdCB7XG4gICAgY29tYmluZSxcbiAgICBkZXN0aW5hdGlvblxuICB9ID0gcmVzdWx0O1xuICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24uZHJvcHBhYmxlSWQ7XG4gIH1cbiAgaWYgKGNvbWJpbmUpIHtcbiAgICByZXR1cm4gY29tYmluZS5kcm9wcGFibGVJZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCA9IHJlc3VsdCA9PiB7XG4gIHJldHVybiByZXN1bHQuY29tYmluZSA/IHJlc3VsdC5jb21iaW5lLmRyYWdnYWJsZUlkIDogbnVsbDtcbn07XG5jb25zdCBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3QgPSBpbXBhY3QgPT4ge1xuICByZXR1cm4gaW1wYWN0LmF0ICYmIGltcGFjdC5hdC50eXBlID09PSAnQ09NQklORScgPyBpbXBhY3QuYXQuY29tYmluZS5kcmFnZ2FibGVJZCA6IG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0RHJhZ2dhYmxlU2VsZWN0b3IoKSB7XG4gIGNvbnN0IG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZSgoeCwgeSkgPT4gKHtcbiAgICB4LFxuICAgIHlcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gbWVtb2l6ZU9uZSgobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyID0gbnVsbCwgY29tYmluZVdpdGggPSBudWxsLCBkcm9wcGluZyA9IG51bGwpID0+ICh7XG4gICAgaXNEcmFnZ2luZzogdHJ1ZSxcbiAgICBpc0Nsb25lLFxuICAgIGlzRHJvcEFuaW1hdGluZzogQm9vbGVhbihkcm9wcGluZyksXG4gICAgZHJvcEFuaW1hdGlvbjogZHJvcHBpbmcsXG4gICAgbW9kZSxcbiAgICBkcmFnZ2luZ092ZXIsXG4gICAgY29tYmluZVdpdGgsXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbFxuICB9KSk7XG4gIGNvbnN0IGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKChvZmZzZXQsIG1vZGUsIGRpbWVuc2lvbiwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyID0gbnVsbCwgY29tYmluZVdpdGggPSBudWxsLCBmb3JjZVNob3VsZEFuaW1hdGUgPSBudWxsKSA9PiAoe1xuICAgIG1hcHBlZDoge1xuICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgIGRyb3BwaW5nOiBudWxsLFxuICAgICAgZHJhZ2dpbmdPdmVyLFxuICAgICAgY29tYmluZVdpdGgsXG4gICAgICBtb2RlLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZGltZW5zaW9uLFxuICAgICAgZm9yY2VTaG91bGRBbmltYXRlLFxuICAgICAgc25hcHNob3Q6IGdldE1lbW9pemVkU25hcHNob3QobW9kZSwgaXNDbG9uZSwgZHJhZ2dpbmdPdmVyLCBjb21iaW5lV2l0aCwgbnVsbClcbiAgICB9XG4gIH0pKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuY3JpdGljYWwuZHJhZ2dhYmxlLmlkICE9PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLmN1cnJlbnQuY2xpZW50Lm9mZnNldDtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHN0YXRlLmRpbWVuc2lvbnMuZHJhZ2dhYmxlc1tvd25Qcm9wcy5kcmFnZ2FibGVJZF07XG4gICAgICBjb25zdCBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpO1xuICAgICAgY29uc3QgY29tYmluZVdpdGggPSBnZXRDb21iaW5lV2l0aEZyb21JbXBhY3Qoc3RhdGUuaW1wYWN0KTtcbiAgICAgIGNvbnN0IGZvcmNlU2hvdWxkQW5pbWF0ZSA9IHN0YXRlLmZvcmNlU2hvdWxkQW5pbWF0ZTtcbiAgICAgIHJldHVybiBnZXRNZW1vaXplZFByb3BzKG1lbW9pemVkT2Zmc2V0KG9mZnNldC54LCBvZmZzZXQueSksIHN0YXRlLm1vdmVtZW50TW9kZSwgZGltZW5zaW9uLCBvd25Qcm9wcy5pc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBmb3JjZVNob3VsZEFuaW1hdGUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdEUk9QX0FOSU1BVElORycpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IHN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIGlmIChjb21wbGV0ZWQucmVzdWx0LmRyYWdnYWJsZUlkICE9PSBvd25Qcm9wcy5kcmFnZ2FibGVJZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2xvbmUgPSBvd25Qcm9wcy5pc0Nsb25lO1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gc3RhdGUuZGltZW5zaW9ucy5kcmFnZ2FibGVzW293blByb3BzLmRyYWdnYWJsZUlkXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRlZC5yZXN1bHQ7XG4gICAgICBjb25zdCBtb2RlID0gcmVzdWx0Lm1vZGU7XG4gICAgICBjb25zdCBkcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlckZyb21SZXN1bHQocmVzdWx0KTtcbiAgICAgIGNvbnN0IGNvbWJpbmVXaXRoID0gZ2V0Q29tYmluZVdpdGhGcm9tUmVzdWx0KHJlc3VsdCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHN0YXRlLmRyb3BEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGRyb3BwaW5nID0ge1xuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgY3VydmU6IGN1cnZlcy5kcm9wLFxuICAgICAgICBtb3ZlVG86IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgIG9wYWNpdHk6IGNvbWJpbmVXaXRoID8gY29tYmluZS5vcGFjaXR5LmRyb3AgOiBudWxsLFxuICAgICAgICBzY2FsZTogY29tYmluZVdpdGggPyBjb21iaW5lLnNjYWxlLmRyb3AgOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwcGVkOiB7XG4gICAgICAgICAgdHlwZTogJ0RSQUdHSU5HJyxcbiAgICAgICAgICBvZmZzZXQ6IHN0YXRlLm5ld0hvbWVDbGllbnRPZmZzZXQsXG4gICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgIGRyb3BwaW5nLFxuICAgICAgICAgIGRyYWdnaW5nT3ZlcixcbiAgICAgICAgICBjb21iaW5lV2l0aCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGZvcmNlU2hvdWxkQW5pbWF0ZTogbnVsbCxcbiAgICAgICAgICBzbmFwc2hvdDogZ2V0TWVtb2l6ZWRTbmFwc2hvdChtb2RlLCBpc0Nsb25lLCBkcmFnZ2luZ092ZXIsIGNvbWJpbmVXaXRoLCBkcm9wcGluZylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cbmZ1bmN0aW9uIGdldFNlY29uZGFyeVNuYXBzaG90KGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsKSB7XG4gIHJldHVybiB7XG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgaXNEcm9wQW5pbWF0aW5nOiBmYWxzZSxcbiAgICBpc0Nsb25lOiBmYWxzZSxcbiAgICBkcm9wQW5pbWF0aW9uOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmdPdmVyOiBudWxsLFxuICAgIGNvbWJpbmVUYXJnZXRGb3IsXG4gICAgY29tYmluZVdpdGg6IG51bGxcbiAgfTtcbn1cbmNvbnN0IGF0UmVzdCA9IHtcbiAgbWFwcGVkOiB7XG4gICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgb2Zmc2V0OiBvcmlnaW4sXG4gICAgY29tYmluZVRhcmdldEZvcjogbnVsbCxcbiAgICBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50OiB0cnVlLFxuICAgIHNuYXBzaG90OiBnZXRTZWNvbmRhcnlTbmFwc2hvdChudWxsKVxuICB9XG59O1xuZnVuY3Rpb24gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKSB7XG4gIGNvbnN0IG1lbW9pemVkT2Zmc2V0ID0gbWVtb2l6ZU9uZSgoeCwgeSkgPT4gKHtcbiAgICB4LFxuICAgIHlcbiAgfSkpO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gbWVtb2l6ZU9uZShnZXRTZWNvbmRhcnlTbmFwc2hvdCk7XG4gIGNvbnN0IGdldE1lbW9pemVkUHJvcHMgPSBtZW1vaXplT25lKChvZmZzZXQsIGNvbWJpbmVUYXJnZXRGb3IgPSBudWxsLCBzaG91bGRBbmltYXRlRGlzcGxhY2VtZW50KSA9PiAoe1xuICAgIG1hcHBlZDoge1xuICAgICAgdHlwZTogJ1NFQ09OREFSWScsXG4gICAgICBvZmZzZXQsXG4gICAgICBjb21iaW5lVGFyZ2V0Rm9yLFxuICAgICAgc2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCxcbiAgICAgIHNuYXBzaG90OiBnZXRNZW1vaXplZFNuYXBzaG90KGNvbWJpbmVUYXJnZXRGb3IpXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldEZhbGxiYWNrID0gY29tYmluZVRhcmdldEZvciA9PiB7XG4gICAgcmV0dXJuIGNvbWJpbmVUYXJnZXRGb3IgPyBnZXRNZW1vaXplZFByb3BzKG9yaWdpbiwgY29tYmluZVRhcmdldEZvciwgdHJ1ZSkgOiBudWxsO1xuICB9O1xuICBjb25zdCBnZXRQcm9wcyA9IChvd25JZCwgZHJhZ2dpbmdJZCwgaW1wYWN0LCBhZnRlckNyaXRpY2FsKSA9PiB7XG4gICAgY29uc3QgdmlzdWFsRGlzcGxhY2VtZW50ID0gaW1wYWN0LmRpc3BsYWNlZC52aXNpYmxlW293bklkXTtcbiAgICBjb25zdCBpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0ID0gQm9vbGVhbihhZnRlckNyaXRpY2FsLmluVmlydHVhbExpc3QgJiYgYWZ0ZXJDcml0aWNhbC5lZmZlY3RlZFtvd25JZF0pO1xuICAgIGNvbnN0IGNvbWJpbmUgPSB0cnlHZXRDb21iaW5lKGltcGFjdCk7XG4gICAgY29uc3QgY29tYmluZVRhcmdldEZvciA9IGNvbWJpbmUgJiYgY29tYmluZS5kcmFnZ2FibGVJZCA9PT0gb3duSWQgPyBkcmFnZ2luZ0lkIDogbnVsbDtcbiAgICBpZiAoIXZpc3VhbERpc3BsYWNlbWVudCkge1xuICAgICAgaWYgKCFpc0FmdGVyQ3JpdGljYWxJblZpcnR1YWxMaXN0KSB7XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbXBhY3QuZGlzcGxhY2VkLmludmlzaWJsZVtvd25JZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFuZ2UgPSBuZWdhdGUoYWZ0ZXJDcml0aWNhbC5kaXNwbGFjZWRCeS5wb2ludCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChjaGFuZ2UueCwgY2hhbmdlLnkpO1xuICAgICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzQWZ0ZXJDcml0aWNhbEluVmlydHVhbExpc3QpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFjayhjb21iaW5lVGFyZ2V0Rm9yKTtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxhY2VCeSA9IGltcGFjdC5kaXNwbGFjZWRCeS5wb2ludDtcbiAgICBjb25zdCBvZmZzZXQgPSBtZW1vaXplZE9mZnNldChkaXNwbGFjZUJ5LngsIGRpc3BsYWNlQnkueSk7XG4gICAgcmV0dXJuIGdldE1lbW9pemVkUHJvcHMob2Zmc2V0LCBjb21iaW5lVGFyZ2V0Rm9yLCB2aXN1YWxEaXNwbGFjZW1lbnQuc2hvdWxkQW5pbWF0ZSk7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gKHN0YXRlLCBvd25Qcm9wcykgPT4ge1xuICAgIGlmIChpc0RyYWdnaW5nKHN0YXRlKSkge1xuICAgICAgaWYgKHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIHN0YXRlLmNyaXRpY2FsLmRyYWdnYWJsZS5pZCwgc3RhdGUuaW1wYWN0LCBzdGF0ZS5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnBoYXNlID09PSAnRFJPUF9BTklNQVRJTkcnKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoY29tcGxldGVkLnJlc3VsdC5kcmFnZ2FibGVJZCA9PT0gb3duUHJvcHMuZHJhZ2dhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvcHMob3duUHJvcHMuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5yZXN1bHQuZHJhZ2dhYmxlSWQsIGNvbXBsZXRlZC5pbXBhY3QsIGNvbXBsZXRlZC5hZnRlckNyaXRpY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBzZWxlY3Rvcjtcbn1cbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSA9ICgpID0+IHtcbiAgY29uc3QgZHJhZ2dpbmdTZWxlY3RvciA9IGdldERyYWdnYWJsZVNlbGVjdG9yKCk7XG4gIGNvbnN0IHNlY29uZGFyeVNlbGVjdG9yID0gZ2V0U2Vjb25kYXJ5U2VsZWN0b3IoKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiBkcmFnZ2luZ1NlbGVjdG9yKHN0YXRlLCBvd25Qcm9wcykgfHwgc2Vjb25kYXJ5U2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB8fCBhdFJlc3Q7XG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMkMSA9IHtcbiAgZHJvcEFuaW1hdGlvbkZpbmlzaGVkOiBkcm9wQW5pbWF0aW9uRmluaXNoZWRcbn07XG5jb25zdCBDb25uZWN0ZWREcmFnZ2FibGUgPSBjb25uZWN0KG1ha2VNYXBTdGF0ZVRvUHJvcHMkMSwgbWFwRGlzcGF0Y2hUb1Byb3BzJDEsIG51bGwsIHtcbiAgY29udGV4dDogU3RvcmVDb250ZXh0LFxuICBhcmVTdGF0ZVByb3BzRXF1YWw6IGlzU3RyaWN0RXF1YWxcbn0pKERyYWdnYWJsZSk7XG5cbmZ1bmN0aW9uIFByaXZhdGVEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZVJlcXVpcmVkQ29udGV4dChEcm9wcGFibGVDb250ZXh0KTtcbiAgY29uc3QgaXNVc2luZ0Nsb25lRm9yID0gZHJvcHBhYmxlQ29udGV4dC5pc1VzaW5nQ2xvbmVGb3I7XG4gIGlmIChpc1VzaW5nQ2xvbmVGb3IgPT09IHByb3BzLmRyYWdnYWJsZUlkICYmICFwcm9wcy5pc0Nsb25lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGVkRHJhZ2dhYmxlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBQdWJsaWNEcmFnZ2FibGUocHJvcHMpIHtcbiAgY29uc3QgaXNFbmFibGVkID0gdHlwZW9mIHByb3BzLmlzRHJhZ0Rpc2FibGVkID09PSAnYm9vbGVhbicgPyAhcHJvcHMuaXNEcmFnRGlzYWJsZWQgOiB0cnVlO1xuICBjb25zdCBjYW5EcmFnSW50ZXJhY3RpdmVFbGVtZW50cyA9IEJvb2xlYW4ocHJvcHMuZGlzYWJsZUludGVyYWN0aXZlRWxlbWVudEJsb2NraW5nKTtcbiAgY29uc3Qgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MgPSBCb29sZWFuKHByb3BzLnNob3VsZFJlc3BlY3RGb3JjZVByZXNzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpdmF0ZURyYWdnYWJsZSwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNDbG9uZTogZmFsc2UsXG4gICAgaXNFbmFibGVkOiBpc0VuYWJsZWQsXG4gICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IGNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzLFxuICAgIHNob3VsZFJlc3BlY3RGb3JjZVByZXNzOiBzaG91bGRSZXNwZWN0Rm9yY2VQcmVzc1xuICB9KSk7XG59XG5cbmNvbnN0IGlzRXF1YWwgPSBiYXNlID0+IHZhbHVlID0+IGJhc2UgPT09IHZhbHVlO1xuY29uc3QgaXNTY3JvbGwgPSBpc0VxdWFsKCdzY3JvbGwnKTtcbmNvbnN0IGlzQXV0byA9IGlzRXF1YWwoJ2F1dG8nKTtcbmNvbnN0IGlzVmlzaWJsZSA9IGlzRXF1YWwoJ3Zpc2libGUnKTtcbmNvbnN0IGlzRWl0aGVyID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSB8fCBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNCb3RoID0gKG92ZXJmbG93LCBmbikgPT4gZm4ob3ZlcmZsb3cub3ZlcmZsb3dYKSAmJiBmbihvdmVyZmxvdy5vdmVyZmxvd1kpO1xuY29uc3QgaXNFbGVtZW50U2Nyb2xsYWJsZSA9IGVsID0+IHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIGNvbnN0IG92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogc3R5bGUub3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WTogc3R5bGUub3ZlcmZsb3dZXG4gIH07XG4gIHJldHVybiBpc0VpdGhlcihvdmVyZmxvdywgaXNTY3JvbGwpIHx8IGlzRWl0aGVyKG92ZXJmbG93LCBpc0F1dG8pO1xufTtcbmNvbnN0IGlzQm9keVNjcm9sbGFibGUgPSAoKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBnZXRCb2R5RWxlbWVudCgpO1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAhaHRtbCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudCgpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBodG1sU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcbiAgY29uc3QgaHRtbE92ZXJmbG93ID0ge1xuICAgIG92ZXJmbG93WDogaHRtbFN0eWxlLm92ZXJmbG93WCxcbiAgICBvdmVyZmxvd1k6IGh0bWxTdHlsZS5vdmVyZmxvd1lcbiAgfTtcbiAgaWYgKGlzQm90aChodG1sT3ZlcmZsb3csIGlzVmlzaWJsZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhgXG4gICAgV2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHlvdXIgPGJvZHk+IGVsZW1lbnQgbWlnaHQgYmUgYSBzY3JvbGwgY29udGFpbmVyLlxuICAgIFdlIGhhdmUgZm91bmQgbm8gcmVsaWFibGUgd2F5IG9mIGRldGVjdGluZyB3aGV0aGVyIHRoZSA8Ym9keT4gZWxlbWVudCBpcyBhIHNjcm9sbCBjb250YWluZXIuXG4gICAgVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIGEgPGJvZHk+IHNjcm9sbCBiYXIgd2lsbCBiZSBvbiB0aGUgPGh0bWw+IGVsZW1lbnQgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcblxuICAgIEJlY2F1c2Ugd2UgY2Fubm90IGRldGVybWluZSBpZiB0aGUgPGJvZHk+IGlzIGEgc2Nyb2xsIGNvbnRhaW5lciwgYW5kIGdlbmVyYWxseSBpdCBpcyBub3Qgb25lLFxuICAgIHdlIHdpbGwgYmUgdHJlYXRpbmcgdGhlIDxib2R5PiBhcyAqbm90KiBhIHNjcm9sbCBjb250YWluZXJcblxuICAgIE1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWxsby1wYW5nZWEvZG5kL2Jsb2IvbWFpbi9kb2NzL2d1aWRlcy9ob3ctd2UtZGV0ZWN0LXNjcm9sbC1jb250YWluZXJzLm1kXG4gIGApIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgZ2V0Q2xvc2VzdFNjcm9sbGFibGUgPSBlbCA9PiB7XG4gIGlmIChlbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIGlzQm9keVNjcm9sbGFibGUoKSA/IGVsIDogbnVsbDtcbiAgfVxuICBpZiAoZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghaXNFbGVtZW50U2Nyb2xsYWJsZShlbCkpIHtcbiAgICByZXR1cm4gZ2V0Q2xvc2VzdFNjcm9sbGFibGUoZWwucGFyZW50RWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxudmFyIGNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyA9IHNjcm9sbGFibGUgPT4ge1xuICBpZiAoIXNjcm9sbGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5vdGhlclNjcm9sbFBhcmVudCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlKHNjcm9sbGFibGUucGFyZW50RWxlbWVudCk7XG4gIGlmICghYW5vdGhlclNjcm9sbFBhcmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGBcbiAgICBEcm9wcGFibGU6IHVuc3VwcG9ydGVkIG5lc3RlZCBzY3JvbGwgY29udGFpbmVyIGRldGVjdGVkLlxuICAgIEEgRHJvcHBhYmxlIGNhbiBvbmx5IGhhdmUgb25lIHNjcm9sbCBwYXJlbnQgKHdoaWNoIGNhbiBiZSBpdHNlbGYpXG4gICAgTmVzdGVkIHNjcm9sbCBjb250YWluZXJzIGFyZSBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cblxuICAgIFdlIGhvcGUgdG8gc3VwcG9ydCBuZXN0ZWQgc2Nyb2xsIGNvbnRhaW5lcnMgc29vbjogaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9yZWFjdC1iZWF1dGlmdWwtZG5kL2lzc3Vlcy8xMzFcbiAgYCkgOiB2b2lkIDA7XG59O1xuXG52YXIgZ2V0U2Nyb2xsID0gZWwgPT4gKHtcbiAgeDogZWwuc2Nyb2xsTGVmdCxcbiAgeTogZWwuc2Nyb2xsVG9wXG59KTtcblxuY29uc3QgZ2V0SXNGaXhlZCA9IGVsID0+IHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGdldElzRml4ZWQoZWwucGFyZW50RWxlbWVudCk7XG59O1xudmFyIGdldEVudiA9IHN0YXJ0ID0+IHtcbiAgY29uc3QgY2xvc2VzdFNjcm9sbGFibGUgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZShzdGFydCk7XG4gIGNvbnN0IGlzRml4ZWRPblBhZ2UgPSBnZXRJc0ZpeGVkKHN0YXJ0KTtcbiAgcmV0dXJuIHtcbiAgICBjbG9zZXN0U2Nyb2xsYWJsZSxcbiAgICBpc0ZpeGVkT25QYWdlXG4gIH07XG59O1xuXG52YXIgZ2V0RHJvcHBhYmxlRGltZW5zaW9uID0gKHtcbiAgZGVzY3JpcHRvcixcbiAgaXNFbmFibGVkLFxuICBpc0NvbWJpbmVFbmFibGVkLFxuICBpc0ZpeGVkT25QYWdlLFxuICBkaXJlY3Rpb24sXG4gIGNsaWVudCxcbiAgcGFnZSxcbiAgY2xvc2VzdFxufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2Nyb2xsU2l6ZSxcbiAgICAgIGNsaWVudDogZnJhbWVDbGllbnRcbiAgICB9ID0gY2xvc2VzdDtcbiAgICBjb25zdCBtYXhTY3JvbGwgPSBnZXRNYXhTY3JvbGwoe1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxTaXplLnNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBzY3JvbGxTaXplLnNjcm9sbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LmhlaWdodCxcbiAgICAgIHdpZHRoOiBmcmFtZUNsaWVudC5wYWRkaW5nQm94LndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VNYXJnaW5Cb3g6IGNsb3Nlc3QucGFnZS5tYXJnaW5Cb3gsXG4gICAgICBmcmFtZUNsaWVudCxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogY2xvc2VzdC5zaG91bGRDbGlwU3ViamVjdCxcbiAgICAgIHNjcm9sbDoge1xuICAgICAgICBpbml0aWFsOiBjbG9zZXN0LnNjcm9sbCxcbiAgICAgICAgY3VycmVudDogY2xvc2VzdC5zY3JvbGwsXG4gICAgICAgIG1heDogbWF4U2Nyb2xsLFxuICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICAgICAgICBkaXNwbGFjZW1lbnQ6IG9yaWdpblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbiAgY29uc3QgYXhpcyA9IGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHZlcnRpY2FsIDogaG9yaXpvbnRhbDtcbiAgY29uc3Qgc3ViamVjdCA9IGdldFN1YmplY3Qoe1xuICAgIHBhZ2UsXG4gICAgd2l0aFBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGF4aXMsXG4gICAgZnJhbWVcbiAgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IHtcbiAgICBkZXNjcmlwdG9yLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgaXNGaXhlZE9uUGFnZSxcbiAgICBheGlzLFxuICAgIGlzRW5hYmxlZCxcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBmcmFtZSxcbiAgICBzdWJqZWN0XG4gIH07XG4gIHJldHVybiBkaW1lbnNpb247XG59O1xuXG5jb25zdCBnZXRDbGllbnQgPSAodGFyZ2V0UmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSkgPT4ge1xuICBjb25zdCBiYXNlID0gZ2V0Qm94KHRhcmdldFJlZik7XG4gIGlmICghY2xvc2VzdFNjcm9sbGFibGUpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAodGFyZ2V0UmVmICE9PSBjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHRvcCA9IGJhc2UucGFkZGluZ0JveC50b3AgLSBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxUb3A7XG4gIGNvbnN0IGxlZnQgPSBiYXNlLnBhZGRpbmdCb3gubGVmdCAtIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbExlZnQ7XG4gIGNvbnN0IGJvdHRvbSA9IHRvcCArIGNsb3Nlc3RTY3JvbGxhYmxlLnNjcm9sbEhlaWdodDtcbiAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGg7XG4gIGNvbnN0IHBhZGRpbmdCb3ggPSB7XG4gICAgdG9wLFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICBsZWZ0XG4gIH07XG4gIGNvbnN0IGJvcmRlckJveCA9IGV4cGFuZChwYWRkaW5nQm94LCBiYXNlLmJvcmRlcik7XG4gIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUJveCh7XG4gICAgYm9yZGVyQm94LFxuICAgIG1hcmdpbjogYmFzZS5tYXJnaW4sXG4gICAgYm9yZGVyOiBiYXNlLmJvcmRlcixcbiAgICBwYWRkaW5nOiBiYXNlLnBhZGRpbmdcbiAgfSk7XG4gIHJldHVybiBjbGllbnQ7XG59O1xudmFyIGdldERpbWVuc2lvbiA9ICh7XG4gIHJlZixcbiAgZGVzY3JpcHRvcixcbiAgZW52LFxuICB3aW5kb3dTY3JvbGwsXG4gIGRpcmVjdGlvbixcbiAgaXNEcm9wRGlzYWJsZWQsXG4gIGlzQ29tYmluZUVuYWJsZWQsXG4gIHNob3VsZENsaXBTdWJqZWN0XG59KSA9PiB7XG4gIGNvbnN0IGNsb3Nlc3RTY3JvbGxhYmxlID0gZW52LmNsb3Nlc3RTY3JvbGxhYmxlO1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQocmVmLCBjbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIGNvbnN0IHBhZ2UgPSB3aXRoU2Nyb2xsKGNsaWVudCwgd2luZG93U2Nyb2xsKTtcbiAgY29uc3QgY2xvc2VzdCA9ICgoKSA9PiB7XG4gICAgaWYgKCFjbG9zZXN0U2Nyb2xsYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lQ2xpZW50ID0gZ2V0Qm94KGNsb3Nlc3RTY3JvbGxhYmxlKTtcbiAgICBjb25zdCBzY3JvbGxTaXplID0ge1xuICAgICAgc2Nyb2xsSGVpZ2h0OiBjbG9zZXN0U2Nyb2xsYWJsZS5zY3JvbGxIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogY2xvc2VzdFNjcm9sbGFibGUuc2Nyb2xsV2lkdGhcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnQ6IGZyYW1lQ2xpZW50LFxuICAgICAgcGFnZTogd2l0aFNjcm9sbChmcmFtZUNsaWVudCwgd2luZG93U2Nyb2xsKSxcbiAgICAgIHNjcm9sbDogZ2V0U2Nyb2xsKGNsb3Nlc3RTY3JvbGxhYmxlKSxcbiAgICAgIHNjcm9sbFNpemUsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdFxuICAgIH07XG4gIH0pKCk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldERyb3BwYWJsZURpbWVuc2lvbih7XG4gICAgZGVzY3JpcHRvcixcbiAgICBpc0VuYWJsZWQ6ICFpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlzRml4ZWRPblBhZ2U6IGVudi5pc0ZpeGVkT25QYWdlLFxuICAgIGRpcmVjdGlvbixcbiAgICBjbGllbnQsXG4gICAgcGFnZSxcbiAgICBjbG9zZXN0XG4gIH0pO1xuICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuY29uc3QgaW1tZWRpYXRlID0ge1xuICBwYXNzaXZlOiBmYWxzZVxufTtcbmNvbnN0IGRlbGF5ZWQgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG52YXIgZ2V0TGlzdGVuZXJPcHRpb25zID0gb3B0aW9ucyA9PiBvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSA/IGltbWVkaWF0ZSA6IGRlbGF5ZWQ7XG5cbmNvbnN0IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcgPSBkcmFnZ2luZyA9PiBkcmFnZ2luZyAmJiBkcmFnZ2luZy5lbnYuY2xvc2VzdFNjcm9sbGFibGUgfHwgbnVsbDtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZVB1Ymxpc2hlcihhcmdzKSB7XG4gIGNvbnN0IHdoaWxlRHJhZ2dpbmdSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFwcENvbnRleHQgPSB1c2VSZXF1aXJlZENvbnRleHQoQXBwQ29udGV4dCk7XG4gIGNvbnN0IHVuaXF1ZUlkID0gdXNlVW5pcXVlSWQoJ2Ryb3BwYWJsZScpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0cnksXG4gICAgbWFyc2hhbFxuICB9ID0gYXBwQ29udGV4dDtcbiAgY29uc3QgcHJldmlvdXNSZWYgPSB1c2VQcmV2aW91cyhhcmdzKTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpZDogYXJncy5kcm9wcGFibGVJZCxcbiAgICB0eXBlOiBhcmdzLnR5cGUsXG4gICAgbW9kZTogYXJncy5tb2RlXG4gIH0pLCBbYXJncy5kcm9wcGFibGVJZCwgYXJncy5tb2RlLCBhcmdzLnR5cGVdKTtcbiAgY29uc3QgcHVibGlzaGVkRGVzY3JpcHRvclJlZiA9IHVzZVJlZihkZXNjcmlwdG9yKTtcbiAgY29uc3QgbWVtb2l6ZWRVcGRhdGVTY3JvbGwgPSB1c2VNZW1vKCgpID0+IG1lbW9pemVPbmUoKHgsIHkpID0+IHtcbiAgICAhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIHNjcm9sbCB3aGVuIGRyYWdnaW5nJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzY3JvbGwgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVTY3JvbGwoZGVzY3JpcHRvci5pZCwgc2Nyb2xsKTtcbiAgfSksIFtkZXNjcmlwdG9yLmlkLCBtYXJzaGFsXSk7XG4gIGNvbnN0IGdldENsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFkcmFnZ2luZyB8fCAhZHJhZ2dpbmcuZW52LmNsb3Nlc3RTY3JvbGxhYmxlKSB7XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0U2Nyb2xsKGRyYWdnaW5nLmVudi5jbG9zZXN0U2Nyb2xsYWJsZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdXBkYXRlU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbCA9IGdldENsb3Nlc3RTY3JvbGwoKTtcbiAgICBtZW1vaXplZFVwZGF0ZVNjcm9sbChzY3JvbGwueCwgc2Nyb2xsLnkpO1xuICB9LCBbZ2V0Q2xvc2VzdFNjcm9sbCwgbWVtb2l6ZWRVcGRhdGVTY3JvbGxdKTtcbiAgY29uc3Qgc2NoZWR1bGVTY3JvbGxVcGRhdGUgPSB1c2VNZW1vKCgpID0+IHJhZlNjaGQodXBkYXRlU2Nyb2xsKSwgW3VwZGF0ZVNjcm9sbF0pO1xuICBjb25zdCBvbkNsb3Nlc3RTY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICEoZHJhZ2dpbmcgJiYgY2xvc2VzdCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBzY3JvbGwgb3B0aW9ucyB3aGlsZSBzY3JvbGxpbmcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkcmFnZ2luZy5zY3JvbGxPcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNob3VsZFB1Ymxpc2hJbW1lZGlhdGVseSkge1xuICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVkdWxlU2Nyb2xsVXBkYXRlKCk7XG4gIH0sIFtzY2hlZHVsZVNjcm9sbFVwZGF0ZSwgdXBkYXRlU2Nyb2xsXSk7XG4gIGNvbnN0IGdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsID0gdXNlQ2FsbGJhY2soKHdpbmRvd1Njcm9sbCwgb3B0aW9ucykgPT4ge1xuICAgICEhd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbGxlY3QgYSBkcm9wcGFibGUgd2hpbGUgYSBkcmFnIGlzIG9jY3VycmluZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBwcmV2aW91c1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHJlZiA9IHByZXZpb3VzLmdldERyb3BwYWJsZVJlZigpO1xuICAgICFyZWYgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29sbGVjdCB3aXRob3V0IGEgZHJvcHBhYmxlIHJlZicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgZW52ID0gZ2V0RW52KHJlZik7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB7XG4gICAgICByZWYsXG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgZW52LFxuICAgICAgc2Nyb2xsT3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50ID0gZHJhZ2dpbmc7XG4gICAgY29uc3QgZGltZW5zaW9uID0gZ2V0RGltZW5zaW9uKHtcbiAgICAgIHJlZixcbiAgICAgIGRlc2NyaXB0b3IsXG4gICAgICBlbnYsXG4gICAgICB3aW5kb3dTY3JvbGwsXG4gICAgICBkaXJlY3Rpb246IHByZXZpb3VzLmRpcmVjdGlvbixcbiAgICAgIGlzRHJvcERpc2FibGVkOiBwcmV2aW91cy5pc0Ryb3BEaXNhYmxlZCxcbiAgICAgIGlzQ29tYmluZUVuYWJsZWQ6IHByZXZpb3VzLmlzQ29tYmluZUVuYWJsZWQsXG4gICAgICBzaG91bGRDbGlwU3ViamVjdDogIXByZXZpb3VzLmlnbm9yZUNvbnRhaW5lckNsaXBwaW5nXG4gICAgfSk7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZSA9IGVudi5jbG9zZXN0U2Nyb2xsYWJsZTtcbiAgICBpZiAoc2Nyb2xsYWJsZSkge1xuICAgICAgc2Nyb2xsYWJsZS5zZXRBdHRyaWJ1dGUoc2Nyb2xsQ29udGFpbmVyLmNvbnRleHRJZCwgYXBwQ29udGV4dC5jb250ZXh0SWQpO1xuICAgICAgc2Nyb2xsYWJsZS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbkNsb3Nlc3RTY3JvbGwsIGdldExpc3RlbmVyT3B0aW9ucyhkcmFnZ2luZy5zY3JvbGxPcHRpb25zKSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja0Zvck5lc3RlZFNjcm9sbENvbnRhaW5lcnMoc2Nyb2xsYWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb247XG4gIH0sIFthcHBDb250ZXh0LmNvbnRleHRJZCwgZGVzY3JpcHRvciwgb25DbG9zZXN0U2Nyb2xsLCBwcmV2aW91c1JlZl0pO1xuICBjb25zdCBnZXRTY3JvbGxXaGlsZURyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRyYWdnaW5nID0gd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICAhKGRyYWdnaW5nICYmIGNsb3Nlc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgcmVjb2xsZWN0IERyb3BwYWJsZSBjbGllbnQgZm9yIERyb3BwYWJsZXMgdGhhdCBoYXZlIGEgc2Nyb2xsIGNvbnRhaW5lcicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGdldFNjcm9sbChjbG9zZXN0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkcmFnU3RvcHBlZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc3RvcCBkcmFnIHdoZW4gbm8gYWN0aXZlIGRyYWcnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBnZXRDbG9zZXN0U2Nyb2xsYWJsZUZyb21EcmFnKGRyYWdnaW5nKTtcbiAgICB3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghY2xvc2VzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlZHVsZVNjcm9sbFVwZGF0ZS5jYW5jZWwoKTtcbiAgICBjbG9zZXN0LnJlbW92ZUF0dHJpYnV0ZShzY3JvbGxDb250YWluZXIuY29udGV4dElkKTtcbiAgICBjbG9zZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uQ2xvc2VzdFNjcm9sbCwgZ2V0TGlzdGVuZXJPcHRpb25zKGRyYWdnaW5nLnNjcm9sbE9wdGlvbnMpKTtcbiAgfSwgW29uQ2xvc2VzdFNjcm9sbCwgc2NoZWR1bGVTY3JvbGxVcGRhdGVdKTtcbiAgY29uc3Qgc2Nyb2xsID0gdXNlQ2FsbGJhY2soY2hhbmdlID0+IHtcbiAgICBjb25zdCBkcmFnZ2luZyA9IHdoaWxlRHJhZ2dpbmdSZWYuY3VycmVudDtcbiAgICAhZHJhZ2dpbmcgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3Qgc2Nyb2xsIHdoZW4gdGhlcmUgaXMgbm8gZHJhZycpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2xvc2VzdCA9IGdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWcoZHJhZ2dpbmcpO1xuICAgICFjbG9zZXN0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHNjcm9sbCBhIGRyb3BwYWJsZSB3aXRoIG5vIGNsb3Nlc3Qgc2Nyb2xsYWJsZScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICAgY2xvc2VzdC5zY3JvbGxUb3AgKz0gY2hhbmdlLnk7XG4gICAgY2xvc2VzdC5zY3JvbGxMZWZ0ICs9IGNoYW5nZS54O1xuICB9LCBbXSk7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXREaW1lbnNpb25BbmRXYXRjaFNjcm9sbCxcbiAgICAgIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsXG4gICAgICBkcmFnU3RvcHBlZCxcbiAgICAgIHNjcm9sbFxuICAgIH07XG4gIH0sIFtkcmFnU3RvcHBlZCwgZ2V0RGltZW5zaW9uQW5kV2F0Y2hTY3JvbGwsIGdldFNjcm9sbFdoaWxlRHJhZ2dpbmcsIHNjcm9sbF0pO1xuICBjb25zdCBlbnRyeSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICB1bmlxdWVJZCxcbiAgICBkZXNjcmlwdG9yLFxuICAgIGNhbGxiYWNrc1xuICB9KSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgdW5pcXVlSWRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50ID0gZW50cnkuZGVzY3JpcHRvcjtcbiAgICByZWdpc3RyeS5kcm9wcGFibGUucmVnaXN0ZXIoZW50cnkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAod2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoJ1Vuc3VwcG9ydGVkOiBjaGFuZ2luZyB0aGUgZHJvcHBhYmxlSWQgb3IgdHlwZSBvZiBhIERyb3BwYWJsZSBkdXJpbmcgYSBkcmFnJykgOiB2b2lkIDA7XG4gICAgICAgIGRyYWdTdG9wcGVkKCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyeS5kcm9wcGFibGUudW5yZWdpc3RlcihlbnRyeSk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrcywgZGVzY3JpcHRvciwgZHJhZ1N0b3BwZWQsIGVudHJ5LCBtYXJzaGFsLCByZWdpc3RyeS5kcm9wcGFibGVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF3aGlsZURyYWdnaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFyc2hhbC51cGRhdGVEcm9wcGFibGVJc0VuYWJsZWQocHVibGlzaGVkRGVzY3JpcHRvclJlZi5jdXJyZW50LmlkLCAhYXJncy5pc0Ryb3BEaXNhYmxlZCk7XG4gIH0sIFthcmdzLmlzRHJvcERpc2FibGVkLCBtYXJzaGFsXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghd2hpbGVEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hcnNoYWwudXBkYXRlRHJvcHBhYmxlSXNDb21iaW5lRW5hYmxlZChwdWJsaXNoZWREZXNjcmlwdG9yUmVmLmN1cnJlbnQuaWQsIGFyZ3MuaXNDb21iaW5lRW5hYmxlZCk7XG4gIH0sIFthcmdzLmlzQ29tYmluZUVuYWJsZWQsIG1hcnNoYWxdKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCBlbXB0eSA9IHtcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMCxcbiAgbWFyZ2luOiBub1NwYWNpbmdcbn07XG5jb25zdCBnZXRTaXplID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgaWYgKGlzQW5pbWF0aW5nT3Blbk9uTW91bnQpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgaWYgKGFuaW1hdGUgPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IHBsYWNlaG9sZGVyLmNsaWVudC5ib3JkZXJCb3guaGVpZ2h0LFxuICAgIHdpZHRoOiBwbGFjZWhvbGRlci5jbGllbnQuYm9yZGVyQm94LndpZHRoLFxuICAgIG1hcmdpbjogcGxhY2Vob2xkZXIuY2xpZW50Lm1hcmdpblxuICB9O1xufTtcbmNvbnN0IGdldFN0eWxlID0gKHtcbiAgaXNBbmltYXRpbmdPcGVuT25Nb3VudCxcbiAgcGxhY2Vob2xkZXIsXG4gIGFuaW1hdGVcbn0pID0+IHtcbiAgY29uc3Qgc2l6ZSA9IGdldFNpemUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgYW5pbWF0ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiBwbGFjZWhvbGRlci5kaXNwbGF5LFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgbWFyZ2luVG9wOiBzaXplLm1hcmdpbi50b3AsXG4gICAgbWFyZ2luUmlnaHQ6IHNpemUubWFyZ2luLnJpZ2h0LFxuICAgIG1hcmdpbkJvdHRvbTogc2l6ZS5tYXJnaW4uYm90dG9tLFxuICAgIG1hcmdpbkxlZnQ6IHNpemUubWFyZ2luLmxlZnQsXG4gICAgZmxleFNocmluazogJzAnLFxuICAgIGZsZXhHcm93OiAnMCcsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHRyYW5zaXRpb246IGFuaW1hdGUgIT09ICdub25lJyA/IHRyYW5zaXRpb25zLnBsYWNlaG9sZGVyIDogbnVsbFxuICB9O1xufTtcbmNvbnN0IFBsYWNlaG9sZGVyID0gcHJvcHMgPT4ge1xuICBjb25zdCBhbmltYXRlT3BlblRpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFhbmltYXRlT3BlblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJUaW1lb3V0KGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgfSwgW10pO1xuICBjb25zdCB7XG4gICAgYW5pbWF0ZSxcbiAgICBvblRyYW5zaXRpb25FbmQsXG4gICAgb25DbG9zZSxcbiAgICBjb250ZXh0SWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaXNBbmltYXRpbmdPcGVuT25Nb3VudCwgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudF0gPSB1c2VTdGF0ZShwcm9wcy5hbmltYXRlID09PSAnb3BlbicpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBbmltYXRpbmdPcGVuT25Nb3VudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGlmIChhbmltYXRlICE9PSAnb3BlbicpIHtcbiAgICAgIHRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lcigpO1xuICAgICAgc2V0SXNBbmltYXRpbmdPcGVuT25Nb3VudChmYWxzZSk7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGFuaW1hdGVPcGVuVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYW5pbWF0ZU9wZW5UaW1lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHNldElzQW5pbWF0aW5nT3Blbk9uTW91bnQoZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXI7XG4gIH0sIFthbmltYXRlLCBpc0FuaW1hdGluZ09wZW5Pbk1vdW50LCB0cnlDbGVhckFuaW1hdGVPcGVuVGltZXJdKTtcbiAgY29uc3Qgb25TaXplQ2hhbmdlRW5kID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uVHJhbnNpdGlvbkVuZCgpO1xuICAgIGlmIChhbmltYXRlID09PSAnY2xvc2UnKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbYW5pbWF0ZSwgb25DbG9zZSwgb25UcmFuc2l0aW9uRW5kXSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0U3R5bGUoe1xuICAgIGlzQW5pbWF0aW5nT3Blbk9uTW91bnQsXG4gICAgYW5pbWF0ZTogcHJvcHMuYW5pbWF0ZSxcbiAgICBwbGFjZWhvbGRlcjogcHJvcHMucGxhY2Vob2xkZXJcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzLnBsYWNlaG9sZGVyLnRhZ05hbWUsIHtcbiAgICBzdHlsZSxcbiAgICAnZGF0YS1yZmQtcGxhY2Vob2xkZXItY29udGV4dC1pZCc6IGNvbnRleHRJZCxcbiAgICBvblRyYW5zaXRpb25FbmQ6IG9uU2l6ZUNoYW5nZUVuZCxcbiAgICByZWY6IHByb3BzLmlubmVyUmVmXG4gIH0pO1xufTtcbnZhciBQbGFjZWhvbGRlciQxID0gUmVhY3QubWVtbyhQbGFjZWhvbGRlcik7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5mdW5jdGlvbiBydW5DaGVja3MoYXJncywgY2hlY2tzKSB7XG4gIGNoZWNrcy5mb3JFYWNoKGNoZWNrID0+IGNoZWNrKGFyZ3MpKTtcbn1cbmNvbnN0IHNoYXJlZCA9IFtmdW5jdGlvbiByZXF1aXJlZCh7XG4gIHByb3BzXG59KSB7XG4gICFwcm9wcy5kcm9wcGFibGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0EgRHJvcHBhYmxlIHJlcXVpcmVzIGEgZHJvcHBhYmxlSWQgcHJvcCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICEodHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkID09PSAnc3RyaW5nJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIGBBIERyb3BwYWJsZSByZXF1aXJlcyBhIFtzdHJpbmddIGRyb3BwYWJsZUlkLiBQcm92aWRlZDogWyR7dHlwZW9mIHByb3BzLmRyb3BwYWJsZUlkfV1gKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gYm9vbGVhbih7XG4gIHByb3BzXG59KSB7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaXNEcm9wRGlzYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNEcm9wRGlzYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xuICAhaXNCb29sZWFuKHByb3BzLmlzQ29tYmluZUVuYWJsZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaXNDb21iaW5lRW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gICFpc0Jvb2xlYW4ocHJvcHMuaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnaWdub3JlQ29udGFpbmVyQ2xpcHBpbmcgbXVzdCBiZSBhIGJvb2xlYW4nKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gcmVmKHtcbiAgZ2V0RHJvcHBhYmxlUmVmXG59KSB7XG4gIGNoZWNrSXNWYWxpZElubmVyUmVmKGdldERyb3BwYWJsZVJlZigpKTtcbn1dO1xuY29uc3Qgc3RhbmRhcmQgPSBbZnVuY3Rpb24gcGxhY2Vob2xkZXIoe1xuICBwcm9wcyxcbiAgZ2V0UGxhY2Vob2xkZXJSZWZcbn0pIHtcbiAgaWYgKCFwcm9wcy5wbGFjZWhvbGRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWYgPSBnZXRQbGFjZWhvbGRlclJlZigpO1xuICBpZiAocmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoYFxuICAgICAgRHJvcHBhYmxlIHNldHVwIGlzc3VlIFtkcm9wcGFibGVJZDogXCIke3Byb3BzLmRyb3BwYWJsZUlkfVwiXTpcbiAgICAgIERyb3BwYWJsZVByb3ZpZGVkID4gcGxhY2Vob2xkZXIgY291bGQgbm90IGJlIGZvdW5kLlxuXG4gICAgICBQbGVhc2UgYmUgc3VyZSB0byBhZGQgdGhlIHtwcm92aWRlZC5wbGFjZWhvbGRlcn0gUmVhY3QgTm9kZSBhcyBhIGNoaWxkIG9mIHlvdXIgRHJvcHBhYmxlLlxuICAgICAgTW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2hlbGxvLXBhbmdlYS9kbmQvYmxvYi9tYWluL2RvY3MvYXBpL2Ryb3BwYWJsZS5tZFxuICAgIGApIDogdm9pZCAwO1xufV07XG5jb25zdCB2aXJ0dWFsID0gW2Z1bmN0aW9uIGhhc0Nsb25lKHtcbiAgcHJvcHNcbn0pIHtcbiAgIXByb3BzLnJlbmRlckNsb25lID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBwcm92aWRlIGEgY2xvbmUgcmVuZGVyIGZ1bmN0aW9uIChyZW5kZXJDbG9uZSkgZm9yIHZpcnR1YWwgbGlzdHMnKSA6IGludmFyaWFudCgpIDogdm9pZCAwO1xufSwgZnVuY3Rpb24gaGFzTm9QbGFjZWhvbGRlcih7XG4gIGdldFBsYWNlaG9sZGVyUmVmXG59KSB7XG4gICEhZ2V0UGxhY2Vob2xkZXJSZWYoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHZpcnR1YWwgbGlzdCB0byBub3QgaGF2ZSBhIHBsYWNlaG9sZGVyJykgOiBpbnZhcmlhbnQoKSA6IHZvaWQgMDtcbn1dO1xuZnVuY3Rpb24gdXNlVmFsaWRhdGlvbihhcmdzKSB7XG4gIHVzZURldlNldHVwV2FybmluZygoKSA9PiB7XG4gICAgcnVuQ2hlY2tzKGFyZ3MsIHNoYXJlZCk7XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgcnVuQ2hlY2tzKGFyZ3MsIHN0YW5kYXJkKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MucHJvcHMubW9kZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICBydW5DaGVja3MoYXJncywgdmlydHVhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuY2xhc3MgQW5pbWF0ZUluT3V0IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMucHJvcHMub24pLFxuICAgICAgZGF0YTogdGhpcy5wcm9wcy5vbixcbiAgICAgIGFuaW1hdGU6IHRoaXMucHJvcHMuc2hvdWxkQW5pbWF0ZSAmJiB0aGlzLnByb3BzLm9uID8gJ29wZW4nIDogJ25vbmUnXG4gICAgfTtcbiAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5hbmltYXRlICE9PSAnY2xvc2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKCFwcm9wcy5zaG91bGRBbmltYXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4ocHJvcHMub24pLFxuICAgICAgICBkYXRhOiBwcm9wcy5vbixcbiAgICAgICAgYW5pbWF0ZTogJ25vbmUnXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocHJvcHMub24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgZGF0YTogcHJvcHMub24sXG4gICAgICAgIGFuaW1hdGU6ICdvcGVuJ1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBkYXRhOiBzdGF0ZS5kYXRhLFxuICAgICAgICBhbmltYXRlOiAnY2xvc2UnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGFuaW1hdGU6ICdjbG9zZScsXG4gICAgICBkYXRhOiBudWxsXG4gICAgfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVkID0ge1xuICAgICAgb25DbG9zZTogdGhpcy5vbkNsb3NlLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5kYXRhLFxuICAgICAgYW5pbWF0ZTogdGhpcy5zdGF0ZS5hbmltYXRlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbihwcm92aWRlZCk7XG4gIH1cbn1cblxuY29uc3QgRHJvcHBhYmxlID0gcHJvcHMgPT4ge1xuICBjb25zdCBhcHBDb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgIWFwcENvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdDb3VsZCBub3QgZmluZCBhcHAgY29udGV4dCcpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0SWQsXG4gICAgaXNNb3ZlbWVudEFsbG93ZWRcbiAgfSA9IGFwcENvbnRleHQ7XG4gIGNvbnN0IGRyb3BwYWJsZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcGxhY2Vob2xkZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIG1vZGUsXG4gICAgZGlyZWN0aW9uLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGlzRHJvcERpc2FibGVkLFxuICAgIGlzQ29tYmluZUVuYWJsZWQsXG4gICAgc25hcHNob3QsXG4gICAgdXNlQ2xvbmUsXG4gICAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGwsXG4gICAgZ2V0Q29udGFpbmVyRm9yQ2xvbmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBnZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjaygoKSA9PiBkcm9wcGFibGVSZWYuY3VycmVudCwgW10pO1xuICBjb25zdCBzZXREcm9wcGFibGVSZWYgPSB1c2VDYWxsYmFjaygodmFsdWUgPSBudWxsKSA9PiB7XG4gICAgZHJvcHBhYmxlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKCgpID0+IHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qgc2V0UGxhY2Vob2xkZXJSZWYgPSB1c2VDYWxsYmFjaygodmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9LCBbXSk7XG4gIHVzZVZhbGlkYXRpb24oe1xuICAgIHByb3BzLFxuICAgIGdldERyb3BwYWJsZVJlZixcbiAgICBnZXRQbGFjZWhvbGRlclJlZlxuICB9KTtcbiAgY29uc3Qgb25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGlzTW92ZW1lbnRBbGxvd2VkKCkpIHtcbiAgICAgIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsKHtcbiAgICAgICAgbWF4U2Nyb2xsOiBnZXRNYXhXaW5kb3dTY3JvbGwoKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbaXNNb3ZlbWVudEFsbG93ZWQsIHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXSk7XG4gIHVzZURyb3BwYWJsZVB1Ymxpc2hlcih7XG4gICAgZHJvcHBhYmxlSWQsXG4gICAgdHlwZSxcbiAgICBtb2RlLFxuICAgIGRpcmVjdGlvbixcbiAgICBpc0Ryb3BEaXNhYmxlZCxcbiAgICBpc0NvbWJpbmVFbmFibGVkLFxuICAgIGlnbm9yZUNvbnRhaW5lckNsaXBwaW5nLFxuICAgIGdldERyb3BwYWJsZVJlZlxuICB9KTtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSB1c2VNZW1vKCgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0ZUluT3V0LCB7XG4gICAgb246IHByb3BzLnBsYWNlaG9sZGVyLFxuICAgIHNob3VsZEFuaW1hdGU6IHByb3BzLnNob3VsZEFuaW1hdGVQbGFjZWhvbGRlclxuICB9LCAoe1xuICAgIG9uQ2xvc2UsXG4gICAgZGF0YSxcbiAgICBhbmltYXRlXG4gIH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIkMSwge1xuICAgIHBsYWNlaG9sZGVyOiBkYXRhLFxuICAgIG9uQ2xvc2U6IG9uQ2xvc2UsXG4gICAgaW5uZXJSZWY6IHNldFBsYWNlaG9sZGVyUmVmLFxuICAgIGFuaW1hdGU6IGFuaW1hdGUsXG4gICAgY29udGV4dElkOiBjb250ZXh0SWQsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblBsYWNlaG9sZGVyVHJhbnNpdGlvbkVuZFxuICB9KSksIFtjb250ZXh0SWQsIG9uUGxhY2Vob2xkZXJUcmFuc2l0aW9uRW5kLCBwcm9wcy5wbGFjZWhvbGRlciwgcHJvcHMuc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyLCBzZXRQbGFjZWhvbGRlclJlZl0pO1xuICBjb25zdCBwcm92aWRlZCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpbm5lclJlZjogc2V0RHJvcHBhYmxlUmVmLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIGRyb3BwYWJsZVByb3BzOiB7XG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWlkJzogZHJvcHBhYmxlSWQsXG4gICAgICAnZGF0YS1yZmQtZHJvcHBhYmxlLWNvbnRleHQtaWQnOiBjb250ZXh0SWRcbiAgICB9XG4gIH0pLCBbY29udGV4dElkLCBkcm9wcGFibGVJZCwgcGxhY2Vob2xkZXIsIHNldERyb3BwYWJsZVJlZl0pO1xuICBjb25zdCBpc1VzaW5nQ2xvbmVGb3IgPSB1c2VDbG9uZSA/IHVzZUNsb25lLmRyYWdnaW5nLmRyYWdnYWJsZUlkIDogbnVsbDtcbiAgY29uc3QgZHJvcHBhYmxlQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBkcm9wcGFibGVJZCxcbiAgICB0eXBlLFxuICAgIGlzVXNpbmdDbG9uZUZvclxuICB9KSwgW2Ryb3BwYWJsZUlkLCBpc1VzaW5nQ2xvbmVGb3IsIHR5cGVdKTtcbiAgZnVuY3Rpb24gZ2V0Q2xvbmUoKSB7XG4gICAgaWYgKCF1c2VDbG9uZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdnaW5nLFxuICAgICAgcmVuZGVyXG4gICAgfSA9IHVzZUNsb25lO1xuICAgIGNvbnN0IG5vZGUgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFByaXZhdGVEcmFnZ2FibGUsIHtcbiAgICAgIGRyYWdnYWJsZUlkOiBkcmFnZ2luZy5kcmFnZ2FibGVJZCxcbiAgICAgIGluZGV4OiBkcmFnZ2luZy5zb3VyY2UuaW5kZXgsXG4gICAgICBpc0Nsb25lOiB0cnVlLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgc2hvdWxkUmVzcGVjdEZvcmNlUHJlc3M6IGZhbHNlLFxuICAgICAgY2FuRHJhZ0ludGVyYWN0aXZlRWxlbWVudHM6IHRydWVcbiAgICB9LCAoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90KSA9PiByZW5kZXIoZHJhZ2dhYmxlUHJvdmlkZWQsIGRyYWdnYWJsZVNuYXBzaG90LCBkcmFnZ2luZykpO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwobm9kZSwgZ2V0Q29udGFpbmVyRm9yQ2xvbmUoKSk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJvcHBhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBkcm9wcGFibGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKHByb3ZpZGVkLCBzbmFwc2hvdCksIGdldENsb25lKCkpO1xufTtcblxuZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgIWRvY3VtZW50LmJvZHkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdkb2N1bWVudC5ib2R5IGlzIG5vdCByZWFkeScpIDogaW52YXJpYW50KCkgOiB2b2lkIDA7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5O1xufVxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtb2RlOiAnc3RhbmRhcmQnLFxuICB0eXBlOiAnREVGQVVMVCcsXG4gIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgaXNEcm9wRGlzYWJsZWQ6IGZhbHNlLFxuICBpc0NvbWJpbmVFbmFibGVkOiBmYWxzZSxcbiAgaWdub3JlQ29udGFpbmVyQ2xpcHBpbmc6IGZhbHNlLFxuICByZW5kZXJDbG9uZTogbnVsbCxcbiAgZ2V0Q29udGFpbmVyRm9yQ2xvbmU6IGdldEJvZHlcbn07XG5jb25zdCBhdHRhY2hEZWZhdWx0UHJvcHNUb093blByb3BzID0gb3duUHJvcHMgPT4ge1xuICBsZXQgbWVyZ2VkUHJvcHMgPSB7XG4gICAgLi4ub3duUHJvcHNcbiAgfTtcbiAgbGV0IGRlZmF1bHRQcm9wS2V5O1xuICBmb3IgKGRlZmF1bHRQcm9wS2V5IGluIGRlZmF1bHRQcm9wcykge1xuICAgIGlmIChvd25Qcm9wc1tkZWZhdWx0UHJvcEtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbWVyZ2VkUHJvcHMgPSB7XG4gICAgICAgIC4uLm1lcmdlZFByb3BzLFxuICAgICAgICBbZGVmYXVsdFByb3BLZXldOiBkZWZhdWx0UHJvcHNbZGVmYXVsdFByb3BLZXldXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkUHJvcHM7XG59O1xuY29uc3QgaXNNYXRjaGluZ1R5cGUgPSAodHlwZSwgY3JpdGljYWwpID0+IHR5cGUgPT09IGNyaXRpY2FsLmRyb3BwYWJsZS50eXBlO1xuY29uc3QgZ2V0RHJhZ2dhYmxlID0gKGNyaXRpY2FsLCBkaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmRyYWdnYWJsZXNbY3JpdGljYWwuZHJhZ2dhYmxlLmlkXTtcbmNvbnN0IG1ha2VNYXBTdGF0ZVRvUHJvcHMgPSAoKSA9PiB7XG4gIGNvbnN0IGlkbGVXaXRoQW5pbWF0aW9uID0ge1xuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICBzbmFwc2hvdDoge1xuICAgICAgaXNEcmFnZ2luZ092ZXI6IGZhbHNlLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogbnVsbCxcbiAgICAgIGRyYWdnaW5nRnJvbVRoaXNXaXRoOiBudWxsLFxuICAgICAgaXNVc2luZ1BsYWNlaG9sZGVyOiBmYWxzZVxuICAgIH0sXG4gICAgdXNlQ2xvbmU6IG51bGxcbiAgfTtcbiAgY29uc3QgaWRsZVdpdGhvdXRBbmltYXRpb24gPSB7XG4gICAgLi4uaWRsZVdpdGhBbmltYXRpb24sXG4gICAgc2hvdWxkQW5pbWF0ZVBsYWNlaG9sZGVyOiBmYWxzZVxuICB9O1xuICBjb25zdCBnZXREcmFnZ2FibGVSdWJyaWMgPSBtZW1vaXplT25lKGRlc2NyaXB0b3IgPT4gKHtcbiAgICBkcmFnZ2FibGVJZDogZGVzY3JpcHRvci5pZCxcbiAgICB0eXBlOiBkZXNjcmlwdG9yLnR5cGUsXG4gICAgc291cmNlOiB7XG4gICAgICBpbmRleDogZGVzY3JpcHRvci5pbmRleCxcbiAgICAgIGRyb3BwYWJsZUlkOiBkZXNjcmlwdG9yLmRyb3BwYWJsZUlkXG4gICAgfVxuICB9KSk7XG4gIGNvbnN0IGdldE1hcFByb3BzID0gbWVtb2l6ZU9uZSgoaWQsIGlzRW5hYmxlZCwgaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciwgaXNEcmFnZ2luZ092ZXJGb3JJbXBhY3QsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSkgPT4ge1xuICAgIGNvbnN0IGRyYWdnYWJsZUlkID0gZHJhZ2dpbmcuZGVzY3JpcHRvci5pZDtcbiAgICBjb25zdCBpc0hvbWUgPSBkcmFnZ2luZy5kZXNjcmlwdG9yLmRyb3BwYWJsZUlkID09PSBpZDtcbiAgICBpZiAoaXNIb21lKSB7XG4gICAgICBjb25zdCB1c2VDbG9uZSA9IHJlbmRlckNsb25lID8ge1xuICAgICAgICByZW5kZXI6IHJlbmRlckNsb25lLFxuICAgICAgICBkcmFnZ2luZzogZ2V0RHJhZ2dhYmxlUnVicmljKGRyYWdnaW5nLmRlc2NyaXB0b3IpXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgICBpc0RyYWdnaW5nT3ZlcjogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lcixcbiAgICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogaXNEcmFnZ2luZ092ZXJGb3JDb25zdW1lciA/IGRyYWdnYWJsZUlkIDogbnVsbCxcbiAgICAgICAgZHJhZ2dpbmdGcm9tVGhpc1dpdGg6IGRyYWdnYWJsZUlkLFxuICAgICAgICBpc1VzaW5nUGxhY2Vob2xkZXI6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZWhvbGRlcjogZHJhZ2dpbmcucGxhY2Vob2xkZXIsXG4gICAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgIHNuYXBzaG90LFxuICAgICAgICB1c2VDbG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0RyYWdnaW5nT3ZlckZvckltcGFjdCkge1xuICAgICAgcmV0dXJuIGlkbGVXaXRoQW5pbWF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBzbmFwc2hvdCA9IHtcbiAgICAgIGlzRHJhZ2dpbmdPdmVyOiBpc0RyYWdnaW5nT3ZlckZvckNvbnN1bWVyLFxuICAgICAgZHJhZ2dpbmdPdmVyV2l0aDogZHJhZ2dhYmxlSWQsXG4gICAgICBkcmFnZ2luZ0Zyb21UaGlzV2l0aDogbnVsbCxcbiAgICAgIGlzVXNpbmdQbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYWNlaG9sZGVyOiBkcmFnZ2luZy5wbGFjZWhvbGRlcixcbiAgICAgIHNob3VsZEFuaW1hdGVQbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgIHNuYXBzaG90LFxuICAgICAgdXNlQ2xvbmU6IG51bGxcbiAgICB9O1xuICB9KTtcbiAgY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUsIG93blByb3BzKSA9PiB7XG4gICAgY29uc3Qgb3duUHJvcHNXaXRoRGVmYXVsdFByb3BzID0gYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyhvd25Qcm9wcyk7XG4gICAgY29uc3QgaWQgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuZHJvcHBhYmxlSWQ7XG4gICAgY29uc3QgdHlwZSA9IG93blByb3BzV2l0aERlZmF1bHRQcm9wcy50eXBlO1xuICAgIGNvbnN0IGlzRW5hYmxlZCA9ICFvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMuaXNEcm9wRGlzYWJsZWQ7XG4gICAgY29uc3QgcmVuZGVyQ2xvbmUgPSBvd25Qcm9wc1dpdGhEZWZhdWx0UHJvcHMucmVuZGVyQ2xvbmU7XG4gICAgaWYgKGlzRHJhZ2dpbmcoc3RhdGUpKSB7XG4gICAgICBjb25zdCBjcml0aWNhbCA9IHN0YXRlLmNyaXRpY2FsO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZ2dpbmcgPSBnZXREcmFnZ2FibGUoY3JpdGljYWwsIHN0YXRlLmRpbWVuc2lvbnMpO1xuICAgICAgY29uc3QgaXNEcmFnZ2luZ092ZXIgPSB3aGF0SXNEcmFnZ2VkT3ZlcihzdGF0ZS5pbXBhY3QpID09PSBpZDtcbiAgICAgIHJldHVybiBnZXRNYXBQcm9wcyhpZCwgaXNFbmFibGVkLCBpc0RyYWdnaW5nT3ZlciwgaXNEcmFnZ2luZ092ZXIsIGRyYWdnaW5nLCByZW5kZXJDbG9uZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5waGFzZSA9PT0gJ0RST1BfQU5JTUFUSU5HJykge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gc3RhdGUuY29tcGxldGVkO1xuICAgICAgaWYgKCFpc01hdGNoaW5nVHlwZSh0eXBlLCBjb21wbGV0ZWQuY3JpdGljYWwpKSB7XG4gICAgICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWdnaW5nID0gZ2V0RHJhZ2dhYmxlKGNvbXBsZXRlZC5jcml0aWNhbCwgc3RhdGUuZGltZW5zaW9ucyk7XG4gICAgICByZXR1cm4gZ2V0TWFwUHJvcHMoaWQsIGlzRW5hYmxlZCwgd2hhdElzRHJhZ2dlZE92ZXJGcm9tUmVzdWx0KGNvbXBsZXRlZC5yZXN1bHQpID09PSBpZCwgd2hhdElzRHJhZ2dlZE92ZXIoY29tcGxldGVkLmltcGFjdCkgPT09IGlkLCBkcmFnZ2luZywgcmVuZGVyQ2xvbmUpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucGhhc2UgPT09ICdJRExFJyAmJiBzdGF0ZS5jb21wbGV0ZWQgJiYgIXN0YXRlLnNob3VsZEZsdXNoKSB7XG4gICAgICBjb25zdCBjb21wbGV0ZWQgPSBzdGF0ZS5jb21wbGV0ZWQ7XG4gICAgICBpZiAoIWlzTWF0Y2hpbmdUeXBlKHR5cGUsIGNvbXBsZXRlZC5jcml0aWNhbCkpIHtcbiAgICAgICAgcmV0dXJuIGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2FzT3ZlciA9IHdoYXRJc0RyYWdnZWRPdmVyKGNvbXBsZXRlZC5pbXBhY3QpID09PSBpZDtcbiAgICAgIGNvbnN0IHdhc0NvbWJpbmluZyA9IEJvb2xlYW4oY29tcGxldGVkLmltcGFjdC5hdCAmJiBjb21wbGV0ZWQuaW1wYWN0LmF0LnR5cGUgPT09ICdDT01CSU5FJyk7XG4gICAgICBjb25zdCBpc0hvbWUgPSBjb21wbGV0ZWQuY3JpdGljYWwuZHJvcHBhYmxlLmlkID09PSBpZDtcbiAgICAgIGlmICh3YXNPdmVyKSB7XG4gICAgICAgIHJldHVybiB3YXNDb21iaW5pbmcgPyBpZGxlV2l0aEFuaW1hdGlvbiA6IGlkbGVXaXRob3V0QW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzSG9tZSkge1xuICAgICAgICByZXR1cm4gaWRsZVdpdGhBbmltYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gaWRsZVdpdGhvdXRBbmltYXRpb247XG4gICAgfVxuICAgIHJldHVybiBpZGxlV2l0aG91dEFuaW1hdGlvbjtcbiAgfTtcbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcbmNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IHtcbiAgdXBkYXRlVmlld3BvcnRNYXhTY3JvbGw6IHVwZGF0ZVZpZXdwb3J0TWF4U2Nyb2xsXG59O1xuY29uc3QgQ29ubmVjdGVkRHJvcHBhYmxlID0gY29ubmVjdChtYWtlTWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIChzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykgPT4ge1xuICByZXR1cm4ge1xuICAgIC4uLmF0dGFjaERlZmF1bHRQcm9wc1RvT3duUHJvcHMob3duUHJvcHMpLFxuICAgIC4uLnN0YXRlUHJvcHMsXG4gICAgLi4uZGlzcGF0Y2hQcm9wc1xuICB9O1xufSwge1xuICBjb250ZXh0OiBTdG9yZUNvbnRleHQsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbDogaXNTdHJpY3RFcXVhbFxufSkoRHJvcHBhYmxlKTtcblxuZXhwb3J0IHsgRHJhZ0Ryb3BDb250ZXh0LCBQdWJsaWNEcmFnZ2FibGUgYXMgRHJhZ2dhYmxlLCBDb25uZWN0ZWREcm9wcGFibGUgYXMgRHJvcHBhYmxlLCB1c2VLZXlib2FyZFNlbnNvciwgdXNlTW91c2VTZW5zb3IsIHVzZVRvdWNoU2Vuc29yIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNvbnRleHQiLCJSZWFjdERPTSIsImZsdXNoU3luYyIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlU3RvcmUkMSIsImNvbXBvc2UiLCJhcHBseU1pZGRsZXdhcmUiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJQcm92aWRlciIsImNvbm5lY3QiLCJnZXRSZWN0IiwiZXhwYW5kIiwib2Zmc2V0Iiwid2l0aFNjcm9sbCIsImNhbGN1bGF0ZUJveCIsImdldEJveCIsImNyZWF0ZUJveCIsInJhZlNjaGQiLCJfZXh0ZW5kcyIsImlzUHJvZHVjdGlvbiQxIiwicHJvY2VzcyIsInNwYWNlc0FuZFRhYnMiLCJsaW5lU3RhcnRXaXRoU3BhY2VzIiwiY2xlYW4kMiIsInZhbHVlIiwicmVwbGFjZSIsInRyaW0iLCJnZXREZXZNZXNzYWdlIiwibWVzc2FnZSIsImdldEZvcm1hdHRlZE1lc3NhZ2UiLCJpc0Rpc2FibGVkRmxhZyIsImxvZyIsInR5cGUiLCJ3aW5kb3ciLCJjb25zb2xlIiwid2FybmluZyIsImJpbmQiLCJlcnJvciIsIm5vb3AkMiIsImdldE9wdGlvbnMiLCJzaGFyZWQiLCJmcm9tQmluZGluZyIsImJpbmRFdmVudHMiLCJlbCIsImJpbmRpbmdzIiwic2hhcmVkT3B0aW9ucyIsInVuYmluZGluZ3MiLCJtYXAiLCJiaW5kaW5nIiwib3B0aW9ucyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJmbiIsInVuYmluZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bmJpbmRBbGwiLCJmb3JFYWNoIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4JDEiLCJSYmRJbnZhcmlhbnQiLCJFcnJvciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwiYXJncyIsImNhbGxiYWNrcyIsIm9uV2luZG93RXJyb3IiLCJldmVudCIsImdldENhbGxiYWNrcyIsImlzRHJhZ2dpbmciLCJ0cnlBYm9ydCIsImVyciIsInByZXZlbnREZWZhdWx0Iiwic2V0Q2FsbGJhY2tzIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRDYXRjaCIsInNldFN0YXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW5kZXIiLCJwcm9wcyIsImNoaWxkcmVuIiwiZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zIiwicG9zaXRpb24iLCJpbmRleCIsIm9uRHJhZ1N0YXJ0Iiwic3RhcnQiLCJzb3VyY2UiLCJ3aXRoTG9jYXRpb24iLCJkZXN0aW5hdGlvbiIsImlzSW5Ib21lTGlzdCIsImRyb3BwYWJsZUlkIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0aW9uIiwid2l0aENvbWJpbmUiLCJpZCIsImNvbWJpbmUiLCJpbkhvbWVMaXN0IiwiZHJhZ2dhYmxlSWQiLCJvbkRyYWdVcGRhdGUiLCJ1cGRhdGUiLCJsb2NhdGlvbiIsInJldHVybmVkVG9TdGFydCIsIm9uRHJhZ0VuZCIsInJlc3VsdCIsInJlYXNvbiIsInByZXNldCIsImlzRXF1YWwkMiIsImZpcnN0Iiwic2Vjb25kIiwiTnVtYmVyIiwiaXNOYU4iLCJhcmVJbnB1dHNFcXVhbCIsIm5ld0lucHV0cyIsImxhc3RJbnB1dHMiLCJsZW5ndGgiLCJpIiwidXNlTWVtbyIsImdldFJlc3VsdCIsImlucHV0cyIsImluaXRpYWwiLCJpc0ZpcnN0UnVuIiwiY29tbWl0dGVkIiwidXNlQ2FjaGUiLCJjdXJyZW50IiwiQm9vbGVhbiIsImNhY2hlIiwidXNlQ2FsbGJhY2siLCJjYWxsYmFjayIsIm9yaWdpbiIsIngiLCJ5IiwiYWRkIiwicG9pbnQxIiwicG9pbnQyIiwic3VidHJhY3QiLCJpc0VxdWFsJDEiLCJuZWdhdGUiLCJwb2ludCIsInBhdGNoIiwibGluZSIsIm90aGVyVmFsdWUiLCJkaXN0YW5jZSIsIk1hdGgiLCJzcXJ0IiwiY2xvc2VzdCQxIiwidGFyZ2V0IiwicG9pbnRzIiwibWluIiwiYXBwbHkiLCJleGVjdXRlQ2xpcCIsImZyYW1lIiwic3ViamVjdCIsInRvcCIsIm1heCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0Iiwib2Zmc2V0QnlQb3NpdGlvbiIsInNwYWNpbmciLCJnZXRDb3JuZXJzIiwibm9TcGFjaW5nIiwic2Nyb2xsJDEiLCJzY3JvbGwiLCJkaWZmIiwiZGlzcGxhY2VtZW50IiwiaW5jcmVhc2UiLCJheGlzIiwid2l0aFBsYWNlaG9sZGVyIiwiaW5jcmVhc2VkQnkiLCJlbmQiLCJjbGlwIiwic2hvdWxkQ2xpcFN1YmplY3QiLCJwYWdlTWFyZ2luQm94IiwiZ2V0U3ViamVjdCIsInBhZ2UiLCJzY3JvbGxlZCIsIm1hcmdpbkJveCIsImluY3JlYXNlZCIsImNsaXBwZWQiLCJhY3RpdmUiLCJzY3JvbGxEcm9wcGFibGUiLCJkcm9wcGFibGUiLCJuZXdTY3JvbGwiLCJzY3JvbGxhYmxlIiwic2Nyb2xsRGlmZiIsInNjcm9sbERpc3BsYWNlbWVudCIsIm1lbW9pemVPbmUiLCJyZXN1bHRGbiIsImlzRXF1YWwiLCJtZW1vaXplZCIsIm5ld0FyZ3MiLCJsYXN0VGhpcyIsImxhc3RBcmdzIiwibGFzdFJlc3VsdCIsImNsZWFyIiwidG9Ecm9wcGFibGVNYXAiLCJkcm9wcGFibGVzIiwicmVkdWNlIiwicHJldmlvdXMiLCJkZXNjcmlwdG9yIiwidG9EcmFnZ2FibGVNYXAiLCJkcmFnZ2FibGVzIiwidG9Ecm9wcGFibGVMaXN0IiwiT2JqZWN0IiwidmFsdWVzIiwidG9EcmFnZ2FibGVMaXN0IiwiZ2V0RHJhZ2dhYmxlc0luc2lkZURyb3BwYWJsZSIsImZpbHRlciIsImRyYWdnYWJsZSIsInNvcnQiLCJhIiwiYiIsInRyeUdldERlc3RpbmF0aW9uIiwiaW1wYWN0IiwiYXQiLCJ0cnlHZXRDb21iaW5lIiwicmVtb3ZlRHJhZ2dhYmxlRnJvbUxpc3QiLCJyZW1vdmUiLCJsaXN0IiwiaXRlbSIsIm1vdmVUb05leHRDb21iaW5lIiwiaXNNb3ZpbmdGb3J3YXJkIiwiaW5zaWRlRGVzdGluYXRpb24iLCJwcmV2aW91c0ltcGFjdCIsImlzQ29tYmluZUVuYWJsZWQiLCJnZXRJbXBhY3QiLCJhbGwiLCJkaXNwbGFjZWQiLCJjbG9zZXN0SWQiLCJ3aXRob3V0RHJhZ2dhYmxlIiwibGFzdCIsImluZGV4T2ZDbG9zZXN0IiwiZmluZEluZGV4IiwiZCIsInByb3Bvc2VkSW5kZXgiLCJiZWZvcmUiLCJpc0hvbWVPZiIsIm5vRGlzcGxhY2VkQnkiLCJlbXB0eUdyb3VwcyIsImludmlzaWJsZSIsInZpc2libGUiLCJub0ltcGFjdCIsImRpc3BsYWNlZEJ5IiwiaXNXaXRoaW4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImlzUGFydGlhbGx5VmlzaWJsZVRocm91Z2hGcmFtZSIsImlzV2l0aGluVmVydGljYWwiLCJpc1dpdGhpbkhvcml6b250YWwiLCJpc0NvbnRhaW5lZCIsImlzUGFydGlhbGx5VmlzaWJsZVZlcnRpY2FsbHkiLCJpc1BhcnRpYWxseVZpc2libGVIb3Jpem9udGFsbHkiLCJpc1BhcnRpYWxseUNvbnRhaW5lZCIsImlzQmlnZ2VyVmVydGljYWxseSIsImlzQmlnZ2VySG9yaXpvbnRhbGx5IiwiaXNUYXJnZXRCaWdnZXJUaGFuRnJhbWUiLCJpc1RhcmdldEJpZ2dlck9uT25lQXhpcyIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWUiLCJ2ZXJ0aWNhbCIsImRpcmVjdGlvbiIsImNyb3NzQXhpc0xpbmUiLCJzaXplIiwiY3Jvc3NBeGlzU3RhcnQiLCJjcm9zc0F4aXNFbmQiLCJjcm9zc0F4aXNTaXplIiwiaG9yaXpvbnRhbCIsImlzVG90YWxseVZpc2libGVUaHJvdWdoRnJhbWVPbkF4aXMiLCJnZXREcm9wcGFibGVEaXNwbGFjZWQiLCJpc1Zpc2libGVJbkRyb3BwYWJsZSIsImlzVmlzaWJsZVRocm91Z2hGcmFtZUZuIiwiaXNWaXNpYmxlSW5WaWV3cG9ydCIsInZpZXdwb3J0IiwiaXNWaXNpYmxlJDEiLCJ0b0JlRGlzcGxhY2VkIiwid2l0aERyb3BwYWJsZURpc3BsYWNlbWVudCIsImRpc3BsYWNlZFRhcmdldCIsImlzUGFydGlhbGx5VmlzaWJsZSIsImlzVG90YWxseVZpc2libGUiLCJpc1RvdGFsbHlWaXNpYmxlT25BeGlzIiwiZ2V0U2hvdWxkQW5pbWF0ZSIsImZvcmNlU2hvdWxkQW5pbWF0ZSIsInNob3VsZEFuaW1hdGUiLCJnZXRUYXJnZXQiLCJleHBhbmRCeSIsImdldERpc3BsYWNlbWVudEdyb3VwcyIsImFmdGVyRHJhZ2dpbmciLCJncm91cHMiLCJwdXNoIiwiaXNWaXNpYmxlIiwiZ2V0SW5kZXhPZkxhc3RJdGVtIiwiaW5kZXhPZkxhc3RJdGVtIiwiZ29BdEVuZCIsIm5ld0luZGV4IiwiY2FsY3VsYXRlUmVvcmRlckltcGFjdCIsIm1hdGNoIiwiZmluZCIsIndpdGhvdXREcmFnZ2luZyIsInNsaWNlRnJvbSIsImluZGV4T2YiLCJpbXBhY3RlZCIsInNsaWNlIiwiZGlkU3RhcnRBZnRlckNyaXRpY2FsIiwiYWZ0ZXJDcml0aWNhbCIsImVmZmVjdGVkIiwiZnJvbUNvbWJpbmUiLCJjb21iaW5lSWQiLCJjb21iaW5lV2l0aCIsImNvbWJpbmVXaXRoSW5kZXgiLCJkaWRDb21iaW5lV2l0aFN0YXJ0QWZ0ZXJDcml0aWNhbCIsImZyb21SZW9yZGVyIiwiY3VycmVudEluZGV4IiwiZmlyc3RJbmRleCIsImxhc3RJbmRleCIsIm1vdmVUb05leHRJbmRleCIsIndhc0F0IiwiZ2V0Q29tYmluZWRJdGVtRGlzcGxhY2VtZW50IiwiaXNEaXNwbGFjZWQiLCJ3aGVuQ29tYmluaW5nIiwiY2VudGVyIiwiYm9yZGVyQm94IiwiZGlzcGxhY2VCeSIsImRpc3RhbmNlRnJvbVN0YXJ0VG9Cb3JkZXJCb3hDZW50ZXIiLCJib3giLCJtYXJnaW4iLCJkaXN0YW5jZUZyb21FbmRUb0JvcmRlckJveENlbnRlciIsImdldENyb3NzQXhpc0JvcmRlckJveENlbnRlciIsImlzTW92aW5nIiwiZ29BZnRlciIsIm1vdmVSZWxhdGl2ZVRvIiwiZ29CZWZvcmUiLCJnb0ludG9TdGFydCIsIm1vdmVJbnRvIiwiY29udGVudEJveCIsIndoZW5SZW9yZGVyaW5nIiwiZHJhZ2dhYmxlUGFnZSIsImNsb3Nlc3RBZnRlciIsImNsb3Nlc3QiLCJ3aXRoRGlzcGxhY2VtZW50IiwiZ2V0UmVzdWx0V2l0aG91dERyb3BwYWJsZURpc3BsYWNlbWVudCIsIm9yaWdpbmFsIiwiZ2V0UGFnZUJvcmRlckJveENlbnRlckZyb21JbXBhY3QiLCJ3aXRob3V0RGlzcGxhY2VtZW50Iiwic2Nyb2xsVmlld3BvcnQiLCJ1cGRhdGVkIiwiZ2V0RHJhZ2dhYmxlcyQxIiwiaWRzIiwidHJ5R2V0VmlzaWJsZSIsInNwZWN1bGF0aXZlbHlJbmNyZWFzZSIsIm1heFNjcm9sbENoYW5nZSIsInNjcm9sbGVkVmlld3BvcnQiLCJzY3JvbGxlZERyb3BwYWJsZSIsIndpdGhWaWV3cG9ydFNjcm9sbCIsIndpdGhEcm9wcGFibGVTY3JvbGwiLCJuZXdJbXBhY3QiLCJ3aXRoVmlld3BvcnREaXNwbGFjZW1lbnQiLCJnZXRDbGllbnRGcm9tUGFnZUJvcmRlckJveENlbnRlciIsInBhZ2VCb3JkZXJCb3hDZW50ZXIiLCJ3aXRob3V0UGFnZVNjcm9sbENoYW5nZSIsImNsaWVudCIsImlzVG90YWxseVZpc2libGVJbk5ld0xvY2F0aW9uIiwibmV3UGFnZUJvcmRlckJveENlbnRlciIsIm9ubHlPbk1haW5BeGlzIiwiY2hhbmdlTmVlZGVkIiwic2hpZnRlZCIsIm1vdmVUb05leHRQbGFjZSIsInByZXZpb3VzUGFnZUJvcmRlckJveENlbnRlciIsInByZXZpb3VzQ2xpZW50U2VsZWN0aW9uIiwiaXNFbmFibGVkIiwiaXNWaXNpYmxlSW5OZXdMb2NhdGlvbiIsImNsaWVudFNlbGVjdGlvbiIsInNjcm9sbEp1bXBSZXF1ZXN0IiwiY2F1dGlvdXMiLCJnZXRLbm93bkFjdGl2ZSIsInJlY3QiLCJnZXRCZXN0Q3Jvc3NBeGlzRHJvcHBhYmxlIiwiaXNCZXR3ZWVuU291cmNlQ2xpcHBlZCIsImNhbmRpZGF0ZXMiLCJhY3RpdmVPZlRhcmdldCIsImlzQmV0d2VlbkRlc3RpbmF0aW9uQ2xpcHBlZCIsImFycmF5IiwiY29udGFpbnMiLCJpc1dpdGhpbkRyb3BwYWJsZSIsImdldEN1cnJlbnRQYWdlQm9yZGVyQm94Q2VudGVyIiwiZ2V0Q3VycmVudFBhZ2VCb3JkZXJCb3giLCJnZXRDbG9zZXN0RHJhZ2dhYmxlIiwic29ydGVkIiwiZGlzdGFuY2VUb0EiLCJkaXN0YW5jZVRvQiIsImdldERpc3BsYWNlZEJ5IiwiZ2V0UmVxdWlyZWRHcm93dGhGb3JQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyU2l6ZSIsIm1vZGUiLCJhdmFpbGFibGVTcGFjZSIsImluc2lkZURyb3BwYWJsZSIsInNwYWNlVXNlZCIsInN1bSIsImRpbWVuc2lvbiIsInJlcXVpcmVkU3BhY2UiLCJuZWVkc1RvR3Jvd0J5Iiwid2l0aE1heFNjcm9sbCIsImFkZFBsYWNlaG9sZGVyIiwicmVxdWlyZWRHcm93dGgiLCJhZGRlZCIsIm9sZEZyYW1lTWF4U2Nyb2xsIiwibWF4U2Nyb2xsIiwibmV3RnJhbWUiLCJyZW1vdmVQbGFjZWhvbGRlciIsIm9sZE1heFNjcm9sbCIsIm1vdmVUb05ld0Ryb3BwYWJsZSIsInByb3Bvc2VkIiwicHJvcG9zZWRQYWdlQm9yZGVyQm94Q2VudGVyIiwiaXNHb2luZ0JlZm9yZVRhcmdldCIsInJlbGF0aXZlVG8iLCJtb3ZlQ3Jvc3NBeGlzIiwiaXNPdmVyIiwid2hhdElzRHJhZ2dlZE92ZXIiLCJnZXREcm9wcGFibGVPdmVyJDEiLCJtb3ZlSW5EaXJlY3Rpb24iLCJzdGF0ZSIsImlzQWN0dWFsbHlPdmVyIiwiZGltZW5zaW9ucyIsImlzTWFpbkF4aXNNb3ZlbWVudEFsbG93ZWQiLCJob21lIiwiY3JpdGljYWwiLCJpc01vdmluZ09uTWFpbkF4aXMiLCJib3JkZXJCb3hDZW50ZXIiLCJzZWxlY3Rpb24iLCJpc01vdmVtZW50QWxsb3dlZCIsInBoYXNlIiwiaXNQb3NpdGlvbkluRnJhbWUiLCJydW4iLCJnZXRIYXNPdmVybGFwIiwiZ2V0RnVydGhlc3RBd2F5IiwicGFnZUJvcmRlckJveCIsInN0YXJ0Q2VudGVyIiwiY2FuZGlkYXRlIiwiZ2V0RHJvcHBhYmxlT3ZlciIsImNoaWxkQ2VudGVyIiwiaXNTdGFydENvbnRhaW5lZCIsImlzRW5kQ29udGFpbmVkIiwib2Zmc2V0UmVjdEJ5UG9zaXRpb24iLCJhcmVhIiwiZ2V0SXNEaXNwbGFjZWQiLCJhdEluZGV4IiwiZ2V0UmVvcmRlckltcGFjdCIsInBhZ2VCb3JkZXJCb3hXaXRoRHJvcHBhYmxlU2Nyb2xsIiwidGFyZ2V0UmVjdCIsInRhcmdldFN0YXJ0IiwidGFyZ2V0RW5kIiwiY2hpbGQiLCJkaWRTdGFydEFmdGVyQ3JpdGljYWwkMSIsImNvbWJpbmVUaHJlc2hvbGREaXZpc29yIiwiZ2V0Q29tYmluZUltcGFjdCIsImNoaWxkUmVjdCIsImNoaWxkU2l6ZSIsInRocmVzaG9sZCIsImdldERyYWdJbXBhY3QiLCJwYWdlT2Zmc2V0IiwiZGVzdGluYXRpb25JZCIsInBhdGNoRHJvcHBhYmxlTWFwIiwiY2xlYXJVbnVzZWRQbGFjZWhvbGRlciIsIm5vdyIsImxhc3REcm9wcGFibGUiLCJyZWNvbXB1dGVQbGFjZWhvbGRlcnMiLCJjbGVhbmVkIiwicGF0Y2hlZCIsImZvcmNlZENsaWVudFNlbGVjdGlvbiIsImZvcmNlZERpbWVuc2lvbnMiLCJmb3JjZWRWaWV3cG9ydCIsImZvcmNlZEltcGFjdCIsIndpdGhVcGRhdGVkUGxhY2Vob2xkZXJzIiwiZ2V0RHJhZ2dhYmxlcyIsInJlY29tcHV0ZSIsImdldENsaWVudEJvcmRlckJveENlbnRlciIsInJlZnJlc2hTbmFwIiwibW92ZW1lbnRNb2RlIiwibmVlZHNWaXNpYmlsaXR5Q2hlY2siLCJnZXRIb21lTG9jYXRpb24iLCJnZXRMaWZ0RWZmZWN0IiwiaW5zaWRlSG9tZSIsInJhd0luZGV4IiwiaW5WaXJ0dWFsTGlzdCIsInBhdGNoRGltZW5zaW9uTWFwIiwia2V5IiwiZmluaXNoIiwib2Zmc2V0RHJhZ2dhYmxlIiwib2Zmc2V0JDEiLCJpbml0aWFsV2luZG93U2Nyb2xsIiwibW92ZWQiLCJwbGFjZWhvbGRlciIsImdldEZyYW1lIiwiYWRqdXN0QWRkaXRpb25zRm9yU2Nyb2xsQ2hhbmdlcyIsImFkZGl0aW9ucyIsInVwZGF0ZWREcm9wcGFibGVzIiwid2luZG93U2Nyb2xsQ2hhbmdlIiwibW9kaWZpZWQiLCJkcm9wcGFibGVTY3JvbGxDaGFuZ2UiLCJ0b3RhbENoYW5nZSIsInB1Ymxpc2hXaGlsZURyYWdnaW5nSW5WaXJ0dWFsIiwicHVibGlzaGVkIiwid2l0aFNjcm9sbENoYW5nZSIsImV4aXN0aW5nIiwidXBkYXRlZEFkZGl0aW9ucyIsInJlbW92YWxzIiwid2FzT3ZlcklkIiwid2FzT3ZlciIsIm9uTGlmdEltcGFjdCIsImRyYWdnaW5nU3RhdGUiLCJkcm9wUGVuZGluZyIsImlzV2FpdGluZyIsImlzU25hcHBpbmciLCJwb3N0RHJvcHBhYmxlQ2hhbmdlIiwiaXNFbmFibGVkQ2hhbmdpbmciLCJyZW1vdmVTY3JvbGxKdW1wUmVxdWVzdCIsImlkbGUkMiIsImNvbXBsZXRlZCIsInNob3VsZEZsdXNoIiwicmVkdWNlciIsImFjdGlvbiIsInBheWxvYWQiLCJpc1dpbmRvd1Njcm9sbEFsbG93ZWQiLCJldmVyeSIsImlzRml4ZWRPblBhZ2UiLCJTdHJpbmciLCJuZXdTdGF0ZSIsImRyb3BEdXJhdGlvbiIsIm5ld0hvbWVDbGllbnRPZmZzZXQiLCJndWFyZCIsInByZWRpY2F0ZSIsImJlZm9yZUluaXRpYWxDYXB0dXJlIiwibGlmdCQxIiwiaW5pdGlhbFB1Ymxpc2giLCJwdWJsaXNoV2hpbGVEcmFnZ2luZyIsImNvbGxlY3Rpb25TdGFydGluZyIsInVwZGF0ZURyb3BwYWJsZVNjcm9sbCIsInVwZGF0ZURyb3BwYWJsZUlzRW5hYmxlZCIsInVwZGF0ZURyb3BwYWJsZUlzQ29tYmluZUVuYWJsZWQiLCJtb3ZlIiwibW92ZUJ5V2luZG93U2Nyb2xsIiwidXBkYXRlVmlld3BvcnRNYXhTY3JvbGwiLCJtb3ZlVXAiLCJtb3ZlRG93biIsIm1vdmVSaWdodCIsIm1vdmVMZWZ0IiwiZmx1c2giLCJhbmltYXRlRHJvcCIsImNvbXBsZXRlRHJvcCIsImRyb3AiLCJkcm9wQW5pbWF0aW9uRmluaXNoZWQiLCJjaGVja0luZGV4ZXMiLCJpbmRleGVzIiwiZXJyb3JzIiwia2V5cyIsImZvcm1hdHRlZCIsImhhc0Vycm9yIiwiam9pbiIsInZhbGlkYXRlRGltZW5zaW9ucyIsImxpZnQiLCJtYXJzaGFsIiwiZ2V0U3RhdGUiLCJkaXNwYXRjaCIsIm5leHQiLCJzY3JvbGxPcHRpb25zIiwic2hvdWxkUHVibGlzaEltbWVkaWF0ZWx5IiwicmVxdWVzdCIsInN0YXJ0UHVibGlzaGluZyIsInN0eWxlIiwiZHJhZ2dpbmciLCJkcm9wcGluZyIsInJlc3RpbmciLCJjdXJ2ZXMiLCJvdXRPZlRoZVdheSIsIm9wYWNpdHkiLCJjb21iaW5pbmciLCJzY2FsZSIsInRpbWluZ3MiLCJtaW5Ecm9wVGltZSIsIm1heERyb3BUaW1lIiwib3V0T2ZUaGVXYXlUaW1pbmciLCJ0cmFuc2l0aW9ucyIsImZsdWlkIiwic25hcCIsImR1cmF0aW9uIiwidGltaW5nIiwibW92ZVRvIiwidW5kZWZpbmVkIiwidHJhbnNmb3JtcyIsImlzQ29tYmluaW5nIiwidHJhbnNsYXRlIiwiZHJvcFRpbWVSYW5nZSIsIm1heERyb3BUaW1lQXREaXN0YW5jZSIsImNhbmNlbERyb3BNb2RpZmllciIsImdldERyb3BEdXJhdGlvbiIsImRpc3RhbmNlJDEiLCJwZXJjZW50YWdlIiwid2l0aER1cmF0aW9uIiwidG9GaXhlZCIsImdldE5ld0hvbWVDbGllbnRPZmZzZXQiLCJuZXdDbGllbnRDZW50ZXIiLCJnZXREcm9wSW1wYWN0IiwibGFzdEltcGFjdCIsInJlY29tcHV0ZWRIb21lSW1wYWN0IiwiZGlkRHJvcEluc2lkZURyb3BwYWJsZSIsIndpdGhvdXRNb3ZlbWVudCIsImRyb3BNaWRkbGV3YXJlIiwiaXNXYWl0aW5nRm9yRHJvcCIsImlzQW5pbWF0aW9uUmVxdWlyZWQiLCJnZXRXaW5kb3dTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmluZGluZyIsInBhc3NpdmUiLCJjYXB0dXJlIiwiZG9jdW1lbnQiLCJnZXRTY3JvbGxMaXN0ZW5lciIsIm9uV2luZG93U2Nyb2xsIiwidXBkYXRlU2Nyb2xsIiwic2NoZWR1bGVkIiwiaXNBY3RpdmUiLCJzdG9wIiwiY2FuY2VsIiwic2hvdWxkU3RvcCQxIiwic2Nyb2xsTGlzdGVuZXIiLCJzdG9yZSIsImxpc3RlbmVyIiwiZ2V0RXhwaXJpbmdBbm5vdW5jZSIsImFubm91bmNlIiwid2FzQ2FsbGVkIiwiaXNFeHBpcmVkIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImdldEFzeW5jTWFyc2hhbCIsImVudHJpZXMiLCJleGVjdXRlIiwidGltZXJJZCIsImVudHJ5Iiwic3BsaWNlIiwic2hhbGxvdyIsImFyZUxvY2F0aW9uc0VxdWFsIiwiaXNDb21iaW5lRXF1YWwiLCJpc0NyaXRpY2FsRXF1YWwiLCJpc0RyYWdnYWJsZUVxdWFsIiwiaXNEcm9wcGFibGVFcXVhbCIsIndpdGhUaW1pbmdzIiwiZ2V0RHJhZ1N0YXJ0IiwicmVzcG9uZGVyIiwiZGF0YSIsImdldERlZmF1bHRNZXNzYWdlIiwid2lsbEV4cGlyZSIsInByb3ZpZGVkIiwiZ2V0UHVibGlzaGVyIiwiZ2V0UmVzcG9uZGVycyIsImFzeW5jTWFyc2hhbCIsImJlZm9yZUNhcHR1cmUiLCJvbkJlZm9yZUNhcHR1cmUiLCJiZWZvcmVTdGFydCIsIm9uQmVmb3JlRHJhZ1N0YXJ0IiwibGFzdENyaXRpY2FsIiwibGFzdExvY2F0aW9uIiwibGFzdENvbWJpbmUiLCJoYXNDcml0aWNhbENoYW5nZWQiLCJoYXNMb2NhdGlvbkNoYW5nZWQiLCJoYXNHcm91cGluZ0NoYW5nZWQiLCJhYm9ydCIsInJlc3BvbmRlcnMiLCJwdWJsaXNoZXIiLCJkcm9wQW5pbWF0aW9uRmluaXNoTWlkZGxld2FyZSIsImRyb3BBbmltYXRpb25GbHVzaE9uU2Nyb2xsTWlkZGxld2FyZSIsImZyYW1lSWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm9uY2UiLCJmbHVzaERyb3BBbmltYXRpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkaW1lbnNpb25NYXJzaGFsU3RvcHBlciIsInN0b3BQdWJsaXNoaW5nIiwiZm9jdXMiLCJpc1dhdGNoaW5nIiwidHJ5UmVjb3JkRm9jdXMiLCJ0cnlSZXN0b3JlRm9jdXNSZWNvcmRlZCIsInRyeVNoaWZ0UmVjb3JkIiwic2hvdWxkU3RvcCIsImF1dG9TY3JvbGwiLCJhdXRvU2Nyb2xsZXIiLCJwZW5kaW5nRHJvcCIsInBvc3RBY3Rpb25TdGF0ZSIsImNvbXBvc2VFbmhhbmNlcnMiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJuYW1lIiwiZGltZW5zaW9uTWFyc2hhbCIsImZvY3VzTWFyc2hhbCIsInN0eWxlTWFyc2hhbCIsImNsZWFuJDEiLCJjcmVhdGVQdWJsaXNoZXIiLCJyZWdpc3RyeSIsInN0YWdpbmciLCJjb2xsZWN0IiwiZ2V0QnlJZCIsImdldERpbWVuc2lvbiIsImdldFNjcm9sbFdoaWxlRHJhZ2dpbmciLCJwdWJsaXNoIiwiZ2V0TWF4U2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJhZGp1c3RlZE1heFNjcm9sbCIsImdldERvY3VtZW50RWxlbWVudCIsImRvYyIsImRvY3VtZW50RWxlbWVudCIsImdldE1heFdpbmRvd1Njcm9sbCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZ2V0Vmlld3BvcnQiLCJnZXRJbml0aWFsUHVibGlzaCIsIndpbmRvd1Njcm9sbCIsImdldEFsbEJ5VHlwZSIsImdldERpbWVuc2lvbkFuZFdhdGNoU2Nyb2xsIiwic2hvdWxkUHVibGlzaFVwZGF0ZSIsImNyZWF0ZURpbWVuc2lvbk1hcnNoYWwiLCJjb2xsZWN0aW9uIiwiZXhpc3RzIiwiY2hhbmdlIiwiZHJhZ1N0b3BwZWQiLCJ1bnN1YnNjcmliZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5TdGFydERyYWciLCJzY3JvbGxXaW5kb3ciLCJzY3JvbGxCeSIsImdldFNjcm9sbGFibGVEcm9wcGFibGVzIiwiZ2V0U2Nyb2xsYWJsZURyb3BwYWJsZU92ZXIiLCJtYXliZSIsImdldEJlc3RTY3JvbGxhYmxlRHJvcHBhYmxlIiwiZGVmYXVsdEF1dG9TY3JvbGxlck9wdGlvbnMiLCJzdGFydEZyb21QZXJjZW50YWdlIiwibWF4U2Nyb2xsQXRQZXJjZW50YWdlIiwibWF4UGl4ZWxTY3JvbGwiLCJlYXNlIiwiZHVyYXRpb25EYW1wZW5pbmciLCJzdG9wRGFtcGVuaW5nQXQiLCJhY2NlbGVyYXRlQXQiLCJkaXNhYmxlZCIsImdldERpc3RhbmNlVGhyZXNob2xkcyIsImNvbnRhaW5lciIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJhdXRvU2Nyb2xsZXJPcHRpb25zIiwic3RhcnRTY3JvbGxpbmdGcm9tIiwibWF4U2Nyb2xsVmFsdWVBdCIsInRocmVzaG9sZHMiLCJnZXRQZXJjZW50YWdlIiwic3RhcnRPZlJhbmdlIiwiZW5kT2ZSYW5nZSIsInJhbmdlIiwiY3VycmVudEluUmFuZ2UiLCJtaW5TY3JvbGwiLCJnZXRWYWx1ZUZyb21EaXN0YW5jZSIsImRpc3RhbmNlVG9FZGdlIiwicGVyY2VudGFnZUZyb21NYXhTY3JvbGxWYWx1ZUF0IiwicGVyY2VudGFnZUZyb21TdGFydFNjcm9sbGluZ0Zyb20iLCJjZWlsIiwiZGFtcGVuVmFsdWVCeVRpbWUiLCJwcm9wb3NlZFNjcm9sbCIsImRyYWdTdGFydFRpbWUiLCJzdG9wQXQiLCJEYXRlIiwicnVuVGltZSIsImJldHdlZW5BY2NlbGVyYXRlQXRBbmRTdG9wQXRQZXJjZW50YWdlIiwiZ2V0VmFsdWUiLCJzaG91bGRVc2VUaW1lRGFtcGVuaW5nIiwiZ2V0U2Nyb2xsT25BeGlzIiwiZGlzdGFuY2VUb0VkZ2VzIiwiaXNDbG9zZXJUb0VuZCIsImFkanVzdEZvclNpemVMaW1pdHMiLCJpc1Rvb0JpZ1ZlcnRpY2FsbHkiLCJpc1Rvb0JpZ0hvcml6b250YWxseSIsImNsZWFuIiwiZ2V0U2Nyb2xsJDEiLCJyZXF1aXJlZCIsImxpbWl0ZWQiLCJzbWFsbGVzdFNpZ25lZCIsImdldE92ZXJsYXAiLCJnZXRSZW1haW5kZXIiLCJ0YXJnZXRTY3JvbGwiLCJvdmVybGFwIiwiY2FuUGFydGlhbGx5U2Nyb2xsIiwicmF3TWF4Iiwic21hbGxlc3RDaGFuZ2UiLCJjYW5TY3JvbGxXaW5kb3ciLCJnZXRXaW5kb3dPdmVybGFwIiwiY2FuU2Nyb2xsRHJvcHBhYmxlIiwiZ2V0RHJvcHBhYmxlT3ZlcmxhcCIsImdldFdpbmRvd1Njcm9sbENoYW5nZSIsImdldERyb3BwYWJsZVNjcm9sbENoYW5nZSIsImNyZWF0ZUZsdWlkU2Nyb2xsZXIiLCJzY2hlZHVsZVdpbmRvd1Njcm9sbCIsInNjaGVkdWxlRHJvcHBhYmxlU2Nyb2xsIiwidHJ5U2Nyb2xsIiwic3RhcnQkMSIsIndhc1Njcm9sbE5lZWRlZCIsImZha2VTY3JvbGxDYWxsYmFjayIsImNyZWF0ZUp1bXBTY3JvbGxlciIsIm1vdmVCeU9mZnNldCIsInNjcm9sbERyb3BwYWJsZUFzTXVjaEFzSXRDYW4iLCJ3aGF0VGhlRHJvcHBhYmxlQ2FuU2Nyb2xsIiwicmVtYWluZGVyIiwic2Nyb2xsV2luZG93QXNNdWNoQXNJdENhbiIsIndoYXRUaGVXaW5kb3dDYW5TY3JvbGwiLCJqdW1wU2Nyb2xsZXIiLCJkcm9wcGFibGVSZW1haW5kZXIiLCJ3aW5kb3dSZW1haW5kZXIiLCJjcmVhdGVBdXRvU2Nyb2xsZXIiLCJmbHVpZFNjcm9sbGVyIiwianVtcFNjcm9sbCIsInNjcm9sbGVyIiwicHJlZml4IiwiZHJhZ0hhbmRsZSIsImJhc2UiLCJjb250ZXh0SWQiLCJzY3JvbGxDb250YWluZXIiLCJtYWtlR2V0U2VsZWN0b3IiLCJjb250ZXh0IiwiYXR0cmlidXRlIiwiZ2V0U3R5bGVzIiwicnVsZXMiLCJwcm9wZXJ0eSIsInJ1bGUiLCJzdHlsZXMiLCJzZWxlY3RvciIsIm5vUG9pbnRlckV2ZW50cyIsImdldFN0eWxlcyQxIiwiZ2V0U2VsZWN0b3IiLCJkcmFnSGFuZGxlJDEiLCJncmFiQ3Vyc29yIiwiYWx3YXlzIiwiZHJvcEFuaW1hdGluZyIsImRyYWdnYWJsZSQxIiwidHJhbnNpdGlvbiIsInVzZXJDYW5jZWwiLCJkcm9wcGFibGUkMSIsImJvZHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlRWxlbWVudCIsImdldEhlYWQiLCJoZWFkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZVN0eWxlRWwiLCJub25jZSIsInNldEF0dHJpYnV0ZSIsInVzZVN0eWxlTWFyc2hhbCIsImFsd2F5c1JlZiIsImR5bmFtaWNSZWYiLCJzZXREeW5hbWljU3R5bGUiLCJ0ZXh0Q29udGVudCIsInNldEFsd2F5c1N0eWxlIiwiZHluYW1pYyIsImFwcGVuZENoaWxkIiwicmVmIiwicmVtb3ZlQ2hpbGQiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyZW50Tm9kZSIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd0Zyb21FbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImlzSHRtbEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImZpbmREcmFnSGFuZGxlIiwicG9zc2libGUiLCJoYW5kbGUiLCJnZXRBdHRyaWJ1dGUiLCJ1c2VGb2N1c01hcnNoYWwiLCJlbnRyaWVzUmVmIiwicmVjb3JkUmVmIiwicmVzdG9yZUZvY3VzRnJhbWVSZWYiLCJpc01vdW50ZWRSZWYiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJ0cnlHaXZlRm9jdXMiLCJ0cnlHaXZlRm9jdXNUbyIsImFjdGl2ZUVsZW1lbnQiLCJyZWRpcmVjdFRvIiwicmVjb3JkIiwiZm9jdXNlZCIsImNsZWFyRnJhbWVPblVubW91bnQiLCJjcmVhdGVSZWdpc3RyeSIsInN1YnNjcmliZXJzIiwiY2IiLCJub3RpZnkiLCJmaW5kRHJhZ2dhYmxlQnlJZCIsImdldERyYWdnYWJsZUJ5SWQiLCJkcmFnZ2FibGVBUEkiLCJ1bmlxdWVJZCIsImZpbmRCeUlkIiwiZmluZERyb3BwYWJsZUJ5SWQiLCJnZXREcm9wcGFibGVCeUlkIiwiZHJvcHBhYmxlQVBJIiwidXNlUmVnaXN0cnkiLCJ1bm1vdW50IiwiU3RvcmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImdldEJvZHlFbGVtZW50IiwidmlzdWFsbHlIaWRkZW4iLCJib3JkZXIiLCJwYWRkaW5nIiwib3ZlcmZsb3ciLCJnZXRJZCIsInVzZUFubm91bmNlciIsInNldHVwIiwiY2xlYW51cCIsImRlZmF1bHRzIiwic2VwYXJhdG9yIiwidXNlVW5pcXVlSWQiLCJ1c2VJZCIsImdldEVsZW1lbnRJZCIsInVzZUhpZGRlblRleHRFbGVtZW50IiwidGV4dCIsIm1vdW50IiwiZGlzcGxheSIsIkFwcENvbnRleHQiLCJwZWVyRGVwZW5kZW5jaWVzIiwicmVhY3QiLCJzZW12ZXIiLCJnZXRWZXJzaW9uIiwiZXhlYyIsIm1ham9yIiwibWlub3IiLCJyYXciLCJpc1NhdGlzZmllZCIsImV4cGVjdGVkIiwiYWN0dWFsIiwiY2hlY2tSZWFjdFZlcnNpb24iLCJwZWVyRGVwVmFsdWUiLCJhY3R1YWxWYWx1ZSIsInBlZXJEZXAiLCJzdWZmaXgiLCJjaGVja0RvY3R5cGUiLCJkb2N0eXBlIiwidG9Mb3dlckNhc2UiLCJwdWJsaWNJZCIsInVzZURldiIsInVzZUhvb2siLCJ1c2VEZXZTZXR1cFdhcm5pbmciLCJlIiwidXNlU3RhcnR1cFZhbGlkYXRpb24iLCJ2ZXJzaW9uIiwidXNlUHJldmlvdXMiLCJjcmVhdGUiLCJsb2NrIiwiaXNDbGFpbWVkIiwiY2xhaW0iLCJhYmFuZG9uIiwibmV3TG9jayIsInJlbGVhc2UiLCJ0cnlBYmFuZG9uIiwidGFiIiwiZW50ZXIiLCJlc2NhcGUiLCJzcGFjZSIsInBhZ2VVcCIsInBhZ2VEb3duIiwiYXJyb3dMZWZ0IiwiYXJyb3dVcCIsImFycm93UmlnaHQiLCJhcnJvd0Rvd24iLCJwcmV2ZW50ZWRLZXlzIiwicHJldmVudFN0YW5kYXJkS2V5RXZlbnRzIiwia2V5Q29kZSIsInN1cHBvcnRlZEV2ZW50TmFtZSIsInN1cHBvcnRlZCIsInByaW1hcnlCdXR0b24iLCJzbG9wcHlDbGlja1RocmVzaG9sZCIsImlzU2xvcHB5Q2xpY2tUaHJlc2hvbGRFeGNlZWRlZCIsImFicyIsImlkbGUkMSIsImdldENhcHR1cmVCaW5kaW5ncyIsImdldFBoYXNlIiwic2V0UGhhc2UiLCJidXR0b24iLCJjbGllbnRYIiwiY2xpZW50WSIsImFjdGlvbnMiLCJwZW5kaW5nIiwiZmx1aWRMaWZ0Iiwic2hvdWxkQmxvY2tOZXh0Q2xpY2siLCJzaG91bGRSZXNwZWN0Rm9yY2VQcmVzcyIsInVzZU1vdXNlU2Vuc29yIiwiYXBpIiwicGhhc2VSZWYiLCJ1bmJpbmRFdmVudHNSZWYiLCJzdGFydENhcHR1cmVCaW5kaW5nIiwib25Nb3VzZURvd24iLCJkZWZhdWx0UHJldmVudGVkIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsImZpbmRDbG9zZXN0RHJhZ2dhYmxlSWQiLCJ0cnlHZXRMb2NrIiwic291cmNlRXZlbnQiLCJzdGFydFBlbmRpbmdEcmFnIiwicHJldmVudEZvcmNlUHJlc3NCaW5kaW5nIiwiZmluZE9wdGlvbnNGb3JEcmFnZ2FibGUiLCJjYW5HZXRMb2NrIiwibGlzdGVuRm9yQ2FwdHVyZSIsImJpbmRDYXB0dXJpbmdFdmVudHMiLCJub29wJDEiLCJzY3JvbGxKdW1wS2V5cyIsImdldERyYWdnaW5nQmluZGluZ3MiLCJ1c2VLZXlib2FyZFNlbnNvciIsIm9uS2V5RG93biIsInByZURyYWciLCJpc0NhcHR1cmluZyIsInNuYXBMaWZ0IiwidHJ5U3RhcnRDYXB0dXJlIiwiaWRsZSIsInRpbWVGb3JMb25nUHJlc3MiLCJmb3JjZVByZXNzVGhyZXNob2xkIiwiZ2V0V2luZG93QmluZGluZ3MiLCJnZXRIYW5kbGVCaW5kaW5ncyIsImhhc01vdmVkIiwidG91Y2hlcyIsInRvdWNoIiwiaXNGb3JjZVByZXNzIiwiZm9yY2UiLCJzaG91bGRSZXNwZWN0IiwidXNlVG91Y2hTZW5zb3IiLCJvblRvdWNoU3RhcnQiLCJsb25nUHJlc3NUaW1lcklkIiwidW5iaW5kVGFyZ2V0IiwidW5iaW5kV2luZG93Iiwic3RhcnREcmFnZ2luZyIsIndlYmtpdEhhY2siLCJ1c2VWYWxpZGF0ZVNlbnNvckhvb2tzIiwic2Vuc29ySG9va3MiLCJwcmV2aW91c1JlZiIsImludGVyYWN0aXZlVGFnTmFtZXMiLCJpc0FuSW50ZXJhY3RpdmVFbGVtZW50IiwicGFyZW50IiwiaGFzQW5JbnRlcmFjdGl2ZVRhZyIsImluY2x1ZGVzIiwidGFnTmFtZSIsInBhcmVudEVsZW1lbnQiLCJpc0V2ZW50SW5JbnRlcmFjdGl2ZUVsZW1lbnQiLCJnZXRCb3JkZXJCb3hDZW50ZXJQb3NpdGlvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJzdXBwb3J0ZWRNYXRjaGVzTmFtZSIsImNsb3Nlc3RQb255ZmlsbCIsImZpbmRDbG9zZXN0RHJhZ0hhbmRsZUZyb21FdmVudCIsInRyeUdldENsb3Nlc3REcmFnZ2FibGVJZEZyb21FdmVudCIsImZpbmREcmFnZ2FibGUiLCJpc0xvY2tBY3RpdmUiLCJzaG91bGRXYXJuIiwiY2FuU3RhcnQiLCJsb2NrQVBJIiwidHJ5U3RhcnQiLCJmb3JjZVNlbnNvclN0b3AiLCJzaG91bGRTdGFydCIsImNhbkRyYWdJbnRlcmFjdGl2ZUVsZW1lbnRzIiwiZ2V0U2hvdWxkUmVzcGVjdEZvcmNlUHJlc3MiLCJ0cnlEaXNwYXRjaCIsImdldEFjdGlvbiIsInRyeURpc3BhdGNoV2hlbkRyYWdnaW5nIiwibGlmdEFjdGlvbkFyZ3MiLCJtb3ZlJDEiLCJhYm9ydFByZURyYWciLCJzaG91bGRSZWxlYXNlIiwiZGVmYXVsdFNlbnNvcnMiLCJ1c2VTZW5zb3JNYXJzaGFsIiwiY3VzdG9tU2Vuc29ycyIsImVuYWJsZURlZmF1bHRTZW5zb3JzIiwidXNlU2Vuc29ycyIsInRyeUFiYW5kb25Mb2NrIiwibGlzdGVuVG9TdG9yZSIsImZvcmNlU3RvcCIsInRyeVJlbGVhc2VMb2NrIiwiaXNMb2NrQ2xhaW1lZCIsImNyZWF0ZVJlc3BvbmRlcnMiLCJ0Iiwib25CZWZvcmVDYXB1cmVDYWxsYmFjayIsImNyZWF0ZUF1dG9TY3JvbGxlck9wdGlvbnMiLCJnZXRTdG9yZSIsImxhenlSZWYiLCJBcHAiLCJzZW5zb3JzIiwibGF6eVN0b3JlUmVmIiwibGFzdFByb3BzUmVmIiwiZHJhZ0hhbmRsZVVzYWdlSW5zdHJ1Y3Rpb25zSWQiLCJsYXp5RGlzcGF0Y2giLCJtYXJzaGFsQ2FsbGJhY2tzIiwidHJ5UmVzZXRTdG9yZSIsImFwcENhbGxiYWNrcyIsImdldENhbkxpZnQiLCJnZXRJc01vdmVtZW50QWxsb3dlZCIsImFwcENvbnRleHQiLCJjYW5MaWZ0IiwidXNlVW5pcXVlQ29udGV4dElkIiwiRHJhZ0Ryb3BDb250ZXh0IiwiekluZGV4T3B0aW9ucyIsImdldERyYWdnaW5nVHJhbnNpdGlvbiIsInNob3VsZEFuaW1hdGVEcmFnTW92ZW1lbnQiLCJnZXREcmFnZ2luZ09wYWNpdHkiLCJpc0Ryb3BBbmltYXRpbmciLCJnZXRTaG91bGREcmFnZ2luZ0FuaW1hdGUiLCJnZXREcmFnZ2luZ1N0eWxlIiwidHJhbnNmb3JtIiwiYm94U2l6aW5nIiwiekluZGV4IiwicG9pbnRlckV2ZW50cyIsImdldFNlY29uZGFyeVN0eWxlIiwic2Vjb25kYXJ5Iiwic2hvdWxkQW5pbWF0ZURpc3BsYWNlbWVudCIsImdldFN0eWxlJDEiLCJtYXBwZWQiLCJnZXREaW1lbnNpb24kMSIsImNvbXB1dGVkU3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInVzZURyYWdnYWJsZVB1Ymxpc2hlciIsImdldERyYWdnYWJsZVJlZiIsInB1Ymxpc2hlZFJlZiIsImlzRmlyc3RQdWJsaXNoUmVmIiwiRHJvcHBhYmxlQ29udGV4dCIsImNoZWNrSXNWYWxpZElubmVyUmVmIiwidXNlVmFsaWRhdGlvbiQxIiwiZ2V0UmVmIiwiaXNJbnRlZ2VyIiwidXNlQ2xvbmVQcm9wVmFsaWRhdGlvbiIsImlzQ2xvbmUiLCJpbml0aWFsUmVmIiwidXNlUmVxdWlyZWRDb250ZXh0IiwiQ29udGV4dCIsInByZXZlbnRIdG1sNURuZCIsIkRyYWdnYWJsZSIsInNldFJlZiIsImRyb3BBbmltYXRpb25GaW5pc2hlZEFjdGlvbiIsImZvclB1Ymxpc2hlciIsImRyYWdIYW5kbGVQcm9wcyIsInRhYkluZGV4Iiwicm9sZSIsIm9uTW92ZUVuZCIsInByb3BlcnR5TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsImlubmVyUmVmIiwiZHJhZ2dhYmxlUHJvcHMiLCJydWJyaWMiLCJGcmFnbWVudCIsInNuYXBzaG90IiwiaXNTdHJpY3RFcXVhbCIsIndoYXRJc0RyYWdnZWRPdmVyRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbVJlc3VsdCIsImdldENvbWJpbmVXaXRoRnJvbUltcGFjdCIsImdldERyYWdnYWJsZVNlbGVjdG9yIiwibWVtb2l6ZWRPZmZzZXQiLCJnZXRNZW1vaXplZFNuYXBzaG90IiwiZHJhZ2dpbmdPdmVyIiwiZHJvcEFuaW1hdGlvbiIsImNvbWJpbmVUYXJnZXRGb3IiLCJnZXRNZW1vaXplZFByb3BzIiwib3duUHJvcHMiLCJjdXJ2ZSIsImdldFNlY29uZGFyeVNuYXBzaG90IiwiYXRSZXN0IiwiZ2V0U2Vjb25kYXJ5U2VsZWN0b3IiLCJnZXRGYWxsYmFjayIsImdldFByb3BzIiwib3duSWQiLCJkcmFnZ2luZ0lkIiwidmlzdWFsRGlzcGxhY2VtZW50IiwiaXNBZnRlckNyaXRpY2FsSW5WaXJ0dWFsTGlzdCIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMkMSIsImRyYWdnaW5nU2VsZWN0b3IiLCJzZWNvbmRhcnlTZWxlY3RvciIsIm1hcERpc3BhdGNoVG9Qcm9wcyQxIiwiQ29ubmVjdGVkRHJhZ2dhYmxlIiwiYXJlU3RhdGVQcm9wc0VxdWFsIiwiUHJpdmF0ZURyYWdnYWJsZSIsImRyb3BwYWJsZUNvbnRleHQiLCJpc1VzaW5nQ2xvbmVGb3IiLCJQdWJsaWNEcmFnZ2FibGUiLCJpc0RyYWdEaXNhYmxlZCIsImRpc2FibGVJbnRlcmFjdGl2ZUVsZW1lbnRCbG9ja2luZyIsImlzU2Nyb2xsIiwiaXNBdXRvIiwiaXNFaXRoZXIiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJpc0JvdGgiLCJpc0VsZW1lbnRTY3JvbGxhYmxlIiwiaXNCb2R5U2Nyb2xsYWJsZSIsImh0bWwiLCJodG1sU3R5bGUiLCJodG1sT3ZlcmZsb3ciLCJnZXRDbG9zZXN0U2Nyb2xsYWJsZSIsImNoZWNrRm9yTmVzdGVkU2Nyb2xsQ29udGFpbmVycyIsImFub3RoZXJTY3JvbGxQYXJlbnQiLCJnZXRTY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiZ2V0SXNGaXhlZCIsImdldEVudiIsImNsb3Nlc3RTY3JvbGxhYmxlIiwiZ2V0RHJvcHBhYmxlRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsImZyYW1lQ2xpZW50IiwicGFkZGluZ0JveCIsImdldENsaWVudCIsInRhcmdldFJlZiIsImVudiIsImlzRHJvcERpc2FibGVkIiwiaW1tZWRpYXRlIiwiZGVsYXllZCIsImdldExpc3RlbmVyT3B0aW9ucyIsImdldENsb3Nlc3RTY3JvbGxhYmxlRnJvbURyYWciLCJ1c2VEcm9wcGFibGVQdWJsaXNoZXIiLCJ3aGlsZURyYWdnaW5nUmVmIiwicHVibGlzaGVkRGVzY3JpcHRvclJlZiIsIm1lbW9pemVkVXBkYXRlU2Nyb2xsIiwiZ2V0Q2xvc2VzdFNjcm9sbCIsInNjaGVkdWxlU2Nyb2xsVXBkYXRlIiwib25DbG9zZXN0U2Nyb2xsIiwiZ2V0RHJvcHBhYmxlUmVmIiwiaWdub3JlQ29udGFpbmVyQ2xpcHBpbmciLCJyZW1vdmVBdHRyaWJ1dGUiLCJub29wIiwiZW1wdHkiLCJnZXRTaXplIiwiaXNBbmltYXRpbmdPcGVuT25Nb3VudCIsImFuaW1hdGUiLCJnZXRTdHlsZSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZsZXhTaHJpbmsiLCJmbGV4R3JvdyIsIlBsYWNlaG9sZGVyIiwiYW5pbWF0ZU9wZW5UaW1lclJlZiIsInRyeUNsZWFyQW5pbWF0ZU9wZW5UaW1lciIsIm9uQ2xvc2UiLCJzZXRJc0FuaW1hdGluZ09wZW5Pbk1vdW50Iiwib25TaXplQ2hhbmdlRW5kIiwiUGxhY2Vob2xkZXIkMSIsIm1lbW8iLCJpc0Jvb2xlYW4iLCJydW5DaGVja3MiLCJjaGVja3MiLCJjaGVjayIsImJvb2xlYW4iLCJzdGFuZGFyZCIsImdldFBsYWNlaG9sZGVyUmVmIiwidmlydHVhbCIsImhhc0Nsb25lIiwicmVuZGVyQ2xvbmUiLCJoYXNOb1BsYWNlaG9sZGVyIiwidXNlVmFsaWRhdGlvbiIsIkFuaW1hdGVJbk91dCIsIlB1cmVDb21wb25lbnQiLCJvbiIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIkRyb3BwYWJsZSIsImRyb3BwYWJsZVJlZiIsInBsYWNlaG9sZGVyUmVmIiwidXNlQ2xvbmUiLCJnZXRDb250YWluZXJGb3JDbG9uZSIsInNldERyb3BwYWJsZVJlZiIsInNldFBsYWNlaG9sZGVyUmVmIiwib25QbGFjZWhvbGRlclRyYW5zaXRpb25FbmQiLCJzaG91bGRBbmltYXRlUGxhY2Vob2xkZXIiLCJkcm9wcGFibGVQcm9wcyIsImdldENsb25lIiwibm9kZSIsImRyYWdnYWJsZVByb3ZpZGVkIiwiZHJhZ2dhYmxlU25hcHNob3QiLCJjcmVhdGVQb3J0YWwiLCJnZXRCb2R5IiwiZGVmYXVsdFByb3BzIiwiYXR0YWNoRGVmYXVsdFByb3BzVG9Pd25Qcm9wcyIsIm1lcmdlZFByb3BzIiwiZGVmYXVsdFByb3BLZXkiLCJpc01hdGNoaW5nVHlwZSIsImdldERyYWdnYWJsZSIsIm1ha2VNYXBTdGF0ZVRvUHJvcHMiLCJpZGxlV2l0aEFuaW1hdGlvbiIsImlzRHJhZ2dpbmdPdmVyIiwiZHJhZ2dpbmdPdmVyV2l0aCIsImRyYWdnaW5nRnJvbVRoaXNXaXRoIiwiaXNVc2luZ1BsYWNlaG9sZGVyIiwiaWRsZVdpdGhvdXRBbmltYXRpb24iLCJnZXREcmFnZ2FibGVSdWJyaWMiLCJnZXRNYXBQcm9wcyIsImlzRHJhZ2dpbmdPdmVyRm9yQ29uc3VtZXIiLCJpc0RyYWdnaW5nT3ZlckZvckltcGFjdCIsImlzSG9tZSIsIm93blByb3BzV2l0aERlZmF1bHRQcm9wcyIsIndhc0NvbWJpbmluZyIsIm1hcERpc3BhdGNoVG9Qcm9wcyIsIkNvbm5lY3RlZERyb3BwYWJsZSIsInN0YXRlUHJvcHMiLCJkaXNwYXRjaFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/dist/dnd.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/node_modules/react-redux/dist/react-redux.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/node_modules/react-redux/dist/react-redux.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\n\n// src/utils/react-is.ts\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(IS_REACT_19 ? \"react.transitional.element\" : \"react.element\");\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const { $$typeof } = object;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                switch(object = object.type, object){\n                    case REACT_FRAGMENT_TYPE:\n                    case REACT_PROFILER_TYPE:\n                    case REACT_STRICT_MODE_TYPE:\n                    case REACT_SUSPENSE_TYPE:\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return object;\n                    default:\n                        switch(object = object && object.$$typeof, object){\n                            case REACT_CONTEXT_TYPE:\n                            case REACT_FORWARD_REF_TYPE:\n                            case REACT_LAZY_TYPE:\n                            case REACT_MEMO_TYPE:\n                                return object;\n                            case REACT_CONSUMER_TYPE:\n                                return object;\n                            default:\n                                return $$typeof;\n                        }\n                }\n            case REACT_PORTAL_TYPE:\n                return $$typeof;\n        }\n    }\n}\nfunction isContextConsumer(object) {\n    return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(`Unexpected value for ${methodName} in connect.`);\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, { displayName }) {\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = ()=>!!( false && 0);\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = ()=>typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = ()=>isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/Context.ts\nvar ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n    const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();\n    let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n    if (!realContext) {\n        realContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/components/connect.tsx\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n// @ts-ignore\npure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\nforwardRef = false, // the context consumer to use\ncontext = ReactReduxContext } = {}) {\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = `Connect(${wrappedComponentName})`;\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext?.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n            const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        const _Connect = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider(providerProps) {\n    const { children, context, serverState, store } = providerProps;\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const subscription = createSubscription(store);\n        const baseContextValue = {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0\n        };\n        if (false) {} else {\n            const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\n            return /* @__PURE__ */ Object.assign(baseContextValue, {\n                stabilityCheck,\n                identityFunctionCheck\n            });\n        }\n    }, [\n        store,\n        serverState\n    ]);\n    const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nvar Provider_default = Provider;\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n    return function useReduxContext2() {\n        const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        const { store } = useReduxContext2();\n        return store;\n    };\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        const store = useStore2();\n        return store.dispatch;\n    };\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/hooks/useSelector.ts\n\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = (selector, equalityFnOrOptions = {})=>{\n        const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(`You must pass a selector to useSelector`);\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(`You must pass a function as a selector to useSelector`);\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(`You must pass a function as an equality function to useSelector`);\n            }\n        }\n        const reduxContext = useReduxContext2();\n        const { store, subscription, getServerState } = reduxContext;\n        const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n        const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n                    const { identityFunctionCheck, stabilityCheck } = reduxContext;\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector\n        ]);\n        const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\n        return selectedState;\n    };\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n //# sourceMappingURL=react-redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2Rpc3QvcmVhY3QtcmVkdXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDVTtBQUUvQix3QkFBd0I7QUFDeEIsSUFBSUMsY0FBYyxhQUFhLEdBQUdELDBDQUFhLENBQUNHLFVBQVUsQ0FBQztBQUMzRCxJQUFJQyxxQkFBcUIsYUFBYSxHQUFHQyxPQUFPQyxHQUFHLENBQ2pETCxjQUFjLCtCQUErQjtBQUUvQyxJQUFJTSxvQkFBb0IsYUFBYSxHQUFHRixPQUFPQyxHQUFHLENBQUM7QUFDbkQsSUFBSUUsc0JBQXNCLGFBQWEsR0FBR0gsT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlHLHlCQUF5QixhQUFhLEdBQUdKLE9BQU9DLEdBQUcsQ0FBQztBQUN4RCxJQUFJSSxzQkFBc0IsYUFBYSxHQUFHTCxPQUFPQyxHQUFHLENBQUM7QUFDckQsSUFBSUssc0JBQXNCLGFBQWEsR0FBR04sT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlNLHFCQUFxQixhQUFhLEdBQUdQLE9BQU9DLEdBQUcsQ0FBQztBQUNwRCxJQUFJTyx5QkFBeUIsYUFBYSxHQUFHUixPQUFPQyxHQUFHLENBQUM7QUFDeEQsSUFBSVEsc0JBQXNCLGFBQWEsR0FBR1QsT0FBT0MsR0FBRyxDQUFDO0FBQ3JELElBQUlTLDJCQUEyQixhQUFhLEdBQUdWLE9BQU9DLEdBQUcsQ0FDdkQ7QUFFRixJQUFJVSxrQkFBa0IsYUFBYSxHQUFHWCxPQUFPQyxHQUFHLENBQUM7QUFDakQsSUFBSVcsa0JBQWtCLGFBQWEsR0FBR1osT0FBT0MsR0FBRyxDQUFDO0FBQ2pELElBQUlZLHVCQUF1QixhQUFhLEdBQUdiLE9BQU9DLEdBQUcsQ0FBQztBQUN0RCxJQUFJYSx5QkFBeUIsYUFBYSxHQUFHZCxPQUFPQyxHQUFHLENBQ3JEO0FBRUYsSUFBSWMsYUFBYVA7QUFDakIsSUFB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OzRCQUN0QixJQUFJZ1AsUUFBUSxLQUFLOzRCQUNqQixJQUFJO2dDQUNGLE1BQU0sSUFBSW5ROzRCQUNaLEVBQUUsT0FBT0MsR0FBRzs7Z0NBRVQsR0FBRWtRLEtBQUssRUFBRSxHQUFHbFEsQ0FBQUE7NEJBQ2Y7NEJBQ0FILFFBQVFtVCxJQUFJLENBQ1YsY0FBZTlTLENBQUFBLFNBQVMwRSxJQUFJLElBQUksU0FBUSxJQUFLLDZOQUM3QztnQ0FBRXNMOzRCQUFNO3dCQUVaO29CQUNGO29CQUNBLElBQUlzQyxTQUFTekYsT0FBTyxFQUFFeUYsU0FBU3pGLE9BQU8sR0FBRztnQkFDM0M7Z0JBQ0EsT0FBTzRGO1lBQ1Q7UUFDRixDQUFDLENBQUN6UyxTQUFTMEUsSUFBSSxDQUFDLEVBQ2hCO1lBQUMxRTtTQUFTO1FBRVosTUFBTWdULGdCQUFnQmpCLDBHQUFnQ0EsQ0FDcEQ1SyxhQUFhUCxZQUFZLEVBQ3pCSixNQUFNK0csUUFBUSxFQUNkNkIsa0JBQWtCNUksTUFBTStHLFFBQVEsRUFDaENnRixpQkFDQUg7UUFFRnpVLGdEQUFtQixDQUFDcVY7UUFDcEIsT0FBT0E7SUFDVDtJQUNBOVMsT0FBT2dSLE1BQU0sQ0FBQ2dCLGNBQWM7UUFDMUJSLFdBQVcsSUFBTVE7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSWdCLGNBQWMsYUFBYSxHQUFHakI7QUFFbEMsaUJBQWlCO0FBQ2pCLElBQUlrQixRQUFRN047QUFhVixDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2R5bmFtaWMtZGF0YS10YWJsZS1tYW5hZ2VyLy4vbm9kZV9tb2R1bGVzL0BoZWxsby1wYW5nZWEvZG5kL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcz81MjJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xudmFyIElTX1JFQUNUXzE5ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LnZlcnNpb24uc3RhcnRzV2l0aChcIjE5XCIpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBJU19SRUFDVF8xOSA/IFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiA6IFwicmVhY3QuZWxlbWVudFwiXG4pO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIik7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBcInJlYWN0LnN1c3BlbnNlX2xpc3RcIlxuKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFxuICBcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIlxuKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSA/IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgY29uc3QgeyAkJHR5cGVvZiB9ID0gb2JqZWN0O1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBzd2l0Y2ggKG9iamVjdCA9IG9iamVjdC50eXBlLCBvYmplY3QpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdCA9IG9iamVjdCAmJiBvYmplY3QuJCR0eXBlb2YsIG9iamVjdCkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIElTX1JFQUNUXzE5ID8gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgOiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cblxuLy8gc3JjL3V0aWxzL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMudHNcbmZ1bmN0aW9uIHZlcmlmeShzZWxlY3RvciwgbWV0aG9kTmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYCk7XG4gIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gXCJtYXBTdGF0ZVRvUHJvcHNcIiB8fCBtZXRob2ROYW1lID09PSBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2VsZWN0b3IsIFwiZGVwZW5kc09uT3duUHJvcHNcIikpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGBUaGUgc2VsZWN0b3IgZm9yICR7bWV0aG9kTmFtZX0gb2YgY29ubmVjdCBkaWQgbm90IHNwZWNpZnkgYSB2YWx1ZSBmb3IgZGVwZW5kc09uT3duUHJvcHMuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICB2ZXJpZnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG4gIHZlcmlmeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS50c1xuZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCB7XG4gIGFyZVN0YXRlc0VxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWxcbn0pIHtcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIGxldCBzdGF0ZTtcbiAgbGV0IG93blByb3BzO1xuICBsZXQgc3RhdGVQcm9wcztcbiAgbGV0IGRpc3BhdGNoUHJvcHM7XG4gIGxldCBtZXJnZWRQcm9wcztcbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIGNvbnN0IG5leHRTdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgaWYgKHN0YXRlUHJvcHNDaGFuZ2VkKVxuICAgICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VkID0gIWFyZVN0YXRlc0VxdWFsKFxuICAgICAgbmV4dFN0YXRlLFxuICAgICAgc3RhdGUsXG4gICAgICBuZXh0T3duUHJvcHMsXG4gICAgICBvd25Qcm9wc1xuICAgICk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5mdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCB7XG4gIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gIGluaXRNZXJnZVByb3BzLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucyk7XG59XG5cbi8vIHNyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGxldCBiYXNlUHJvdG8gPSBwcm90bztcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XG59XG5cbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gdmVyaWZ5UGxhaW5PYmplY3QodmFsdWUsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgYCR7bWV0aG9kTmFtZX0oKSBpbiAke2Rpc3BsYXlOYW1lfSBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZCAke3ZhbHVlfS5gXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgICBjb25zdGFudFNlbGVjdG9yLmRlcGVuZHNPbk93blByb3BzID0gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnN0YW50U2VsZWN0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufVxuZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFRvUHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcbiAgICBjb25zdCBwcm94eSA9IGZ1bmN0aW9uIG1hcFRvUHJvcHNQcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICByZXR1cm4gcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPyBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIDogcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIHZvaWQgMCk7XG4gICAgfTtcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgbGV0IHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L2ludmFsaWRBcmdGYWN0b3J5LnRzXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShhcmcsIG5hbWUpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYXJnfSBmb3IgJHtuYW1lfSBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50ICR7b3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZX0uYFxuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcERpc3BhdGNoVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcbiAgICAoZGlzcGF0Y2gpID0+IChcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxuICAgIClcbiAgKSA6ICFtYXBEaXNwYXRjaFRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KChkaXNwYXRjaCkgPT4gKHtcbiAgICBkaXNwYXRjaFxuICB9KSkgOiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXG4gICkgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9tYXBTdGF0ZVRvUHJvcHMudHNcbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcbmZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiB7IC4uLm93blByb3BzLCAuLi5zdGF0ZVByb3BzLCAuLi5kaXNwYXRjaFByb3BzIH07XG59XG5mdW5jdGlvbiB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdE1lcmdlUHJvcHNQcm94eShkaXNwYXRjaCwgeyBkaXNwbGF5TmFtZSwgYXJlTWVyZ2VkUHJvcHNFcXVhbCB9KSB7XG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcbiAgICBsZXQgbWVyZ2VkUHJvcHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNSdW5PbmNlID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QobWVyZ2VkUHJvcHMsIGRpc3BsYXlOYW1lLCBcIm1lcmdlUHJvcHNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHNGYWN0b3J5KG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxuLy8gc3JjL3V0aWxzL1N1YnNjcmlwdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICBsZXQgZmlyc3QgPSBudWxsO1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeSgpIHtcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBsZXQgbGlzdGVuZXIgPSBmaXJzdDtcbiAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgcHJldjogbGFzdFxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsaXN0ZW5lci5uZXh0KSB7XG4gICAgICAgICAgbGlzdGVuZXIubmV4dC5wcmV2ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0ID0gbGlzdGVuZXIucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnkoKSB7XG4gIH0sXG4gIGdldDogKCkgPT4gW11cbn07XG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICBsZXQgdW5zdWJzY3JpYmU7XG4gIGxldCBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICBsZXQgc3Vic2NyaXB0aW9uc0Ftb3VudCA9IDA7XG4gIGxldCBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICBjb25zdCBjbGVhbnVwTGlzdGVuZXIgPSBsaXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXJlbW92ZWQpIHtcbiAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lcigpO1xuICAgICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlV3JhcHBlcigpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICByZXR1cm4gc2VsZlN1YnNjcmliZWQ7XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQrKztcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICB1bnN1YnNjcmliZSA9IHBhcmVudFN1YiA/IHBhcmVudFN1Yi5hZGROZXN0ZWRTdWIoaGFuZGxlQ2hhbmdlV3JhcHBlcikgOiBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICBsaXN0ZW5lcnMgPSBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudC0tO1xuICAgIGlmICh1bnN1YnNjcmliZSAmJiBzdWJzY3JpcHRpb25zQW1vdW50ID09PSAwKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgdW5zdWJzY3JpYmUgPSB2b2lkIDA7XG4gICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKCFzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0cnlVbnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgYWRkTmVzdGVkU3ViLFxuICAgIG5vdGlmeU5lc3RlZFN1YnMsXG4gICAgaGFuZGxlQ2hhbmdlV3JhcHBlcixcbiAgICBpc1N1YnNjcmliZWQsXG4gICAgdHJ5U3Vic2NyaWJlOiB0cnlTdWJzY3JpYmVTZWxmLFxuICAgIHRyeVVuc3Vic2NyaWJlOiB0cnlVbnN1YnNjcmliZVNlbGYsXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcbiAgfTtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QudHNcbnZhciBjYW5Vc2VET00gPSAoKSA9PiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbnZhciBpc0RPTSA9IC8qIEBfX1BVUkVfXyAqLyBjYW5Vc2VET00oKTtcbnZhciBpc1J1bm5pbmdJblJlYWN0TmF0aXZlID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xudmFyIGlzUmVhY3ROYXRpdmUgPSAvKiBAX19QVVJFX18gKi8gaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSgpO1xudmFyIGdldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAoKSA9PiBpc0RPTSB8fCBpc1JlYWN0TmF0aXZlID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSAvKiBAX19QVVJFX18gKi8gZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgpO1xuXG4vLyBzcmMvdXRpbHMvc2hhbGxvd0VxdWFsLnRzXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3V0aWxzL2hvaXN0U3RhdGljcy50c1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJCR0eXBlb2Y6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XG4gIFtGb3J3YXJkUmVmXTogRk9SV0FSRF9SRUZfU1RBVElDUyxcbiAgW01lbW9dOiBNRU1PX1NUQVRJQ1Ncbn07XG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICBpZiAoaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9XG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50W1wiJCR0eXBlb2ZcIl1dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBjb25zdCBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgY29uc3Qgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9Db250ZXh0LnRzXG52YXIgQ29udGV4dEtleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dCkgcmV0dXJuIHt9O1xuICBjb25zdCBjb250ZXh0TWFwID0gZ1RbQ29udGV4dEtleV0gPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZWFsQ29udGV4dCA9IGNvbnRleHRNYXAuZ2V0KFJlYWN0LmNyZWF0ZUNvbnRleHQpO1xuICBpZiAoIXJlYWxDb250ZXh0KSB7XG4gICAgcmVhbENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVhbENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJlYWN0UmVkdXhcIjtcbiAgICB9XG4gICAgY29udGV4dE1hcC5zZXQoUmVhY3QuY3JlYXRlQ29udGV4dCwgcmVhbENvbnRleHQpO1xuICB9XG4gIHJldHVybiByZWFsQ29udGV4dDtcbn1cbnZhciBSZWFjdFJlZHV4Q29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRDb250ZXh0KCk7XG5cbi8vIHNyYy9jb21wb25lbnRzL2Nvbm5lY3QudHN4XG52YXIgTk9fU1VCU0NSSVBUSU9OX0FSUkFZID0gW251bGwsIG51bGxdO1xudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGVmZmVjdEZ1bmMoLi4uZWZmZWN0QXJncyksIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xuICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50KSB7XG4gICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbnVsbDtcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiAoKSA9PiB7XG4gIH07XG4gIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xuICBsZXQgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgY29uc3QgY2hlY2tGb3JVcGRhdGVzID0gKCkgPT4ge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgbGV0IG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuICAgIHRyeSB7XG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxuICAgICAgICBsYXRlc3RTdG9yZVN0YXRlLFxuICAgICAgICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9O1xuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IG51bGw7XG4gICAgaWYgKGxhc3RUaHJvd25FcnJvcikge1xuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn1cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xuICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVyZSxcbiAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0XG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChwdXJlICE9PSB2b2lkIDAgJiYgIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24pIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSB0cnVlO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3Qgd3JhcFdpdGhDb25uZWN0ID0gKFdyYXBwZWRDb21wb25lbnQpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBjb25uZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7c3RyaW5naWZ5Q29tcG9uZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBgQ29ubmVjdCgke3dyYXBwZWRDb21wb25lbnROYW1lfSlgO1xuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wc0NvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgLi4ud3JhcHBlclByb3BzMiB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIHdyYXBwZXJQcm9wczJdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IFJlc3VsdENvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBpZiAocHJvcHNDb250ZXh0Py5Db25zdW1lcikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNDb250ZXh0Q29uc3VtZXIoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHNDb250ZXh0LkNvbnN1bWVyLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3QgY29udGV4dCBjb25zdW1lciBhcyBgcHJvcHMuY29udGV4dGBcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dCA9IHByb3BzQ29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc3VsdENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7XG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPSBCb29sZWFuKHByb3BzLnN0b3JlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmdldFN0YXRlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICB9LCBbc3RvcmVdKTtcbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSByZXR1cm4gTk9fU1VCU0NSSVBUSU9OX0FSUkFZO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxuICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHZvaWQgMCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgbm90aWZ5TmVzdGVkU3ViczIgPSBzdWJzY3JpcHRpb24yLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24yKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24yLCBub3RpZnlOZXN0ZWRTdWJzMl07XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XG4gICAgICBjb25zdCBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcbiAgICAgIGNvbnN0IGxhc3RDaGlsZFByb3BzID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCBsYXN0V3JhcHBlclByb3BzID0gUmVhY3QudXNlUmVmKHdyYXBwZXJQcm9wcyk7XG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gICAgICBjb25zdCByZW5kZXJJc1NjaGVkdWxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZihcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgJiYgd3JhcHBlclByb3BzID09PSBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfSwgW3N0b3JlLCB3cmFwcGVyUHJvcHNdKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZSA9IChyZWFjdExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcbiAgICAgICAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY2hpbGRQcm9wc1NlbGVjdG9yLFxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgICAgIGxhc3RDaGlsZFByb3BzLFxuICAgICAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgICAgICBpc01vdW50ZWQsXG4gICAgICAgICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLFxuICAgICAgICAgICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgICAgfSwgW3N1YnNjcmlwdGlvbl0pO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGNhcHR1cmVXcmFwcGVyUHJvcHMsIFtcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcbiAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxuICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnNcbiAgICAgIF0pO1xuICAgICAgbGV0IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB0cnkge1xuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgLy8gVE9ETyBXZSdyZSBwYXNzaW5nIHRocm91Z2ggYSBiaWcgd3JhcHBlciB0aGF0IGRvZXMgYSBidW5jaCBvZiBleHRyYSBzaWRlIGVmZmVjdHMgYmVzaWRlcyBzdWJzY3JpYmluZ1xuICAgICAgICAgIHN1YnNjcmliZUZvclJlYWN0LFxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcbiAgICAgICAgICAvLyBUT0RPIGFuZCB3ZSdyZSBqdXN0IHBhc3NpbmcgdGhhdCB0aHJvdWdoIHNvIGl0IHRyaWdnZXJzIGEgcmUtcmVuZGVyIGZvciB1cyByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGB1U0VTYC5cbiAgICAgICAgICBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICA7XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYFxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcbiR7bGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrfVxuXG5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXG4gICAgICAgICAgICAgIHJlZjogcmVhY3RSZWR1eEZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0sIFtyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCBXcmFwcGVkQ29tcG9uZW50LCBhY3R1YWxDaGlsZFByb3BzXSk7XG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFRvVXNlLlByb3ZpZGVyLCB7IHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlIH0sIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfVxuICAgIGNvbnN0IF9Db25uZWN0ID0gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pO1xuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBDb25uZWN0RnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBpZiAoZm9yd2FyZFJlZikge1xuICAgICAgY29uc3QgX2ZvcndhcmRlZCA9IFJlYWN0LmZvcndhcmRSZWYoXG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcbiAgICAgIGZvcndhcmRlZC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgICAgZm9yd2FyZGVkLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xuICByZXR1cm4gd3JhcFdpdGhDb25uZWN0O1xufVxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Byb3ZpZGVyLnRzeFxuZnVuY3Rpb24gUHJvdmlkZXIocHJvdmlkZXJQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBjb250ZXh0LCBzZXJ2ZXJTdGF0ZSwgc3RvcmUgfSA9IHByb3ZpZGVyUHJvcHM7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgY29uc3QgYmFzZUNvbnRleHRWYWx1ZSA9IHtcbiAgICAgIHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgZ2V0U2VydmVyU3RhdGU6IHNlcnZlclN0YXRlID8gKCkgPT4gc2VydmVyU3RhdGUgOiB2b2lkIDBcbiAgICB9O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBiYXNlQ29udGV4dFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9IFwib25jZVwiLCBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiIH0gPSBwcm92aWRlclByb3BzO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKGJhc2VDb250ZXh0VmFsdWUsIHtcbiAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlXSk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHN0b3JlLmdldFN0YXRlKCksIFtzdG9yZV0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHZvaWQgMDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIGNvbnN0IENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcbn1cbnZhciBQcm92aWRlcl9kZWZhdWx0ID0gUHJvdmlkZXI7XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KVxuICApO1xuICBjb25zdCB1c2VTdG9yZTIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZTIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVN0b3JlMlxuICB9KTtcbiAgcmV0dXJuIHVzZVN0b3JlMjtcbn1cbnZhciB1c2VTdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTdG9yZUhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZURpc3BhdGNoLnRzXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIGNvbnN0IHVzZVN0b3JlMiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlU3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIGNvbnN0IHVzZURpc3BhdGNoMiA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlMigpO1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaDIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZURpc3BhdGNoMlxuICB9KTtcbiAgcmV0dXJuIHVzZURpc3BhdGNoMjtcbn1cbnZhciB1c2VEaXNwYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEaXNwYXRjaEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHsgZXF1YWxpdHlGbjogZXF1YWxpdHlGbk9yT3B0aW9ucyB9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvcmApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgYW4gZXF1YWxpdHkgZnVuY3Rpb24gdG8gdXNlU2VsZWN0b3JgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCB7IHN0b3JlLCBzdWJzY3JpcHRpb24sIGdldFNlcnZlclN0YXRlIH0gPSByZWR1eENvbnRleHQ7XG4gICAgY29uc3QgZmlyc3RSdW4gPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICB7XG4gICAgICAgIFtzZWxlY3Rvci5uYW1lXShzdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIHN0YWJpbGl0eUNoZWNrIH0gPSByZWR1eENvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjazogZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrOiBmaW5hbFN0YWJpbGl0eUNoZWNrXG4gICAgICAgICAgICB9ID0ge1xuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB0b0NvbXBhcmUgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgICAgIGlmICghZXF1YWxpdHlGbihzZWxlY3RlZCwgdG9Db21wYXJlKSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycy4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIGEgbmV3IHJlZmVyZW5jZSAoc3VjaCBhcyBhbiBvYmplY3Qgb3IgYW4gYXJyYXkpIHNob3VsZCBiZSBtZW1vaXplZDogaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdXNhZ2UvZGVyaXZpbmctZGF0YS1zZWxlY3RvcnMjb3B0aW1pemluZy1zZWxlY3RvcnMtd2l0aC1tZW1vaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkMjogdG9Db21wYXJlLFxuICAgICAgICAgICAgICAgICAgICBzdGFja1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCB0aGUgcm9vdCBzdGF0ZSB3aGVuIGNhbGxlZC4gVGhpcyBjYW4gbGVhZCB0byB1bm5lY2Vzc2FyeSByZXJlbmRlcnMuXFxuU2VsZWN0b3JzIHRoYXQgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUgYXJlIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlLCBhcyB0aGV5IHdpbGwgY2F1c2UgYSByZXJlbmRlciB3aGVuZXZlciAqYW55dGhpbmcqIGluIHN0YXRlIGNoYW5nZXMuXCIsXG4gICAgICAgICAgICAgICAgICB7IHN0YWNrIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudCkgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1bc2VsZWN0b3IubmFtZV0sXG4gICAgICBbc2VsZWN0b3JdXG4gICAgKTtcbiAgICBjb25zdCBzZWxlY3RlZFN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgICBzdWJzY3JpcHRpb24uYWRkTmVzdGVkU3ViLFxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSB8fCBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICAgIGVxdWFsaXR5Rm5cbiAgICApO1xuICAgIFJlYWN0LnVzZURlYnVnVmFsdWUoc2VsZWN0ZWRTdGF0ZSk7XG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odXNlU2VsZWN0b3IyLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcbiAgfSk7XG4gIHJldHVybiB1c2VTZWxlY3RvcjI7XG59XG52YXIgdXNlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2VsZWN0b3JIb29rKCk7XG5cbi8vIHNyYy9leHBvcnRzLnRzXG52YXIgYmF0Y2ggPSBkZWZhdWx0Tm9vcEJhdGNoO1xuZXhwb3J0IHtcbiAgUHJvdmlkZXJfZGVmYXVsdCBhcyBQcm92aWRlcixcbiAgUmVhY3RSZWR1eENvbnRleHQsXG4gIGJhdGNoLFxuICBjb25uZWN0X2RlZmF1bHQgYXMgY29ubmVjdCxcbiAgY3JlYXRlRGlzcGF0Y2hIb29rLFxuICBjcmVhdGVTZWxlY3Rvckhvb2ssXG4gIGNyZWF0ZVN0b3JlSG9vayxcbiAgc2hhbGxvd0VxdWFsLFxuICB1c2VEaXNwYXRjaCxcbiAgdXNlU2VsZWN0b3IsXG4gIHVzZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsIklTX1JFQUNUXzE5IiwidmVyc2lvbiIsInN0YXJ0c1dpdGgiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX0NPTlNVTUVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsIkZvcndhcmRSZWYiLCJNZW1vIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiZ2V0TW9kdWxlSWQiLCJ0eXBlT2YiLCJvYmplY3QiLCJpc0NvbnRleHRDb25zdW1lciIsImlzTWVtbyIsIndhcm5pbmciLCJtZXNzYWdlIiwiY29uc29sZSIsImVycm9yIiwiRXJyb3IiLCJlIiwidmVyaWZ5Iiwic2VsZWN0b3IiLCJtZXRob2ROYW1lIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmVyaWZ5U3Vic2VsZWN0b3JzIiwibWFwU3RhdGVUb1Byb3BzIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwibWVyZ2VQcm9wcyIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiZGlzcGF0Y2giLCJhcmVTdGF0ZXNFcXVhbCIsImFyZU93blByb3BzRXF1YWwiLCJhcmVTdGF0ZVByb3BzRXF1YWwiLCJoYXNSdW5BdExlYXN0T25jZSIsInN0YXRlIiwib3duUHJvcHMiLCJzdGF0ZVByb3BzIiwiZGlzcGF0Y2hQcm9wcyIsIm1lcmdlZFByb3BzIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiZGVwZW5kc09uT3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wcyIsImhhbmRsZU5ld1N0YXRlIiwibmV4dFN0YXRlUHJvcHMiLCJzdGF0ZVByb3BzQ2hhbmdlZCIsImhhbmRsZVN1YnNlcXVlbnRDYWxscyIsIm5leHRTdGF0ZSIsIm5leHRPd25Qcm9wcyIsInByb3BzQ2hhbmdlZCIsInN0YXRlQ2hhbmdlZCIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3IiLCJmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJwcm9jZXNzIiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiYWN0aW9uQ3JlYXRvcnMiLCJib3VuZEFjdGlvbkNyZWF0b3JzIiwia2V5IiwiYWN0aW9uQ3JlYXRvciIsImFyZ3MiLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImJhc2VQcm90byIsInZlcmlmeVBsYWluT2JqZWN0IiwidmFsdWUiLCJkaXNwbGF5TmFtZSIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiQm9vbGVhbiIsImxlbmd0aCIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImluaXRQcm94eVNlbGVjdG9yIiwicHJveHkiLCJtYXBUb1Byb3BzUHJveHkiLCJzdGF0ZU9yRGlzcGF0Y2giLCJkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IiwicHJvcHMiLCJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsImFyZyIsIm5hbWUiLCJ3cmFwcGVkQ29tcG9uZW50TmFtZSIsIm1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkiLCJtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE1lcmdlUHJvcHMiLCJ3cmFwTWVyZ2VQcm9wc0Z1bmMiLCJpbml0TWVyZ2VQcm9wc1Byb3h5IiwiYXJlTWVyZ2VkUHJvcHNFcXVhbCIsImhhc1J1bk9uY2UiLCJtZXJnZVByb3BzUHJveHkiLCJuZXh0TWVyZ2VkUHJvcHMiLCJtZXJnZVByb3BzRmFjdG9yeSIsImRlZmF1bHROb29wQmF0Y2giLCJjYWxsYmFjayIsImNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbiIsImZpcnN0IiwibGFzdCIsImNsZWFyIiwibm90aWZ5IiwibGlzdGVuZXIiLCJuZXh0IiwiZ2V0IiwibGlzdGVuZXJzIiwicHVzaCIsInN1YnNjcmliZSIsImlzU3Vic2NyaWJlZCIsInByZXYiLCJ1bnN1YnNjcmliZSIsIm51bGxMaXN0ZW5lcnMiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJzdG9yZSIsInBhcmVudFN1YiIsInN1YnNjcmlwdGlvbnNBbW91bnQiLCJzZWxmU3Vic2NyaWJlZCIsImFkZE5lc3RlZFN1YiIsInRyeVN1YnNjcmliZSIsImNsZWFudXBMaXN0ZW5lciIsInJlbW92ZWQiLCJ0cnlVbnN1YnNjcmliZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJoYW5kbGVDaGFuZ2VXcmFwcGVyIiwic3Vic2NyaXB0aW9uIiwib25TdGF0ZUNoYW5nZSIsInRyeVN1YnNjcmliZVNlbGYiLCJ0cnlVbnN1YnNjcmliZVNlbGYiLCJnZXRMaXN0ZW5lcnMiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc0RPTSIsImlzUnVubmluZ0luUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwiaXNSZWFjdE5hdGl2ZSIsImdldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiaXMiLCJ4IiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJpIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJkZWZhdWx0UHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJtaXhpbnMiLCJwcm9wVHlwZXMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJndW1lbnRzIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmplY3RQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImluaGVyaXRlZENvbXBvbmVudCIsImNvbmNhdCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiZGVzY3JpcHRvciIsIkNvbnRleHRLZXkiLCJnVCIsImdsb2JhbFRoaXMiLCJnZXRDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHRNYXAiLCJNYXAiLCJyZWFsQ29udGV4dCIsInNldCIsIlJlYWN0UmVkdXhDb250ZXh0IiwiTk9fU1VCU0NSSVBUSU9OX0FSUkFZIiwic3RyaW5naWZ5Q29tcG9uZW50IiwiQ29tcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnIiLCJTdHJpbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MiLCJlZmZlY3RGdW5jIiwiZWZmZWN0QXJncyIsImRlcGVuZGVuY2llcyIsImNhcHR1cmVXcmFwcGVyUHJvcHMiLCJsYXN0V3JhcHBlclByb3BzIiwibGFzdENoaWxkUHJvcHMiLCJyZW5kZXJJc1NjaGVkdWxlZCIsIndyYXBwZXJQcm9wcyIsImNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUiLCJjdXJyZW50Iiwic3Vic2NyaWJlVXBkYXRlcyIsInNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyIsImNoaWxkUHJvcHNTZWxlY3RvciIsImlzTW91bnRlZCIsImFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lciIsImRpZFVuc3Vic2NyaWJlIiwibGFzdFRocm93bkVycm9yIiwiY2hlY2tGb3JVcGRhdGVzIiwibGF0ZXN0U3RvcmVTdGF0ZSIsImdldFN0YXRlIiwibmV3Q2hpbGRQcm9wcyIsInVuc3Vic2NyaWJlV3JhcHBlciIsInN0cmljdEVxdWFsIiwiYSIsImIiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwiY29ubmVjdCIsInB1cmUiLCJmb3J3YXJkUmVmIiwiY29udGV4dCIsIkNvbnRleHQiLCJ3cmFwV2l0aENvbm5lY3QiLCJXcmFwcGVkQ29tcG9uZW50IiwiaXNWYWxpZCIsInNlbGVjdG9yRmFjdG9yeU9wdGlvbnMiLCJDb25uZWN0RnVuY3Rpb24iLCJwcm9wc0NvbnRleHQiLCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyIiwid3JhcHBlclByb3BzMiIsIkNvbnRleHRUb1VzZSIsIlJlc3VsdENvbnRleHQiLCJDb25zdW1lciIsImNvbnRleHRWYWx1ZSIsInVzZUNvbnRleHQiLCJkaWRTdG9yZUNvbWVGcm9tUHJvcHMiLCJkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCIsImdldFNlcnZlclN0YXRlIiwic3Vic2NyaXB0aW9uMiIsIm5vdGlmeU5lc3RlZFN1YnMyIiwiYmluZCIsIm92ZXJyaWRkZW5Db250ZXh0VmFsdWUiLCJ1c2VSZWYiLCJsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yIiwiYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yIiwic3Vic2NyaWJlRm9yUmVhY3QiLCJyZWFjdExpc3RlbmVyIiwiYWN0dWFsQ2hpbGRQcm9wcyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwic3RhY2siLCJyZW5kZXJlZFdyYXBwZWRDb21wb25lbnQiLCJyZWYiLCJyZW5kZXJlZENoaWxkIiwiUHJvdmlkZXIiLCJfQ29ubmVjdCIsIm1lbW8iLCJDb25uZWN0IiwiX2ZvcndhcmRlZCIsImZvcndhcmRDb25uZWN0UmVmIiwiZm9yd2FyZGVkIiwiY29ubmVjdF9kZWZhdWx0IiwicHJvdmlkZXJQcm9wcyIsImNoaWxkcmVuIiwic2VydmVyU3RhdGUiLCJiYXNlQ29udGV4dFZhbHVlIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwic3RhYmlsaXR5Q2hlY2siLCJhc3NpZ24iLCJwcmV2aW91c1N0YXRlIiwiUHJvdmlkZXJfZGVmYXVsdCIsImNyZWF0ZVJlZHV4Q29udGV4dEhvb2siLCJ1c2VSZWR1eENvbnRleHQyIiwidXNlUmVkdXhDb250ZXh0IiwiY3JlYXRlU3RvcmVIb29rIiwidXNlU3RvcmUyIiwid2l0aFR5cGVzIiwidXNlU3RvcmUiLCJjcmVhdGVEaXNwYXRjaEhvb2siLCJ1c2VEaXNwYXRjaDIiLCJ1c2VEaXNwYXRjaCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwicmVmRXF1YWxpdHkiLCJjcmVhdGVTZWxlY3Rvckhvb2siLCJ1c2VTZWxlY3RvcjIiLCJlcXVhbGl0eUZuT3JPcHRpb25zIiwiZXF1YWxpdHlGbiIsInJlZHV4Q29udGV4dCIsImZpcnN0UnVuIiwid3JhcHBlZFNlbGVjdG9yIiwidXNlQ2FsbGJhY2siLCJzZWxlY3RlZCIsImRldk1vZGVDaGVja3MiLCJmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayIsImZpbmFsU3RhYmlsaXR5Q2hlY2siLCJ0b0NvbXBhcmUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwic2VsZWN0ZWRTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJ1c2VTZWxlY3RvciIsImJhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/node_modules/react-redux/dist/react-redux.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@hello-pangea/dnd/node_modules/redux/dist/redux.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@hello-pangea/dnd/node_modules/redux/dist/redux.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* binding */ actionTypes_default),\n/* harmony export */   applyMiddleware: () => (/* binding */ applyMiddleware),\n/* harmony export */   bindActionCreators: () => (/* binding */ bindActionCreators),\n/* harmony export */   combineReducers: () => (/* binding */ combineReducers),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   legacy_createStore: () => (/* binding */ legacy_createStore)\n/* harmony export */ });\n// src/utils/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n// src/utils/symbol-observable.ts\nvar $$observable = /* @__PURE__ */ (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nvar symbol_observable_default = $$observable;\n// src/utils/actionTypes.ts\nvar randomString = ()=>Math.random().toString(36).substring(7).split(\"\").join(\".\");\nvar ActionTypes = {\n    INIT: `@@redux/INIT${randomString()}`,\n    REPLACE: `@@redux/REPLACE${randomString()}`,\n    PROBE_UNKNOWN_ACTION: ()=>`@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n};\nvar actionTypes_default = ActionTypes;\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    let proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n}\n// src/utils/kindOf.ts\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    const type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    const constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    }\n    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    let typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n// src/createStore.ts\nfunction createStore(reducer, preloadedState, enhancer) {\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = void 0;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    let currentReducer = reducer;\n    let currentState = preloadedState;\n    let currentListeners = /* @__PURE__ */ new Map();\n    let nextListeners = currentListeners;\n    let listenerIdCounter = 0;\n    let isDispatching = false;\n    function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = /* @__PURE__ */ new Map();\n            currentListeners.forEach((listener, key)=>{\n                nextListeners.set(key, listener);\n            });\n        }\n    }\n    function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        let isSubscribed = true;\n        ensureCanMutateNextListeners();\n        const listenerId = listenerIdCounter++;\n        nextListeners.set(listenerId, listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            nextListeners.delete(listenerId);\n            currentListeners = null;\n        };\n    }\n    function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (typeof action.type !== \"string\") {\n            throw new Error( false ? 0 : `Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        const listeners = currentListeners = nextListeners;\n        listeners.forEach((listener)=>{\n            listener();\n        });\n        return action;\n    }\n    function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);\n        }\n        currentReducer = nextReducer;\n        dispatch({\n            type: actionTypes_default.REPLACE\n        });\n    }\n    function observable() {\n        const outerSubscribe = subscribe;\n        return {\n            /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe (observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);\n                }\n                function observeState() {\n                    const observerAsObserver = observer;\n                    if (observerAsObserver.next) {\n                        observerAsObserver.next(getState());\n                    }\n                }\n                observeState();\n                const unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe\n                };\n            },\n            [symbol_observable_default] () {\n                return this;\n            }\n        };\n    }\n    dispatch({\n        type: actionTypes_default.INIT\n    });\n    const store = {\n        dispatch,\n        subscribe,\n        getState,\n        replaceReducer,\n        [symbol_observable_default]: observable\n    };\n    return store;\n}\nfunction legacy_createStore(reducer, preloadedState, enhancer) {\n    return createStore(reducer, preloadedState, enhancer);\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/combineReducers.ts\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n    const reducerKeys = Object.keys(reducers);\n    const argumentName = action && action.type === actionTypes_default.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n    if (reducerKeys.length === 0) {\n        return \"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\";\n    }\n    if (!isPlainObject(inputState)) {\n        return `The ${argumentName} has unexpected type of \"${kindOf(inputState)}\". Expected argument to be an object with the following keys: \"${reducerKeys.join('\", \"')}\"`;\n    }\n    const unexpectedKeys = Object.keys(inputState).filter((key)=>!reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n    unexpectedKeys.forEach((key)=>{\n        unexpectedKeyCache[key] = true;\n    });\n    if (action && action.type === actionTypes_default.REPLACE) return;\n    if (unexpectedKeys.length > 0) {\n        return `Unexpected ${unexpectedKeys.length > 1 ? \"keys\" : \"key\"} \"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. Expected to find one of the known reducer keys instead: \"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`;\n    }\n}\nfunction assertReducerShape(reducers) {\n    Object.keys(reducers).forEach((key)=>{\n        const reducer = reducers[key];\n        const initialState = reducer(void 0, {\n            type: actionTypes_default.INIT\n        });\n        if (typeof initialState === \"undefined\") {\n            throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n        }\n        if (typeof reducer(void 0, {\n            type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n        }) === \"undefined\") {\n            throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in \"redux/*\" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);\n        }\n    });\n}\nfunction combineReducers(reducers) {\n    const reducerKeys = Object.keys(reducers);\n    const finalReducers = {};\n    for(let i = 0; i < reducerKeys.length; i++){\n        const key = reducerKeys[i];\n        if (true) {\n            if (typeof reducers[key] === \"undefined\") {\n                warning(`No reducer provided for key \"${key}\"`);\n            }\n        }\n        if (typeof reducers[key] === \"function\") {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    const finalReducerKeys = Object.keys(finalReducers);\n    let unexpectedKeyCache;\n    if (true) {\n        unexpectedKeyCache = {};\n    }\n    let shapeAssertionError;\n    try {\n        assertReducerShape(finalReducers);\n    } catch (e) {\n        shapeAssertionError = e;\n    }\n    return function combination(state = {}, action) {\n        if (shapeAssertionError) {\n            throw shapeAssertionError;\n        }\n        if (true) {\n            const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n        }\n        let hasChanged = false;\n        const nextState = {};\n        for(let i = 0; i < finalReducerKeys.length; i++){\n            const key = finalReducerKeys[i];\n            const reducer = finalReducers[key];\n            const previousStateForKey = state[key];\n            const nextStateForKey = reducer(previousStateForKey, action);\n            if (typeof nextStateForKey === \"undefined\") {\n                const actionType = action && action.type;\n                throw new Error( false ? 0 : `When called with an action of type ${actionType ? `\"${String(actionType)}\"` : \"(unknown type)\"}, the slice reducer for key \"${key}\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);\n            }\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n        return hasChanged ? nextState : state;\n    };\n}\n// src/bindActionCreators.ts\nfunction bindActionCreator(actionCreator, dispatch) {\n    return function(...args) {\n        return dispatch(actionCreator.apply(this, args));\n    };\n}\nfunction bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n        return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n        throw new Error( false ? 0 : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`);\n    }\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n        }\n    }\n    return boundActionCreators;\n}\n// src/compose.ts\nfunction compose(...funcs) {\n    if (funcs.length === 0) {\n        return (arg)=>arg;\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce((a, b)=>(...args)=>a(b(...args)));\n}\n// src/applyMiddleware.ts\nfunction applyMiddleware(...middlewares) {\n    return (createStore2)=>(reducer, preloadedState)=>{\n            const store = createStore2(reducer, preloadedState);\n            let dispatch = ()=>{\n                throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.\");\n            };\n            const middlewareAPI = {\n                getState: store.getState,\n                dispatch: (action, ...args)=>dispatch(action, ...args)\n            };\n            const chain = middlewares.map((middleware)=>middleware(middlewareAPI));\n            dispatch = compose(...chain)(store.dispatch);\n            return {\n                ...store,\n                dispatch\n            };\n        };\n}\n// src/utils/isAction.ts\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n}\n //# sourceMappingURL=redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGhlbGxvLXBhbmdlYS9kbmQvbm9kZV9tb2R1bGVzL3JlZHV4L2Rpc3QvcmVkdXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHNDQUFzQztBQUN0QyxTQUFTQSx1QkFBdUJDLElBQUk7SUFDbEMsT0FBTyxDQUFDLHNCQUFzQixFQUFFQSxLQUFLLHlDQUF5QyxFQUFFQSxLQUFLLCtFQUErRSxDQUFDO0FBQ3ZLO0FBRUEsaUNBQWlDO0FBQ2pDLElBQUlDLGVBQStCLGFBQUgsR0FBSSxLQUFNLE9BQU9DLFdBQVcsY0FBY0EsT0FBT0MsVUFBVSxJQUFJLGNBQWE7QUFDNUcsSUFBSUMsNEJBQTRCSDtBQUVoQywyQkFBMkI7QUFDM0IsSUFBSUksZUFBZSxJQUFNQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDLElBQUlDLElBQUksQ0FBQztBQUNoRixJQUFJQyxjQUFjO0lBQ2hCQyxNQUFNLENBQUMsWUFBWSxFQUFrQlIsZUFBZSxDQUFDO0lBQ3JEUyxTQUFTLENBQUMsZUFBZSxFQUFrQlQsZUFBZSxDQUFDO0lBQzNEVSxzQkFBc0IsSUFBTSxDQUFDLDRCQUE0QixFQUFFVixlQUFlLENBQUM7QUFDN0U7QUFDQSxJQUFJVyxzQkFBc0JKO0FBRTFCLDZCQUE2QjtBQUM3QixTQUFTSyxjQUFjQyxHQUFHO0lBQ3hCLElBQUksT0FBT0EsUUFBUSxZQUFZQSxRQUFRLE1BQ3JDLE9BQU87SUFDVCxJQUFJQyxRQUFRRDtJQUNaLE1BQU9FLE9BQU9DLGNBQWMsQ0FBQ0YsV0FBVyxLQUFNO1FBQzVDQSxRQUFRQyxPQUFPQyxjQUFjLENBQUNGO0lBQ2hDO0lBQ0EsT0FBT0MsT0FBT0MsY0FBYyxDQUFDSCxTQUFTQyxTQUFTQyxPQUFPQyxjQUFjLENBQUNILFNBQVM7QUFDaEY7QUFFQSxzQkFBc0I7QUFDdEIsU0FBU0ksV0FBV0MsR0FBRztJQUNyQixJQUFJQSxRQUFRLEtB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O0FBQ3hCLFNBQVMrRCxTQUFTOUQsTUFBTTtJQUN0QixPQUFPdkQsY0FBY3VELFdBQVcsVUFBVUEsVUFBVSxPQUFPQSxPQUFPaEQsSUFBSSxLQUFLO0FBQzdFO0FBV0UsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9keW5hbWljLWRhdGEtdGFibGUtbWFuYWdlci8uL25vZGVfbW9kdWxlcy9AaGVsbG8tcGFuZ2VhL2RuZC9ub2RlX21vZHVsZXMvcmVkdXgvZGlzdC9yZWR1eC5tanM/NjYwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS50c1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cblxuLy8gc3JjL3V0aWxzL3N5bWJvbC1vYnNlcnZhYmxlLnRzXG52YXIgJCRvYnNlcnZhYmxlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgXCJAQG9ic2VydmFibGVcIikoKTtcbnZhciBzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0ID0gJCRvYnNlcnZhYmxlO1xuXG4vLyBzcmMvdXRpbHMvYWN0aW9uVHlwZXMudHNcbnZhciByYW5kb21TdHJpbmcgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoXCJcIikuam9pbihcIi5cIik7XG52YXIgQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6IGBAQHJlZHV4L0lOSVQkey8qIEBfX1BVUkVfXyAqLyByYW5kb21TdHJpbmcoKX1gLFxuICBSRVBMQUNFOiBgQEByZWR1eC9SRVBMQUNFJHsvKiBAX19QVVJFX18gKi8gcmFuZG9tU3RyaW5nKCl9YCxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046ICgpID0+IGBAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OJHtyYW5kb21TdHJpbmcoKX1gXG59O1xudmFyIGFjdGlvblR5cGVzX2RlZmF1bHQgPSBBY3Rpb25UeXBlcztcblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGxldCBwcm90byA9IG9iajtcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90byB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gbnVsbDtcbn1cblxuLy8gc3JjL3V0aWxzL2tpbmRPZi50c1xuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBpZiAodmFsID09PSBudWxsKVxuICAgIHJldHVybiBcIm51bGxcIjtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6IHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHJldHVybiBcImFycmF5XCI7XG4gIGlmIChpc0RhdGUodmFsKSlcbiAgICByZXR1cm4gXCJkYXRlXCI7XG4gIGlmIChpc0Vycm9yKHZhbCkpXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvck5hbWUpIHtcbiAgICBjYXNlIFwiU3ltYm9sXCI6XG4gICAgY2FzZSBcIlByb21pc2VcIjpcbiAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgIGNhc2UgXCJXZWFrU2V0XCI6XG4gICAgY2FzZSBcIk1hcFwiOlxuICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiB2YWwubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLmdldERhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgbGV0IHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVPZlZhbDtcbn1cblxuLy8gc3JjL2NyZWF0ZVN0b3JlLnRzXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IGBFeHBlY3RlZCB0aGUgcm9vdCByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2YocmVkdWNlcil9J2ApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZW5oYW5jZXIgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgwKSA6IFwiSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gY3JlYXRlU3RvcmUoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJbnN0ZWFkLCBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNjcmVhdGluZy1hLXN0b3JlLXdpdGgtZW5oYW5jZXJzIGZvciBhbiBleGFtcGxlLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGVuaGFuY2VyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IGBFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihlbmhhbmNlcil9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuICBsZXQgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICBsZXQgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIGxldCBjdXJyZW50TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICBsZXQgbGlzdGVuZXJJZENvdW50ZXIgPSAwO1xuICBsZXQgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGtleSkgPT4ge1xuICAgICAgICBuZXh0TGlzdGVuZXJzLnNldChrZXksIGxpc3RlbmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIFRoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gUGFzcyBpdCBkb3duIGZyb20gdGhlIHRvcCByZWR1Y2VyIGluc3RlYWQgb2YgcmVhZGluZyBpdCBmcm9tIHRoZSBzdG9yZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IGBFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihsaXN0ZW5lcil9J2ApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNSkgOiBcIllvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSBjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICB9XG4gICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIGNvbnN0IGxpc3RlbmVySWQgPSBsaXN0ZW5lcklkQ291bnRlcisrO1xuICAgIG5leHRMaXN0ZW5lcnMuc2V0KGxpc3RlbmVySWQsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IFwiWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgbmV4dExpc3RlbmVycy5kZWxldGUobGlzdGVuZXJJZCk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IGBBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbil9Jy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYW4gYWN0aW9uIHR5cGUgc3RyaW5nIGNvbnN0YW50LicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBgQWN0aW9uIFwidHlwZVwiIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcuIEluc3RlYWQsIHRoZSBhY3R1YWwgdHlwZSB3YXM6ICcke2tpbmRPZihhY3Rpb24udHlwZSl9Jy4gVmFsdWUgd2FzOiAnJHthY3Rpb24udHlwZX0nIChzdHJpbmdpZmllZClgKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IGBFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihuZXh0UmVkdWNlcil9YCk7XG4gICAgfVxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICBjb25zdCBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSBcIm9iamVjdFwiIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogYEV4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkOiAnJHtraW5kT2Yob2JzZXJ2ZXIpfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgY29uc3Qgb2JzZXJ2ZXJBc09ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlckFzT2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIFtzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0XSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gIH0pO1xuICBjb25zdCBzdG9yZSA9IHtcbiAgICBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXIsXG4gICAgW3N5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHRdOiBvYnNlcnZhYmxlXG4gIH07XG4gIHJldHVybiBzdG9yZTtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9jcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2NvbWJpbmVSZWR1Y2Vycy50c1xuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUID8gXCJwcmVsb2FkZWRTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmVcIiA6IFwicHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXJcIjtcbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlN0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuXCI7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIGBUaGUgJHthcmd1bWVudE5hbWV9IGhhcyB1bmV4cGVjdGVkIHR5cGUgb2YgXCIke2tpbmRPZihpbnB1dFN0YXRlKX1cIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCJgO1xuICB9XG4gIGNvbnN0IHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKChrZXkpID0+ICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IGFjdGlvblR5cGVzX2RlZmF1bHQuUkVQTEFDRSlcbiAgICByZXR1cm47XG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/IFwia2V5c1wiIDogXCJrZXlcIn0gXCIke3VuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpfVwiIGZvdW5kIGluICR7YXJndW1lbnROYW1lfS4gRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBcIiR7cmVkdWNlcktleXMuam9pbignXCIsIFwiJyl9XCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuYDtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5JTklUXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgdHlwZTogYWN0aW9uVHlwZXNfZGVmYXVsdC5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gRG9uJ3QgdHJ5IHRvIGhhbmRsZSAnJHthY3Rpb25UeXBlc19kZWZhdWx0LklOSVR9JyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiIG5hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC5gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIGNvbnN0IHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICBjb25zdCBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgd2FybmluZyhgTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJHtrZXl9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcbiAgbGV0IHVuZXhwZWN0ZWRLZXlDYWNoZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG4gIGxldCBzaGFwZUFzc2VydGlvbkVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgbmV4dFN0YXRlID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgY29uc3QgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgY29uc3QgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogYFdoZW4gY2FsbGVkIHdpdGggYW4gYWN0aW9uIG9mIHR5cGUgJHthY3Rpb25UeXBlID8gYFwiJHtTdHJpbmcoYWN0aW9uVHlwZSl9XCJgIDogXCIodW5rbm93biB0eXBlKVwifSwgdGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7a2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC4gVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLiBJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG4vLyBzcmMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gXCJvYmplY3RcIiB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IGBiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGJ1dCBpbnN0ZWFkIHJlY2VpdmVkOiAnJHtraW5kT2YoYWN0aW9uQ3JlYXRvcnMpfScuIERpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/YCk7XG4gIH1cbiAgY29uc3QgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIGNvbnN0IGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG4vLyBzcmMvY29tcG9zZS50c1xuZnVuY3Rpb24gY29tcG9zZSguLi5mdW5jcykge1xuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhcmcpID0+IGFyZztcbiAgfVxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoKGEsIGIpID0+ICguLi5hcmdzKSA9PiBhKGIoLi4uYXJncykpKTtcbn1cblxuLy8gc3JjL2FwcGx5TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gIHJldHVybiAoY3JlYXRlU3RvcmUyKSA9PiAocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlMihyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gICAgbGV0IGRpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJEaXNwYXRjaGluZyB3aGlsZSBjb25zdHJ1Y3RpbmcgeW91ciBtaWRkbGV3YXJlIGlzIG5vdCBhbGxvd2VkLiBPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guXCIpO1xuICAgIH07XG4gICAgY29uc3QgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGRpc3BhdGNoOiAoYWN0aW9uLCAuLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb24sIC4uLmFyZ3MpXG4gICAgfTtcbiAgICBjb25zdCBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcCgobWlkZGxld2FyZSkgPT4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKSk7XG4gICAgZGlzcGF0Y2ggPSBjb21wb3NlKC4uLmNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0b3JlLFxuICAgICAgZGlzcGF0Y2hcbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMvaXNBY3Rpb24udHNcbmZ1bmN0aW9uIGlzQWN0aW9uKGFjdGlvbikge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnQge1xuICBhY3Rpb25UeXBlc19kZWZhdWx0IGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMsXG4gIGFwcGx5TWlkZGxld2FyZSxcbiAgYmluZEFjdGlvbkNyZWF0b3JzLFxuICBjb21iaW5lUmVkdWNlcnMsXG4gIGNvbXBvc2UsXG4gIGNyZWF0ZVN0b3JlLFxuICBpc0FjdGlvbixcbiAgaXNQbGFpbk9iamVjdCxcbiAgbGVnYWN5X2NyZWF0ZVN0b3JlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6WyJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiY29kZSIsIiQkb2JzZXJ2YWJsZSIsIlN5bWJvbCIsIm9ic2VydmFibGUiLCJzeW1ib2xfb2JzZXJ2YWJsZV9kZWZhdWx0IiwicmFuZG9tU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwic3BsaXQiLCJqb2luIiwiQWN0aW9uVHlwZXMiLCJJTklUIiwiUkVQTEFDRSIsIlBST0JFX1VOS05PV05fQUNUSU9OIiwiYWN0aW9uVHlwZXNfZGVmYXVsdCIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwibWluaUtpbmRPZiIsInZhbCIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJpc0RhdGUiLCJpc0Vycm9yIiwiY29uc3RydWN0b3JOYW1lIiwiY3Rvck5hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdGFja1RyYWNlTGltaXQiLCJEYXRlIiwidG9EYXRlU3RyaW5nIiwiZ2V0RGF0ZSIsInNldERhdGUiLCJraW5kT2YiLCJ0eXBlT2ZWYWwiLCJwcm9jZXNzIiwiY3JlYXRlU3RvcmUiLCJyZWR1Y2VyIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlciIsImFyZ3VtZW50cyIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIk1hcCIsIm5leHRMaXN0ZW5lcnMiLCJsaXN0ZW5lcklkQ291bnRlciIsImlzRGlzcGF0Y2hpbmciLCJlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwia2V5Iiwic2V0IiwiZ2V0U3RhdGUiLCJzdWJzY3JpYmUiLCJpc1N1YnNjcmliZWQiLCJsaXN0ZW5lcklkIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImFjdGlvbiIsImxpc3RlbmVycyIsInJlcGxhY2VSZWR1Y2VyIiwibmV4dFJlZHVjZXIiLCJvdXRlclN1YnNjcmliZSIsIm9ic2VydmVyIiwib2JzZXJ2ZVN0YXRlIiwib2JzZXJ2ZXJBc09ic2VydmVyIiwibmV4dCIsInN0b3JlIiwibGVnYWN5X2NyZWF0ZVN0b3JlIiwid2FybmluZyIsImNvbnNvbGUiLCJlcnJvciIsImUiLCJnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlIiwiaW5wdXRTdGF0ZSIsInJlZHVjZXJzIiwidW5leHBlY3RlZEtleUNhY2hlIiwicmVkdWNlcktleXMiLCJrZXlzIiwiYXJndW1lbnROYW1lIiwibGVuZ3RoIiwidW5leHBlY3RlZEtleXMiLCJmaWx0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsImFzc2VydFJlZHVjZXJTaGFwZSIsImluaXRpYWxTdGF0ZSIsImNvbWJpbmVSZWR1Y2VycyIsImZpbmFsUmVkdWNlcnMiLCJpIiwiZmluYWxSZWR1Y2VyS2V5cyIsInNoYXBlQXNzZXJ0aW9uRXJyb3IiLCJjb21iaW5hdGlvbiIsInN0YXRlIiwid2FybmluZ01lc3NhZ2UiLCJoYXNDaGFuZ2VkIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZUZvcktleSIsIm5leHRTdGF0ZUZvcktleSIsImFjdGlvblR5cGUiLCJTdHJpbmciLCJiaW5kQWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3IiLCJhcmdzIiwiYXBwbHkiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwiZnVuY3MiLCJhcmciLCJyZWR1Y2UiLCJhIiwiYiIsImFwcGx5TWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiY3JlYXRlU3RvcmUyIiwibWlkZGxld2FyZUFQSSIsImNoYWluIiwibWFwIiwibWlkZGxld2FyZSIsImlzQWN0aW9uIiwiX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@hello-pangea/dnd/node_modules/redux/dist/redux.mjs\n");

/***/ })

};
;